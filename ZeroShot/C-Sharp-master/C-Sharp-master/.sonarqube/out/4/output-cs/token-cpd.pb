¯X
èC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\Algorithms\Problems\DynamicProgramming\CoinChange\DynamicCoinChangeSolver.cs
	namespace 	

Algorithms
 
. 
Problems 
. 
DynamicProgramming 0
.0 1

CoinChange1 ;
;; <
public 
static 
class #
DynamicCoinChangeSolver +
{ 
public 

static 
int 
[ 
] %
GenerateSingleCoinChanges 1
(1 2
int2 5
coin6 :
,: ;
int< ?
[? @
]@ A
coinsB G
)G H
{ 
ValidateCoin 
( 
coin 
) 
; 
ValidateCoinsArray 
( 
coins  
)  !
;! "
var 
coinsArrayCopy 
= 
new  
int! $
[$ %
coins% *
.* +
Length+ 1
]1 2
;2 3
Array 
. 
Copy 
( 
coins 
, 
coinsArrayCopy (
,( )
coins* /
./ 0
Length0 6
)6 7
;7 8
Array 
. 
Sort 
( 
coinsArrayCopy !
)! "
;" #
Array 
. 
Reverse 
( 
coinsArrayCopy $
)$ %
;% &
var 
list 
= 
new 
List 
< 
int 
>  
(  !
)! "
;" #
foreach 
( 
var 
item 
in 
coinsArrayCopy +
)+ ,
{ 	
if   
(   
item   
>   
coin   
)   
{!! 
continue"" 
;"" 
}## 
var%% 

difference%% 
=%% 
coin%% !
-%%" #
item%%$ (
;%%( )
list'' 
.'' 
Add'' 
('' 

difference'' 
)''  
;''  !
}(( 	
var** 
result** 
=** 
list** 
.** 
ToArray** !
(**! "
)**" #
;**# $
return,, 
result,, 
;,, 
}-- 
public77 

static77 

Dictionary77 
<77 
int77  
,77  !
int77" %
[77% &
]77& '
>77' (%
GenerateChangesDictionary77) B
(77B C
int77C F
coin77G K
,77K L
int77M P
[77P Q
]77Q R
coins77S X
)77X Y
{88 
var99 
dict99 
=99 
new99 

Dictionary99 !
<99! "
int99" %
,99% &
int99' *
[99* +
]99+ ,
>99, -
(99- .
)99. /
;99/ 0
var:: 
currentCoin:: 
=:: 
$num:: 
;:: 
while<< 
(<< 
currentCoin<< 
<=<< 
coin<< "
)<<" #
{== 	
var>> 
changeArray>> 
=>> %
GenerateSingleCoinChanges>> 7
(>>7 8
currentCoin>>8 C
,>>C D
coins>>E J
)>>J K
;>>K L
dict?? 
[?? 
currentCoin?? 
]?? 
=?? 
changeArray??  +
;??+ ,
currentCoin@@ 
++@@ 
;@@ 
}AA 	
returnCC 
dictCC 
;CC 
}DD 
publicNN 

staticNN 
intNN 
GetMinimalNextCoinNN (
(NN( )
intNN) ,
coinNN- 1
,NN1 2

DictionaryNN3 =
<NN= >
intNN> A
,NNA B
intNNC F
[NNF G
]NNG H
>NNH I
	exchangesNNJ S
)NNS T
{OO 
varPP 
nextCoinPP 
=PP 
intPP 
.PP 
MaxValuePP #
;PP# $
varQQ 
	minChangeQQ 
=QQ 
intQQ 
.QQ 
MaxValueQQ $
;QQ$ %
varSS 
coinChangesSS 
=SS 
	exchangesSS #
[SS# $
coinSS$ (
]SS( )
;SS) *
foreachUU 
(UU 
varUU 
changeUU 
inUU 
coinChangesUU *
)UU* +
{VV 	
ifWW 
(WW 
changeWW 
==WW 
$numWW 
)WW 
{XX 
returnYY 
$numYY 
;YY 
}ZZ 
var\\ 
currentChange\\ 
=\\ 
	exchanges\\  )
[\\) *
change\\* 0
]\\0 1
;\\1 2
var]] 
min]] 
=]] 
currentChange]] #
.]]# $
Min]]$ '
(]]' (
)]]( )
;]]) *
var__ 
minIsLesser__ 
=__ 
min__ !
<__" #
	minChange__$ -
;__- .
ifaa 
(aa 
minIsLesseraa 
)aa 
{bb 
nextCoincc 
=cc 
changecc !
;cc! "
	minChangedd 
=dd 
mindd 
;dd  
}ee 
}ff 	
returnhh 
nextCoinhh 
;hh 
}ii 
publicqq 

staticqq 
intqq 
[qq 
]qq !
MakeCoinChangeDynamicqq -
(qq- .
intqq. 1
coinqq2 6
,qq6 7
intqq8 ;
[qq; <
]qq< =
coinsqq> C
)qqC D
{rr 
varss 
changesTabless 
=ss %
GenerateChangesDictionaryss 4
(ss4 5
coinss5 9
,ss9 :
coinsss; @
)ss@ A
;ssA B
vartt 
listtt 
=tt 
newtt 
Listtt 
<tt 
inttt 
>tt  
(tt  !
)tt! "
;tt" #
varvv 
currentCoinvv 
=vv 
coinvv 
;vv 
varww 
nextCoinww 
=ww 
intww 
.ww 
MaxValueww #
;ww# $
whileyy 
(yy 
nextCoinyy 
!=yy 
$numyy 
)yy 
{zz 	
nextCoin{{ 
={{ 
GetMinimalNextCoin{{ )
({{) *
currentCoin{{* 5
,{{5 6
changesTable{{7 C
){{C D
;{{D E
var|| 

difference|| 
=|| 
currentCoin|| (
-||) *
nextCoin||+ 3
;||3 4
list}} 
.}} 
Add}} 
(}} 

difference}} 
)}}  
;}}  !
currentCoin~~ 
=~~ 
nextCoin~~ "
;~~" #
} 	
var
ÅÅ 
result
ÅÅ 
=
ÅÅ 
list
ÅÅ 
.
ÅÅ 
ToArray
ÅÅ !
(
ÅÅ! "
)
ÅÅ" #
;
ÅÅ# $
return
ÉÉ 
result
ÉÉ 
;
ÉÉ 
}
ÑÑ 
private
ÜÜ 
static
ÜÜ 
void
ÜÜ 
ValidateCoin
ÜÜ $
(
ÜÜ$ %
int
ÜÜ% (
coin
ÜÜ) -
)
ÜÜ- .
{
áá 
if
àà 

(
àà 
coin
àà 
<=
àà 
$num
àà 
)
àà 
{
ââ 	
throw
ää 
new
ää '
InvalidOperationException
ää /
(
ää/ 0
$"
ää0 2
$str
ää2 ]
{
ää] ^
nameof
ää^ d
(
ääd e
coin
ääe i
)
ääi j
}
ääj k
$str
ääk l
"
ääl m
)
ääm n
;
ään o
}
ãã 	
}
åå 
private
éé 
static
éé 
void
éé  
ValidateCoinsArray
éé *
(
éé* +
int
éé+ .
[
éé. /
]
éé/ 0

coinsArray
éé1 ;
)
éé; <
{
èè 
var
êê 
coinsAsArray
êê 
=
êê 

coinsArray
êê %
.
êê% &
ToArray
êê& -
(
êê- .
)
êê. /
;
êê/ 0
if
íí 

(
íí 
coinsAsArray
íí 
.
íí 
Length
íí 
==
íí  "
$num
íí# $
)
íí$ %
{
ìì 	
throw
îî 
new
îî '
InvalidOperationException
îî /
(
îî/ 0
$"
îî0 2
$str
îî2 N
{
îîN O
nameof
îîO U
(
îîU V
coinsAsArray
îîV b
)
îîb c
}
îîc d
$str
îîd e
"
îîe f
)
îîf g
;
îîg h
}
ïï 	
var
óó 
coinsContainOne
óó 
=
óó 
coinsAsArray
óó *
.
óó* +
Any
óó+ .
(
óó. /
x
óó/ 0
=>
óó1 3
x
óó4 5
==
óó6 8
$num
óó9 :
)
óó: ;
;
óó; <
if
ôô 

(
ôô 
!
ôô 
coinsContainOne
ôô 
)
ôô 
{
öö 	
throw
õõ 
new
õõ '
InvalidOperationException
õõ /
(
õõ/ 0
$"
õõ0 2
$str
õõ2 R
{
õõR S
nameof
õõS Y
(
õõY Z
coinsAsArray
õõZ f
)
õõf g
}
õõg h
$str
õõh i
"
õõi j
)
õõj k
;
õõk l
}
úú 	
var
ûû !
containsNonPositive
ûû 
=
ûû  !
coinsAsArray
ûû" .
.
ûû. /
Any
ûû/ 2
(
ûû2 3
x
ûû3 4
=>
ûû5 7
x
ûû8 9
<=
ûû: <
$num
ûû= >
)
ûû> ?
;
ûû? @
if
†† 

(
†† !
containsNonPositive
†† 
)
††  
{
°° 	
throw
¢¢ 
new
¢¢ '
InvalidOperationException
¢¢ /
(
¢¢/ 0
$"
££ 
{
££ 
nameof
££ 
(
££ 
coinsAsArray
££ &
)
££& '
}
££' (
$str
££( Z
"
££Z [
)
££[ \
;
££\ ]
}
§§ 	
var
¶¶  
containsDuplicates
¶¶ 
=
¶¶  
coinsAsArray
¶¶! -
.
¶¶- .
GroupBy
¶¶. 5
(
¶¶5 6
x
¶¶6 7
=>
¶¶8 :
x
¶¶; <
)
¶¶< =
.
¶¶= >
Any
¶¶> A
(
¶¶A B
g
¶¶B C
=>
¶¶D F
g
¶¶G H
.
¶¶H I
Count
¶¶I N
(
¶¶N O
)
¶¶O P
>
¶¶Q R
$num
¶¶S T
)
¶¶T U
;
¶¶U V
if
®® 

(
®®  
containsDuplicates
®® 
)
®® 
{
©© 	
throw
™™ 
new
™™ '
InvalidOperationException
™™ /
(
™™/ 0
$"
™™0 2
$str
™™2 X
{
™™X Y
nameof
™™Y _
(
™™_ `
coinsAsArray
™™` l
)
™™l m
}
™™m n
$str
™™n o
"
™™o p
)
™™p q
;
™™q r
}
´´ 	
}
¨¨ 
}≠≠ Âa
gC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\Algorithms\Other\RGBHSVConversion.cs
	namespace 	

Algorithms
 
. 
Other 
; 
public 
static 
class 
RgbHsvConversion $
{ 
public 

static 
( 
byte 
Red 
, 
byte !
Green" '
,' (
byte) -
Blue. 2
)2 3
HsvToRgb4 <
(< =
double 
hue 
, 
double 

saturation 
, 
double 
value 
) 
{ 
if 

( 
hue 
< 
$num 
|| 
hue 
> 
$num  
)  !
{ 	
throw   
new   '
ArgumentOutOfRangeException   1
(  1 2
nameof  2 8
(  8 9
hue  9 <
)  < =
,  = >
$"  ? A
{  A B
nameof  B H
(  H I
hue  I L
)  L M
}  M N
$str  N j
"  j k
)  k l
;  l m
}!! 	
if## 

(## 

saturation## 
<## 
$num## 
||## 

saturation## (
>##) *
$num##+ ,
)##, -
{$$ 	
throw%% 
new%% '
ArgumentOutOfRangeException%% 1
(%%1 2
nameof&& 
(&& 

saturation&& !
)&&! "
,&&" #
$"'' 
{'' 
nameof'' 
('' 

saturation'' $
)''$ %
}''% &
$str''& @
"''@ A
)''A B
;''B C
}(( 	
if** 

(** 
value** 
<** 
$num** 
||** 
value** 
>**  
$num**! "
)**" #
{++ 	
throw,, 
new,, '
ArgumentOutOfRangeException,, 1
(,,1 2
nameof,,2 8
(,,8 9
value,,9 >
),,> ?
,,,? @
$",,A C
{,,C D
nameof,,D J
(,,J K
value,,K P
),,P Q
},,Q R
$str,,R l
",,l m
),,m n
;,,n o
}-- 	
var// 
chroma// 
=// 
value// 
*// 

saturation// '
;//' (
var00 

hueSection00 
=00 
hue00 
/00 
$num00 !
;00! "
var11 "
secondLargestComponent11 "
=11# $
chroma11% +
*11, -
(11. /
$num11/ 0
-111 2
Math113 7
.117 8
Abs118 ;
(11; <

hueSection11< F
%11G H
$num11I J
-11K L
$num11M N
)11N O
)11O P
;11P Q
var22 

matchValue22 
=22 
value22 
-22  
chroma22! '
;22' (
return44 
GetRgbBySection44 
(44 

hueSection44 )
,44) *
chroma44+ 1
,441 2

matchValue443 =
,44= >"
secondLargestComponent44? U
)44U V
;44V W
}55 
public>> 

static>> 
(>> 
double>> 
Hue>> 
,>> 
double>> %

Saturation>>& 0
,>>0 1
double>>2 8
Value>>9 >
)>>> ?
RgbToHsv>>@ H
(>>H I
byte?? 
red?? 
,?? 
byte@@ 
green@@ 
,@@ 
byteAA 
blueAA 
)AA 
{BB 
varCC 
dRedCC 
=CC 
(CC 
doubleCC 
)CC 
redCC 
/CC  
$numCC! $
;CC$ %
varDD 
dGreenDD 
=DD 
(DD 
doubleDD 
)DD 
greenDD "
/DD# $
$numDD% (
;DD( )
varEE 
dBlueEE 
=EE 
(EE 
doubleEE 
)EE 
blueEE  
/EE! "
$numEE# &
;EE& '
varFF 
valueFF 
=FF 
MathFF 
.FF 
MaxFF 
(FF 
MathFF !
.FF! "
MaxFF" %
(FF% &
dRedFF& *
,FF* +
dGreenFF, 2
)FF2 3
,FF3 4
dBlueFF5 :
)FF: ;
;FF; <
varGG 
chromaGG 
=GG 
valueGG 
-GG 
MathGG !
.GG! "
MinGG" %
(GG% &
MathGG& *
.GG* +
MinGG+ .
(GG. /
dRedGG/ 3
,GG3 4
dGreenGG5 ;
)GG; <
,GG< =
dBlueGG> C
)GGC D
;GGD E
varHH 

saturationHH 
=HH 
valueHH 
.HH 
EqualsHH %
(HH% &
$numHH& '
)HH' (
?HH) *
$numHH+ ,
:HH- .
chromaHH/ 5
/HH6 7
valueHH8 =
;HH= >
doubleII 
hueII 
;II 
ifKK 

(KK 
chromaKK 
.KK 
EqualsKK 
(KK 
$numKK 
)KK 
)KK 
{LL 	
hueMM 
=MM 
$numMM 
;MM 
}NN 	
elseOO 
ifOO 
(OO 
valueOO 
.OO 
EqualsOO 
(OO 
dRedOO "
)OO" #
)OO# $
{PP 	
hueQQ 
=QQ 
$numQQ 
*QQ 
(QQ 
$numQQ 
+QQ 
(QQ 
dGreenQQ #
-QQ$ %
dBlueQQ& +
)QQ+ ,
/QQ- .
chromaQQ/ 5
)QQ5 6
;QQ6 7
}RR 	
elseSS 
ifSS 
(SS 
valueSS 
.SS 
EqualsSS 
(SS 
dGreenSS $
)SS$ %
)SS% &
{TT 	
hueUU 
=UU 
$numUU 
*UU 
(UU 
$numUU 
+UU 
(UU 
dBlueUU "
-UU# $
dRedUU% )
)UU) *
/UU+ ,
chromaUU- 3
)UU3 4
;UU4 5
}VV 	
elseWW 
{XX 	
hueYY 
=YY 
$numYY 
*YY 
(YY 
$numYY 
+YY 
(YY 
dRedYY !
-YY" #
dGreenYY$ *
)YY* +
/YY, -
chromaYY. 4
)YY4 5
;YY5 6
}ZZ 	
hue\\ 
=\\ 
(\\ 
hue\\ 
+\\ 
$num\\ 
)\\ 
%\\ 
$num\\ 
;\\  
return^^ 
(^^ 
hue^^ 
,^^ 

saturation^^ 
,^^  
value^^! &
)^^& '
;^^' (
}__ 
privateaa 
staticaa 
(aa 
byteaa 
Redaa 
,aa 
byteaa "
Greenaa# (
,aa( )
byteaa* .
Blueaa/ 3
)aa3 4
GetRgbBySectionaa5 D
(aaD E
doublebb 

hueSectionbb 
,bb 
doublecc 
chromacc 
,cc 
doubledd 

matchValuedd 
,dd 
doubleee "
secondLargestComponentee %
)ee% &
{ff 
bytegg 
redgg 
;gg 
bytehh 
greenhh 
;hh 
byteii 
blueii 
;ii 
ifkk 

(kk 

hueSectionkk 
>=kk 
$numkk 
&&kk 

hueSectionkk )
<=kk* ,
$numkk- .
)kk. /
{ll 	
redmm 
=mm 
ConvertToBytemm 
(mm  
chromamm  &
+mm' (

matchValuemm) 3
)mm3 4
;mm4 5
greennn 
=nn 
ConvertToBytenn !
(nn! ""
secondLargestComponentnn" 8
+nn9 :

matchValuenn; E
)nnE F
;nnF G
blueoo 
=oo 
ConvertToByteoo  
(oo  !

matchValueoo! +
)oo+ ,
;oo, -
}pp 	
elseqq 
ifqq 
(qq 

hueSectionqq 
>qq 
$numqq 
&&qq  "

hueSectionqq# -
<=qq. 0
$numqq1 2
)qq2 3
{rr 	
redss 
=ss 
ConvertToBytess 
(ss  "
secondLargestComponentss  6
+ss7 8

matchValuess9 C
)ssC D
;ssD E
greentt 
=tt 
ConvertToBytett !
(tt! "
chromatt" (
+tt) *

matchValuett+ 5
)tt5 6
;tt6 7
blueuu 
=uu 
ConvertToByteuu  
(uu  !

matchValueuu! +
)uu+ ,
;uu, -
}vv 	
elseww 
ifww 
(ww 

hueSectionww 
>ww 
$numww 
&&ww  "

hueSectionww# -
<=ww. 0
$numww1 2
)ww2 3
{xx 	
redyy 
=yy 
ConvertToByteyy 
(yy  

matchValueyy  *
)yy* +
;yy+ ,
greenzz 
=zz 
ConvertToBytezz !
(zz! "
chromazz" (
+zz) *

matchValuezz+ 5
)zz5 6
;zz6 7
blue{{ 
={{ 
ConvertToByte{{  
({{  !"
secondLargestComponent{{! 7
+{{8 9

matchValue{{: D
){{D E
;{{E F
}|| 	
else}} 
if}} 
(}} 

hueSection}} 
>}} 
$num}} 
&&}}  "

hueSection}}# -
<=}}. 0
$num}}1 2
)}}2 3
{~~ 	
red 
= 
ConvertToByte 
(  

matchValue  *
)* +
;+ ,
green
ÄÄ 
=
ÄÄ 
ConvertToByte
ÄÄ !
(
ÄÄ! "$
secondLargestComponent
ÄÄ" 8
+
ÄÄ9 :

matchValue
ÄÄ; E
)
ÄÄE F
;
ÄÄF G
blue
ÅÅ 
=
ÅÅ 
ConvertToByte
ÅÅ  
(
ÅÅ  !
chroma
ÅÅ! '
+
ÅÅ( )

matchValue
ÅÅ* 4
)
ÅÅ4 5
;
ÅÅ5 6
}
ÇÇ 	
else
ÉÉ 
if
ÉÉ 
(
ÉÉ 

hueSection
ÉÉ 
>
ÉÉ 
$num
ÉÉ 
&&
ÉÉ  "

hueSection
ÉÉ# -
<=
ÉÉ. 0
$num
ÉÉ1 2
)
ÉÉ2 3
{
ÑÑ 	
red
ÖÖ 
=
ÖÖ 
ConvertToByte
ÖÖ 
(
ÖÖ  $
secondLargestComponent
ÖÖ  6
+
ÖÖ7 8

matchValue
ÖÖ9 C
)
ÖÖC D
;
ÖÖD E
green
ÜÜ 
=
ÜÜ 
ConvertToByte
ÜÜ !
(
ÜÜ! "

matchValue
ÜÜ" ,
)
ÜÜ, -
;
ÜÜ- .
blue
áá 
=
áá 
ConvertToByte
áá  
(
áá  !
chroma
áá! '
+
áá( )

matchValue
áá* 4
)
áá4 5
;
áá5 6
}
àà 	
else
ââ 
{
ää 	
red
ãã 
=
ãã 
ConvertToByte
ãã 
(
ãã  
chroma
ãã  &
+
ãã' (

matchValue
ãã) 3
)
ãã3 4
;
ãã4 5
green
åå 
=
åå 
ConvertToByte
åå !
(
åå! "

matchValue
åå" ,
)
åå, -
;
åå- .
blue
çç 
=
çç 
ConvertToByte
çç  
(
çç  !$
secondLargestComponent
çç! 7
+
çç8 9

matchValue
çç: D
)
ççD E
;
ççE F
}
éé 	
return
êê 
(
êê 
red
êê 
,
êê 
green
êê 
,
êê 
blue
êê  
)
êê  !
;
êê! "
}
ëë 
private
ìì 
static
ìì 
byte
ìì 
ConvertToByte
ìì %
(
ìì% &
double
ìì& ,
input
ìì- 2
)
ìì2 3
=>
ìì4 6
(
ìì7 8
byte
ìì8 <
)
ìì< =
Math
ìì= A
.
ììA B
Round
ììB G
(
ììG H
$num
ììH K
*
ììL M
input
ììN S
)
ììS T
;
ììT U
}îî à]
aC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\Algorithms\Other\Mandelbrot.cs
	namespace 	

Algorithms
 
. 
Other 
; 
public 
static 
class 

Mandelbrot 
{ 
private 
const 
byte 
Alpha 
= 
$num "
;" #
public,, 

static,, 
SKBitmap,, 
	GetBitmap,, $
(,,$ %
int-- 
bitmapWidth-- 
=-- 
$num-- 
,-- 
int.. 
bitmapHeight.. 
=.. 
$num.. 
,.. 
double// 
figureCenterX// 
=// 
-//  
$num//  #
,//# $
double00 
figureCenterY00 
=00 
$num00  
,00  !
double11 
figureWidth11 
=11 
$num11  
,11  !
int22 
maxStep22 
=22 
$num22 
,22 
bool33 "
useDistanceColorCoding33 #
=33$ %
true33& *
)33* +
{44 
if55 

(55 
bitmapWidth55 
<=55 
$num55 
)55 
{66 	
throw77 
new77 '
ArgumentOutOfRangeException77 1
(771 2
nameof88 
(88 
bitmapWidth88 "
)88" #
,88# $
$"99 
{99 
nameof99 
(99 
bitmapWidth99 %
)99% &
}99& '
$str99' C
"99C D
)99D E
;99E F
}:: 	
if<< 

(<< 
bitmapHeight<< 
<=<< 
$num<< 
)<< 
{== 	
throw>> 
new>> '
ArgumentOutOfRangeException>> 1
(>>1 2
nameof?? 
(?? 
bitmapHeight?? #
)??# $
,??$ %
$"@@ 
{@@ 
nameof@@ 
(@@ 
bitmapHeight@@ &
)@@& '
}@@' (
$str@@( D
"@@D E
)@@E F
;@@F G
}AA 	
ifCC 

(CC 
maxStepCC 
<=CC 
$numCC 
)CC 
{DD 	
throwEE 
newEE '
ArgumentOutOfRangeExceptionEE 1
(EE1 2
nameofFF 
(FF 
maxStepFF 
)FF 
,FF  
$"GG 
{GG 
nameofGG 
(GG 
maxStepGG !
)GG! "
}GG" #
$strGG# ?
"GG? @
)GG@ A
;GGA B
}HH 	
varJJ 
bitmapJJ 
=JJ 
newJJ 
SKBitmapJJ !
(JJ! "
bitmapWidthJJ" -
,JJ- .
bitmapHeightJJ/ ;
)JJ; <
;JJ< =
varKK 
figureHeightKK 
=KK 
figureWidthKK &
/KK' (
bitmapWidthKK) 4
*KK5 6
bitmapHeightKK7 C
;KKC D
forNN 
(NN 
varNN 
bitmapXNN 
=NN 
$numNN 
;NN 
bitmapXNN %
<NN& '
bitmapWidthNN( 3
;NN3 4
bitmapXNN5 <
++NN< >
)NN> ?
{OO 	
forPP 
(PP 
varPP 
bitmapYPP 
=PP 
$numPP  
;PP  !
bitmapYPP" )
<PP* +
bitmapHeightPP, 8
;PP8 9
bitmapYPP: A
++PPA C
)PPC D
{QQ 
varSS 
figureXSS 
=SS 
figureCenterXSS +
+SS, -
(SS. /
(SS/ 0
doubleSS0 6
)SS6 7
bitmapXSS7 >
/SS? @
bitmapWidthSSA L
-SSM N
$numSSO R
)SSR S
*SST U
figureWidthSSV a
;SSa b
varTT 
figureYTT 
=TT 
figureCenterYTT +
+TT, -
(TT. /
(TT/ 0
doubleTT0 6
)TT6 7
bitmapYTT7 >
/TT? @
bitmapHeightTTA M
-TTN O
$numTTP S
)TTS T
*TTU V
figureHeightTTW c
;TTc d
varVV 
distanceVV 
=VV 
GetDistanceVV *
(VV* +
figureXVV+ 2
,VV2 3
figureYVV4 ;
,VV; <
maxStepVV= D
)VVD E
;VVE F
bitmapYY 
.YY 
SetPixelYY 
(YY  
bitmapXZZ 
,ZZ 
bitmapY[[ 
,[[ "
useDistanceColorCoding\\ *
?\\+ ,
ColorCodedColorMap\\- ?
(\\? @
distance\\@ H
)\\H I
:\\J K!
BlackAndWhiteColorMap\\L a
(\\a b
distance\\b j
)\\j k
)\\k l
;\\l m
}]] 
}^^ 	
return`` 
bitmap`` 
;`` 
}aa 
privateii 
staticii 
SKColorii !
BlackAndWhiteColorMapii 0
(ii0 1
doubleii1 7
distanceii8 @
)ii@ A
=>iiB D
distancejj 
>=jj 
$numjj 
?kk 
newkk 
SKColorkk 
(kk 
$numkk 
,kk 
$numkk 
,kk 
$numkk  !
,kk! "
Alphakk# (
)kk( )
:ll 
newll 
SKColorll 
(ll 
$numll 
,ll 
$numll "
,ll" #
$numll$ '
,ll' (
Alphall) .
)ll. /
;ll/ 0
privatett 
statictt 
SKColortt 
ColorCodedColorMaptt -
(tt- .
doublett. 4
distancett5 =
)tt= >
{uu 
ifvv 

(vv 
distancevv 
>=vv 
$numvv 
)vv 
{ww 	
returnxx 
newxx 
SKColorxx 
(xx 
$numxx  
,xx  !
$numxx" #
,xx# $
$numxx% &
,xx& '
Alphaxx( -
)xx- .
;xx. /
}yy 	
var}} 
hue}} 
=}} 
$num}} 
*}} 
distance}}  
;}}  !
double~~ 

saturation~~ 
=~~ 
$num~~ 
;~~ 
double 
val 
= 
$num 
; 
var
ÄÄ 
hi
ÄÄ 
=
ÄÄ 
(
ÄÄ 
int
ÄÄ 
)
ÄÄ 
Math
ÄÄ 
.
ÄÄ 
Floor
ÄÄ  
(
ÄÄ  !
hue
ÄÄ! $
/
ÄÄ% &
$num
ÄÄ' )
)
ÄÄ) *
%
ÄÄ+ ,
$num
ÄÄ- .
;
ÄÄ. /
var
ÅÅ 
f
ÅÅ 
=
ÅÅ 
hue
ÅÅ 
/
ÅÅ 
$num
ÅÅ 
-
ÅÅ 
Math
ÅÅ 
.
ÅÅ  
Floor
ÅÅ  %
(
ÅÅ% &
hue
ÅÅ& )
/
ÅÅ* +
$num
ÅÅ, .
)
ÅÅ. /
;
ÅÅ/ 0
var
ÉÉ 
v
ÉÉ 
=
ÉÉ 
(
ÉÉ 
byte
ÉÉ 
)
ÉÉ 
val
ÉÉ 
;
ÉÉ 
const
ÑÑ 
byte
ÑÑ 
p
ÑÑ 
=
ÑÑ 
$num
ÑÑ 
;
ÑÑ 
var
ÖÖ 
q
ÖÖ 
=
ÖÖ 
(
ÖÖ 
byte
ÖÖ 
)
ÖÖ 
(
ÖÖ 
val
ÖÖ 
*
ÖÖ 
(
ÖÖ 
$num
ÖÖ 
-
ÖÖ  !
f
ÖÖ" #
*
ÖÖ$ %

saturation
ÖÖ& 0
)
ÖÖ0 1
)
ÖÖ1 2
;
ÖÖ2 3
var
ÜÜ 
t
ÜÜ 
=
ÜÜ 
(
ÜÜ 
byte
ÜÜ 
)
ÜÜ 
(
ÜÜ 
val
ÜÜ 
*
ÜÜ 
(
ÜÜ 
$num
ÜÜ 
-
ÜÜ  !
(
ÜÜ" #
$num
ÜÜ# $
-
ÜÜ% &
f
ÜÜ' (
)
ÜÜ( )
*
ÜÜ* +

saturation
ÜÜ, 6
)
ÜÜ6 7
)
ÜÜ7 8
;
ÜÜ8 9
switch
àà 
(
àà 
hi
àà 
)
àà 
{
ââ 	
case
ää 
$num
ää 
:
ää 
return
ää 
new
ää 
SKColor
ää &
(
ää& '
v
ää' (
,
ää( )
t
ää* +
,
ää+ ,
p
ää- .
,
ää. /
Alpha
ää0 5
)
ää5 6
;
ää6 7
case
ãã 
$num
ãã 
:
ãã 
return
ãã 
new
ãã 
SKColor
ãã &
(
ãã& '
q
ãã' (
,
ãã( )
v
ãã* +
,
ãã+ ,
p
ãã- .
,
ãã. /
Alpha
ãã0 5
)
ãã5 6
;
ãã6 7
case
åå 
$num
åå 
:
åå 
return
åå 
new
åå 
SKColor
åå &
(
åå& '
p
åå' (
,
åå( )
v
åå* +
,
åå+ ,
t
åå- .
,
åå. /
Alpha
åå0 5
)
åå5 6
;
åå6 7
case
çç 
$num
çç 
:
çç 
return
çç 
new
çç 
SKColor
çç &
(
çç& '
p
çç' (
,
çç( )
q
çç* +
,
çç+ ,
v
çç- .
,
çç. /
Alpha
çç0 5
)
çç5 6
;
çç6 7
case
éé 
$num
éé 
:
éé 
return
éé 
new
éé 
SKColor
éé &
(
éé& '
t
éé' (
,
éé( )
p
éé* +
,
éé+ ,
v
éé- .
,
éé. /
Alpha
éé0 5
)
éé5 6
;
éé6 7
default
èè 
:
èè 
return
èè 
new
èè 
SKColor
èè  '
(
èè' (
v
èè( )
,
èè) *
p
èè+ ,
,
èè, -
q
èè. /
,
èè/ 0
Alpha
èè1 6
)
èè6 7
;
èè7 8
}
êê 	
}
ëë 
private
úú 
static
úú 
double
úú 
GetDistance
úú %
(
úú% &
double
úú& ,
figureX
úú- 4
,
úú4 5
double
úú6 <
figureY
úú= D
,
úúD E
int
úúF I
maxStep
úúJ Q
)
úúQ R
{
ùù 
var
ûû 
a
ûû 
=
ûû 
figureX
ûû 
;
ûû 
var
üü 
b
üü 
=
üü 
figureY
üü 
;
üü 
var
†† 
currentStep
†† 
=
†† 
$num
†† 
;
†† 
for
°° 
(
°° 
var
°° 
step
°° 
=
°° 
$num
°° 
;
°° 
step
°° 
<
°°  !
maxStep
°°" )
;
°°) *
step
°°+ /
++
°°/ 1
)
°°1 2
{
¢¢ 	
currentStep
££ 
=
££ 
step
££ 
;
££ 
var
§§ 
aNew
§§ 
=
§§ 
a
§§ 
*
§§ 
a
§§ 
-
§§ 
b
§§  
*
§§! "
b
§§# $
+
§§% &
figureX
§§' .
;
§§. /
b
•• 
=
•• 
$num
•• 
*
•• 
a
•• 
*
•• 
b
•• 
+
•• 
figureY
•• #
;
••# $
a
¶¶ 
=
¶¶ 
aNew
¶¶ 
;
¶¶ 
if
™™ 
(
™™ 
a
™™ 
*
™™ 
a
™™ 
+
™™ 
b
™™ 
*
™™ 
b
™™ 
>
™™ 
$num
™™  !
)
™™! "
{
´´ 
break
¨¨ 
;
¨¨ 
}
≠≠ 
}
ÆÆ 	
return
∞∞ 
(
∞∞ 
double
∞∞ 
)
∞∞ 
currentStep
∞∞ "
/
∞∞# $
(
∞∞% &
maxStep
∞∞& -
-
∞∞. /
$num
∞∞0 1
)
∞∞1 2
;
∞∞2 3
}
±± 
}≤≤ ÒW
dC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\Algorithms\Other\KochSnowflake.cs
	namespace 	

Algorithms
 
. 
Other 
; 
public 
static 
class 
KochSnowflake !
{ 
public%% 

static%% 
List%% 
<%% 
Vector2%% 
>%% 
Iterate%%  '
(%%' (
List%%( ,
<%%, -
Vector2%%- 4
>%%4 5
initialVectors%%6 D
,%%D E
int%%F I
steps%%J O
=%%P Q
$num%%R S
)%%S T
{&& 
List'' 
<'' 
Vector2'' 
>'' 
vectors'' 
='' 
initialVectors''  .
;''. /
for(( 
((( 
var(( 
i(( 
=(( 
$num(( 
;(( 
i(( 
<(( 
steps(( !
;((! "
i((# $
++(($ &
)((& '
{)) 	
vectors** 
=** 
IterationStep** #
(**# $
vectors**$ +
)**+ ,
;**, -
}++ 	
return-- 
vectors-- 
;-- 
}.. 
public77 

static77 
SKBitmap77 
GetKochSnowflake77 +
(77+ ,
int88 
bitmapWidth88 
=88 
$num88 
,88 
int99 
steps99 
=99 
$num99 
)99 
{:: 
if;; 

(;; 
bitmapWidth;; 
<=;; 
$num;; 
);; 
{<< 	
throw== 
new== '
ArgumentOutOfRangeException== 1
(==1 2
nameof>> 
(>> 
bitmapWidth>> "
)>>" #
,>># $
$"?? 
{?? 
nameof?? 
(?? 
bitmapWidth?? %
)??% &
}??& '
$str??' C
"??C D
)??D E
;??E F
}@@ 	
varBB 
offsetXBB 
=BB 
bitmapWidthBB !
/BB" #
$numBB$ '
;BB' (
varCC 
offsetYCC 
=CC 
bitmapWidthCC !
/CC" #
$numCC$ (
;CC( )
varDD 
vector1DD 
=DD 
newDD 
Vector2DD !
(DD! "
offsetXDD" )
,DD) *
offsetYDD+ 2
)DD2 3
;DD3 4
varEE 
vector2EE 
=EE 
newEE 
Vector2EE !
(EE! "
bitmapWidthEE" -
/EE. /
$numEE0 1
,EE1 2
(EE3 4
floatEE4 9
)EE9 :
MathEE: >
.EE> ?
SinEE? B
(EEB C
MathEEC G
.EEG H
PIEEH J
/EEK L
$numEEM N
)EEN O
*EEP Q
bitmapWidthEER ]
*EE^ _
$numEE` d
+EEe f
offsetYEEg n
)EEn o
;EEo p
varFF 
vector3FF 
=FF 
newFF 
Vector2FF !
(FF! "
bitmapWidthFF" -
-FF. /
offsetXFF0 7
,FF7 8
offsetYFF9 @
)FF@ A
;FFA B
ListGG 
<GG 
Vector2GG 
>GG 
initialVectorsGG $
=GG% &
newGG' *
(GG* +
)GG+ ,
{GG- .
vector1GG/ 6
,GG6 7
vector2GG8 ?
,GG? @
vector3GGA H
,GGH I
vector1GGJ Q
}GGR S
;GGS T
ListHH 
<HH 
Vector2HH 
>HH 
vectorsHH 
=HH 
IterateHH  '
(HH' (
initialVectorsHH( 6
,HH6 7
stepsHH8 =
)HH= >
;HH> ?
returnII 
	GetBitmapII 
(II 
vectorsII  
,II  !
bitmapWidthII" -
,II- .
bitmapWidthII/ :
)II: ;
;II; <
}JJ 
privateWW 
staticWW 
ListWW 
<WW 
Vector2WW 
>WW  
IterationStepWW! .
(WW. /
ListWW/ 3
<WW3 4
Vector2WW4 ;
>WW; <
vectorsWW= D
)WWD E
{XX 
ListYY 
<YY 
Vector2YY 
>YY 

newVectorsYY  
=YY! "
newYY# &
(YY& '
)YY' (
;YY( )
forZZ 
(ZZ 
varZZ 
iZZ 
=ZZ 
$numZZ 
;ZZ 
iZZ 
<ZZ 
vectorsZZ #
.ZZ# $
CountZZ$ )
-ZZ* +
$numZZ, -
;ZZ- .
iZZ/ 0
++ZZ0 2
)ZZ2 3
{[[ 	
var\\ 
startVector\\ 
=\\ 
vectors\\ %
[\\% &
i\\& '
]\\' (
;\\( )
var]] 
	endVector]] 
=]] 
vectors]] #
[]]# $
i]]$ %
+]]& '
$num]]( )
]]]) *
;]]* +

newVectors^^ 
.^^ 
Add^^ 
(^^ 
startVector^^ &
)^^& '
;^^' (
var__ 
differenceVector__  
=__! "
	endVector__# ,
-__- .
startVector__/ :
;__: ;

newVectors`` 
.`` 
Add`` 
(`` 
startVector`` &
+``' (
differenceVector``) 9
/``: ;
$num``< =
)``= >
;``> ?

newVectorsaa 
.aa 
Addaa 
(aa 
startVectoraa &
+aa' (
differenceVectoraa) 9
/aa: ;
$numaa< =
+aa> ?
Rotateaa@ F
(aaF G
differenceVectoraaG W
/aaX Y
$numaaZ [
,aa[ \
$numaa] _
)aa_ `
)aa` a
;aaa b

newVectorsbb 
.bb 
Addbb 
(bb 
startVectorbb &
+bb' (
differenceVectorbb) 9
*bb: ;
$numbb< =
/bb> ?
$numbb@ A
)bbA B
;bbB C
}cc 	

newVectorsee 
.ee 
Addee 
(ee 
vectorsee 
[ee 
^ee  
$numee  !
]ee! "
)ee" #
;ee# $
returnff 

newVectorsff 
;ff 
}gg 
privatepp 
staticpp 
Vector2pp 
Rotatepp !
(pp! "
Vector2pp" )
vectorpp* 0
,pp0 1
floatpp2 7
angleInDegreespp8 F
)ppF G
{qq 
varrr 
radiansrr 
=rr 
angleInDegreesrr $
*rr% &
(rr' (
floatrr( -
)rr- .
Mathrr. 2
.rr2 3
PIrr3 5
/rr6 7
$numrr8 ;
;rr; <
varss 
cass 
=ss 
(ss 
floatss 
)ss 
Mathss 
.ss 
Cosss  
(ss  !
radiansss! (
)ss( )
;ss) *
vartt 
satt 
=tt 
(tt 
floattt 
)tt 
Mathtt 
.tt 
Sintt  
(tt  !
radianstt! (
)tt( )
;tt) *
returnuu 
newuu 
Vector2uu 
(uu 
cauu 
*uu 
vectoruu  &
.uu& '
Xuu' (
-uu) *
sauu+ -
*uu. /
vectoruu0 6
.uu6 7
Yuu7 8
,uu8 9
sauu: <
*uu= >
vectoruu? E
.uuE F
XuuF G
+uuH I
cauuJ L
*uuM N
vectoruuO U
.uuU V
YuuV W
)uuW X
;uuX Y
}vv 
private 
static 
SKBitmap 
	GetBitmap %
(% &
List
ÄÄ 
<
ÄÄ 
Vector2
ÄÄ 
>
ÄÄ 
vectors
ÄÄ 
,
ÄÄ 
int
ÅÅ 
bitmapWidth
ÅÅ 
,
ÅÅ 
int
ÇÇ 
bitmapHeight
ÇÇ 
)
ÇÇ 
{
ÉÉ 
SKBitmap
ÑÑ 
bitmap
ÑÑ 
=
ÑÑ 
new
ÑÑ 
(
ÑÑ 
bitmapWidth
ÑÑ )
,
ÑÑ) *
bitmapHeight
ÑÑ+ 7
)
ÑÑ7 8
;
ÑÑ8 9
var
ÖÖ 
canvas
ÖÖ 
=
ÖÖ 
new
ÖÖ 
SKCanvas
ÖÖ !
(
ÖÖ! "
bitmap
ÖÖ" (
)
ÖÖ( )
;
ÖÖ) *
var
àà 
rect
àà 
=
àà 
SKRect
àà 
.
àà 
Create
àà  
(
àà  !
$num
àà! "
,
àà" #
$num
àà$ %
,
àà% &
bitmapWidth
àà' 2
,
àà2 3
bitmapHeight
àà4 @
)
àà@ A
;
ààA B
var
ää 
paint
ää 
=
ää 
new
ää 
SKPaint
ää 
{
ãã 	
Style
åå 
=
åå 
SKPaintStyle
åå  
.
åå  !
Fill
åå! %
,
åå% &
Color
çç 
=
çç 
SKColors
çç 
.
çç 
White
çç "
,
çç" #
}
éé 	
;
éé	 

canvas
êê 
.
êê 
DrawRect
êê 
(
êê 
rect
êê 
,
êê 
paint
êê #
)
êê# $
;
êê$ %
paint
íí 
.
íí 
Color
íí 
=
íí 
SKColors
íí 
.
íí 
Black
íí $
;
íí$ %
for
ïï 
(
ïï 
var
ïï 
i
ïï 
=
ïï 
$num
ïï 
;
ïï 
i
ïï 
<
ïï 
vectors
ïï #
.
ïï# $
Count
ïï$ )
-
ïï* +
$num
ïï, -
;
ïï- .
i
ïï/ 0
++
ïï0 2
)
ïï2 3
{
ññ 	
var
óó 
x1
óó 
=
óó 
vectors
óó 
[
óó 
i
óó 
]
óó 
.
óó  
X
óó  !
;
óó! "
var
òò 
y1
òò 
=
òò 
vectors
òò 
[
òò 
i
òò 
]
òò 
.
òò  
Y
òò  !
;
òò! "
var
ôô 
x2
ôô 
=
ôô 
vectors
ôô 
[
ôô 
i
ôô 
+
ôô  
$num
ôô! "
]
ôô" #
.
ôô# $
X
ôô$ %
;
ôô% &
var
öö 
y2
öö 
=
öö 
vectors
öö 
[
öö 
i
öö 
+
öö  
$num
öö! "
]
öö" #
.
öö# $
Y
öö$ %
;
öö% &
canvas
úú 
.
úú 
DrawLine
úú 
(
úú 
new
úú 
SKPoint
úú  '
(
úú' (
x1
úú( *
,
úú* +
y1
úú, .
)
úú. /
,
úú/ 0
new
úú1 4
SKPoint
úú5 <
(
úú< =
x2
úú= ?
,
úú? @
y2
úúA C
)
úúC D
,
úúD E
paint
úúF K
)
úúK L
;
úúL M
}
ùù 	
return
üü 
bitmap
üü 
;
üü 
}
†† 
}°° ∫Ç
rC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\Algorithms\Graph\MinimumSpanningTree\Kruskal.cs
	namespace 	

Algorithms
 
. 
Graph 
. 
MinimumSpanningTree .
;. /
public 
static 
class 
Kruskal 
{ 
public 

static 
float 
[ 
, 
] 
Solve  
(  !
float! &
[& '
,' (
]( )
adjacencyMatrix* 9
)9 :
{ 
ValidateGraph 
( 
adjacencyMatrix %
)% &
;& '
var 
numNodes 
= 
adjacencyMatrix &
.& '
	GetLength' 0
(0 1
$num1 2
)2 3
;3 4
var   
set   
=   
new   
DisjointSet   !
<  ! "
int  " %
>  % &
(  & '
)  ' (
;  ( )
var!! 
nodes!! 
=!! 
new!! 
Node!! 
<!! 
int!!  
>!!  !
[!!! "
numNodes!!" *
]!!* +
;!!+ ,
var"" 
edgeWeightList"" 
="" 
new""  
List""! %
<""% &
float""& +
>""+ ,
("", -
)""- .
;"". /
var## 
nodeConnectList## 
=## 
new## !
List##" &
<##& '
(##' (
int##( +
,##+ ,
int##- 0
)##0 1
>##1 2
(##2 3
)##3 4
;##4 5
for&& 
(&& 
var&& 
i&& 
=&& 
$num&& 
;&& 
i&& 
<&& 
numNodes&& $
;&&$ %
i&&& '
++&&' )
)&&) *
{'' 	
nodes(( 
[(( 
i(( 
](( 
=(( 
set(( 
.(( 
MakeSet(( "
(((" #
i((# $
)(($ %
;((% &
})) 	
for,, 
(,, 
var,, 
i,, 
=,, 
$num,, 
;,, 
i,, 
<,, 
numNodes,, $
-,,% &
$num,,' (
;,,( )
i,,* +
++,,+ -
),,- .
{-- 	
for.. 
(.. 
var.. 
j.. 
=.. 
i.. 
+.. 
$num.. 
;.. 
j..  !
<.." #
numNodes..$ ,
;.., -
j... /
++../ 1
)..1 2
{// 
if00 
(00 
float00 
.00 
IsFinite00 "
(00" #
adjacencyMatrix00# 2
[002 3
i003 4
,004 5
j006 7
]007 8
)008 9
)009 :
{11 
edgeWeightList22 "
.22" #
Add22# &
(22& '
adjacencyMatrix22' 6
[226 7
i227 8
,228 9
j22: ;
]22; <
)22< =
;22= >
nodeConnectList33 #
.33# $
Add33$ '
(33' (
(33( )
i33) *
,33* +
j33, -
)33- .
)33. /
;33/ 0
}44 
}55 
}66 	
var88 
edges88 
=88 
Solve88 
(88 
set88 
,88 
nodes88 $
,88$ %
edgeWeightList88& 4
.884 5
ToArray885 <
(88< =
)88= >
,88> ?
nodeConnectList88@ O
.88O P
ToArray88P W
(88W X
)88X Y
)88Y Z
;88Z [
var;; 
mst;; 
=;; 
new;; 
float;; 
[;; 
numNodes;; $
,;;$ %
numNodes;;& .
];;. /
;;;/ 0
for<< 
(<< 
var<< 
i<< 
=<< 
$num<< 
;<< 
i<< 
<<< 
numNodes<< $
;<<$ %
i<<& '
++<<' )
)<<) *
{== 	
mst>> 
[>> 
i>> 
,>> 
i>> 
]>> 
=>> 
float>> 
.>> 
PositiveInfinity>> .
;>>. /
for@@ 
(@@ 
var@@ 
j@@ 
=@@ 
i@@ 
+@@ 
$num@@ 
;@@ 
j@@  !
<@@" #
numNodes@@$ ,
;@@, -
j@@. /
++@@/ 1
)@@1 2
{AA 
mstBB 
[BB 
iBB 
,BB 
jBB 
]BB 
=BB 
floatBB !
.BB! "
PositiveInfinityBB" 2
;BB2 3
mstCC 
[CC 
jCC 
,CC 
iCC 
]CC 
=CC 
floatCC !
.CC! "
PositiveInfinityCC" 2
;CC2 3
}DD 
}EE 	
foreachGG 
(GG 
varGG 
(GG 
node1GG 
,GG 
node2GG "
)GG" #
inGG$ &
edgesGG' ,
)GG, -
{HH 	
mstII 
[II 
node1II 
,II 
node2II 
]II 
=II 
adjacencyMatrixII  /
[II/ 0
node1II0 5
,II5 6
node2II7 <
]II< =
;II= >
mstJJ 
[JJ 
node2JJ 
,JJ 
node1JJ 
]JJ 
=JJ 
adjacencyMatrixJJ  /
[JJ/ 0
node1JJ0 5
,JJ5 6
node2JJ7 <
]JJ< =
;JJ= >
}KK 	
returnMM 
mstMM 
;MM 
}NN 
publicUU 

staticUU 

DictionaryUU 
<UU 
intUU  
,UU  !
floatUU" '
>UU' (
[UU( )
]UU) *
SolveUU+ 0
(UU0 1

DictionaryUU1 ;
<UU; <
intUU< ?
,UU? @
floatUUA F
>UUF G
[UUG H
]UUH I
adjacencyListUUJ W
)UUW X
{VV 
ValidateGraphWW 
(WW 
adjacencyListWW #
)WW# $
;WW$ %
varYY 
numNodesYY 
=YY 
adjacencyListYY $
.YY$ %
LengthYY% +
;YY+ ,
varZZ 
setZZ 
=ZZ 
newZZ 
DisjointSetZZ !
<ZZ! "
intZZ" %
>ZZ% &
(ZZ& '
)ZZ' (
;ZZ( )
var[[ 
nodes[[ 
=[[ 
new[[ 
Node[[ 
<[[ 
int[[  
>[[  !
[[[! "
numNodes[[" *
][[* +
;[[+ ,
var\\ 
edgeWeightList\\ 
=\\ 
new\\  
List\\! %
<\\% &
float\\& +
>\\+ ,
(\\, -
)\\- .
;\\. /
var]] 
nodeConnectList]] 
=]] 
new]] !
List]]" &
<]]& '
(]]' (
int]]( +
,]]+ ,
int]]- 0
)]]0 1
>]]1 2
(]]2 3
)]]3 4
;]]4 5
for`` 
(`` 
var`` 
i`` 
=`` 
$num`` 
;`` 
i`` 
<`` 
numNodes`` $
;``$ %
i``& '
++``' )
)``) *
{aa 	
nodesbb 
[bb 
ibb 
]bb 
=bb 
setbb 
.bb 
MakeSetbb "
(bb" #
ibb# $
)bb$ %
;bb% &
foreachdd 
(dd 
vardd 
(dd 
nodedd 
,dd 
weightdd %
)dd% &
indd' )
adjacencyListdd* 7
[dd7 8
idd8 9
]dd9 :
)dd: ;
{ee 
edgeWeightListff 
.ff 
Addff "
(ff" #
weightff# )
)ff) *
;ff* +
nodeConnectListgg 
.gg  
Addgg  #
(gg# $
(gg$ %
igg% &
,gg& '
nodegg( ,
)gg, -
)gg- .
;gg. /
}hh 
}ii 	
varkk 
edgeskk 
=kk 
Solvekk 
(kk 
setkk 
,kk 
nodeskk $
,kk$ %
edgeWeightListkk& 4
.kk4 5
ToArraykk5 <
(kk< =
)kk= >
,kk> ?
nodeConnectListkk@ O
.kkO P
ToArraykkP W
(kkW X
)kkX Y
)kkY Z
;kkZ [
varnn 
mstnn 
=nn 
newnn 

Dictionarynn  
<nn  !
intnn! $
,nn$ %
floatnn& +
>nn+ ,
[nn, -
numNodesnn- 5
]nn5 6
;nn6 7
foroo 
(oo 
varoo 
ioo 
=oo 
$numoo 
;oo 
ioo 
<oo 
numNodesoo $
;oo$ %
ioo& '
++oo' )
)oo) *
{pp 	
mstqq 
[qq 
iqq 
]qq 
=qq 
newqq 

Dictionaryqq #
<qq# $
intqq$ '
,qq' (
floatqq) .
>qq. /
(qq/ 0
)qq0 1
;qq1 2
}rr 	
foreachtt 
(tt 
vartt 
(tt 
node1tt 
,tt 
node2tt "
)tt" #
intt$ &
edgestt' ,
)tt, -
{uu 	
mstvv 
[vv 
node1vv 
]vv 
.vv 
Addvv 
(vv 
node2vv  
,vv  !
adjacencyListvv" /
[vv/ 0
node1vv0 5
]vv5 6
[vv6 7
node2vv7 <
]vv< =
)vv= >
;vv> ?
mstww 
[ww 
node2ww 
]ww 
.ww 
Addww 
(ww 
node1ww  
,ww  !
adjacencyListww" /
[ww/ 0
node1ww0 5
]ww5 6
[ww6 7
node2ww7 <
]ww< =
)ww= >
;ww> ?
}xx 	
returnzz 
mstzz 
;zz 
}{{ 
private
ÅÅ 
static
ÅÅ 
void
ÅÅ 
ValidateGraph
ÅÅ %
(
ÅÅ% &
float
ÅÅ& +
[
ÅÅ+ ,
,
ÅÅ, -
]
ÅÅ- .
adj
ÅÅ/ 2
)
ÅÅ2 3
{
ÇÇ 
if
ÉÉ 

(
ÉÉ 
adj
ÉÉ 
.
ÉÉ 
	GetLength
ÉÉ 
(
ÉÉ 
$num
ÉÉ 
)
ÉÉ 
!=
ÉÉ 
adj
ÉÉ  #
.
ÉÉ# $
	GetLength
ÉÉ$ -
(
ÉÉ- .
$num
ÉÉ. /
)
ÉÉ/ 0
)
ÉÉ0 1
{
ÑÑ 	
throw
ÖÖ 
new
ÖÖ 
ArgumentException
ÖÖ '
(
ÖÖ' (
$str
ÖÖ( @
)
ÖÖ@ A
;
ÖÖA B
}
ÜÜ 	
for
àà 
(
àà 
var
àà 
i
àà 
=
àà 
$num
àà 
;
àà 
i
àà 
<
àà 
adj
àà 
.
àà  
	GetLength
àà  )
(
àà) *
$num
àà* +
)
àà+ ,
-
àà- .
$num
àà/ 0
;
àà0 1
i
àà2 3
++
àà3 5
)
àà5 6
{
ââ 	
for
ää 
(
ää 
var
ää 
j
ää 
=
ää 
i
ää 
+
ää 
$num
ää 
;
ää 
j
ää  !
<
ää" #
adj
ää$ '
.
ää' (
	GetLength
ää( 1
(
ää1 2
$num
ää2 3
)
ää3 4
;
ää4 5
j
ää6 7
++
ää7 9
)
ää9 :
{
ãã 
if
åå 
(
åå 
Math
åå 
.
åå 
Abs
åå 
(
åå 
adj
åå  
[
åå  !
i
åå! "
,
åå" #
j
åå$ %
]
åå% &
-
åå' (
adj
åå) ,
[
åå, -
j
åå- .
,
åå. /
i
åå0 1
]
åå1 2
)
åå2 3
>
åå4 5
$num
åå6 :
)
åå: ;
{
çç 
throw
éé 
new
éé 
ArgumentException
éé /
(
éé/ 0
$str
éé0 K
)
ééK L
;
ééL M
}
èè 
}
êê 
}
ëë 	
}
íí 
private
òò 
static
òò 
void
òò 
ValidateGraph
òò %
(
òò% &

Dictionary
òò& 0
<
òò0 1
int
òò1 4
,
òò4 5
float
òò6 ;
>
òò; <
[
òò< =
]
òò= >
adj
òò? B
)
òòB C
{
ôô 
for
öö 
(
öö 
var
öö 
i
öö 
=
öö 
$num
öö 
;
öö 
i
öö 
<
öö 
adj
öö 
.
öö  
Length
öö  &
;
öö& '
i
öö( )
++
öö) +
)
öö+ ,
{
õõ 	
foreach
úú 
(
úú 
var
úú 
edge
úú 
in
úú  
adj
úú! $
[
úú$ %
i
úú% &
]
úú& '
)
úú' (
{
ùù 
if
ûû 
(
ûû 
!
ûû 
adj
ûû 
[
ûû 
edge
ûû 
.
ûû 
Key
ûû !
]
ûû! "
.
ûû" #
ContainsKey
ûû# .
(
ûû. /
i
ûû/ 0
)
ûû0 1
||
ûû2 4
Math
ûû5 9
.
ûû9 :
Abs
ûû: =
(
ûû= >
edge
ûû> B
.
ûûB C
Value
ûûC H
-
ûûI J
adj
ûûK N
[
ûûN O
edge
ûûO S
.
ûûS T
Key
ûûT W
]
ûûW X
[
ûûX Y
i
ûûY Z
]
ûûZ [
)
ûû[ \
>
ûû] ^
$num
ûû_ c
)
ûûc d
{
üü 
throw
†† 
new
†† 
ArgumentException
†† /
(
††/ 0
$str
††0 K
)
††K L
;
††L M
}
°° 
}
¢¢ 
}
££ 	
}
§§ 
private
ÆÆ 
static
ÆÆ 
(
ÆÆ 
int
ÆÆ 
,
ÆÆ 
int
ÆÆ 
)
ÆÆ 
[
ÆÆ 
]
ÆÆ 
Solve
ÆÆ  %
(
ÆÆ% &
DisjointSet
ÆÆ& 1
<
ÆÆ1 2
int
ÆÆ2 5
>
ÆÆ5 6
set
ÆÆ7 :
,
ÆÆ: ;
Node
ÆÆ< @
<
ÆÆ@ A
int
ÆÆA D
>
ÆÆD E
[
ÆÆE F
]
ÆÆF G
nodes
ÆÆH M
,
ÆÆM N
float
ÆÆO T
[
ÆÆT U
]
ÆÆU V
edgeWeights
ÆÆW b
,
ÆÆb c
(
ÆÆd e
int
ÆÆe h
,
ÆÆh i
int
ÆÆj m
)
ÆÆm n
[
ÆÆn o
]
ÆÆo p
connections
ÆÆq |
)
ÆÆ| }
{
ØØ 
var
∞∞ 
edges
∞∞ 
=
∞∞ 
new
∞∞ 
List
∞∞ 
<
∞∞ 
(
∞∞ 
int
∞∞ !
,
∞∞! "
int
∞∞# &
)
∞∞& '
>
∞∞' (
(
∞∞( )
)
∞∞) *
;
∞∞* +
Array
≤≤ 
.
≤≤ 
Sort
≤≤ 
(
≤≤ 
edgeWeights
≤≤ 
,
≤≤ 
connections
≤≤  +
)
≤≤+ ,
;
≤≤, -
foreach
¥¥ 
(
¥¥ 
var
¥¥ 
(
¥¥ 
node1
¥¥ 
,
¥¥ 
node2
¥¥ "
)
¥¥" #
in
¥¥$ &
connections
¥¥' 2
)
¥¥2 3
{
µµ 	
if
∂∂ 
(
∂∂ 
set
∂∂ 
.
∂∂ 
FindSet
∂∂ 
(
∂∂ 
nodes
∂∂ !
[
∂∂! "
node1
∂∂" '
]
∂∂' (
)
∂∂( )
!=
∂∂* ,
set
∂∂- 0
.
∂∂0 1
FindSet
∂∂1 8
(
∂∂8 9
nodes
∂∂9 >
[
∂∂> ?
node2
∂∂? D
]
∂∂D E
)
∂∂E F
)
∂∂F G
{
∑∑ 
set
∏∏ 
.
∏∏ 
UnionSet
∏∏ 
(
∏∏ 
nodes
∏∏ "
[
∏∏" #
node1
∏∏# (
]
∏∏( )
,
∏∏) *
nodes
∏∏+ 0
[
∏∏0 1
node2
∏∏1 6
]
∏∏6 7
)
∏∏7 8
;
∏∏8 9
edges
ππ 
.
ππ 
Add
ππ 
(
ππ 
(
ππ 
node1
ππ  
,
ππ  !
node2
ππ" '
)
ππ' (
)
ππ( )
;
ππ) *
}
∫∫ 
}
ªª 	
return
ΩΩ 
edges
ΩΩ 
.
ΩΩ 
ToArray
ΩΩ 
(
ΩΩ 
)
ΩΩ 
;
ΩΩ 
}
ææ 
}øø 