äå
]C:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\Timeline.cs
	namespace 	
DataStructures
 
; 
public 
class 
Timeline 
< 
TValue 
> 
: 
ICollection  +
<+ ,
(, -
DateTime- 5
Time6 :
,: ;
TValue< B
ValueC H
)H I
>I J
,J K

IEquatableL V
<V W
TimelineW _
<_ `
TValue` f
>f g
>g h
{ 
private   
readonly   
List   
<   
(   
DateTime   #
Time  $ (
,  ( )
TValue  * 0
Value  1 6
)  6 7
>  7 8
timeline  9 A
=  B C
new  D G
(  G H
)  H I
;  I J
public%% 

Timeline%% 
(%% 
)%% 
{&& 
}'' 
public.. 

Timeline.. 
(.. 
DateTime.. 
time.. !
,..! "
TValue..# )
value..* /
)../ 0
=>// 

timeline// 
=// 
new// 
List// 
<// 
(//  
DateTime//  (
,//( )
TValue//* 0
)//0 1
>//1 2
{00 	
(11 
time11 
,11 
value11 
)11 
,11 
}22 	
;22	 

public99 

Timeline99 
(99 
params99 
(99 
DateTime99 $
,99$ %
TValue99& ,
)99, -
[99- .
]99. /
timeline990 8
)998 9
=>:: 

this:: 
.:: 
timeline:: 
=:: 
timeline:: #
.;; 
OrderBy;; 
(;; 
pair;; 
=>;; 
pair;; !
.;;! "
Item1;;" '
);;' (
.<< 
ToList<< 
(<< 
)<< 
;<< 
publicAA 

intAA 

TimesCountAA 
=>BB 

GetAllTimesBB 
(BB 
)BB 
.BB 
LengthBB 
;BB  
publicGG 

intGG 
ValuesCountGG 
=>HH 

GetAllValuesHH 
(HH 
)HH 
.HH 
LengthHH  
;HH  !
publicOO 

TValueOO 
[OO 
]OO 
thisOO 
[OO 
DateTimeOO !
timeOO" &
]OO& '
{PP 
getQQ 
=>QQ 
GetValuesByTimeQQ 
(QQ 
timeQQ #
)QQ# $
;QQ$ %
setRR 
{SS 	
varTT 
overridenEventsTT 
=TT  !
timelineTT" *
.TT* +
WhereTT+ 0
(TT0 1
@eventTT1 7
=>TT8 :
@eventTT; A
.TTA B
TimeTTB F
==TTG I
timeTTJ N
)TTN O
.TTO P
ToListTTP V
(TTV W
)TTW X
;TTX Y
foreachUU 
(UU 
varUU 
@eventUU 
inUU  "
overridenEventsUU# 2
)UU2 3
{VV 
timelineWW 
.WW 
RemoveWW 
(WW  
@eventWW  &
)WW& '
;WW' (
}XX 
foreachZZ 
(ZZ 
varZZ 
vZZ 
inZZ 
valueZZ #
)ZZ# $
{[[ 
Add\\ 
(\\ 
time\\ 
,\\ 
v\\ 
)\\ 
;\\ 
}]] 
}^^ 	
}__ 
boolbb 
ICollectionbb	 
<bb 
(bb 
DateTimebb 
Timebb #
,bb# $
TValuebb% +
Valuebb, 1
)bb1 2
>bb2 3
.bb3 4

IsReadOnlybb4 >
=>cc 

falsecc 
;cc 
publichh 

inthh 
Counthh 
=>ii 

timelineii 
.ii 
Countii 
;ii 
publicnn 

voidnn 
Clearnn 
(nn 
)nn 
=>oo 

timelineoo 
.oo 
Clearoo 
(oo 
)oo 
;oo 
publicvv 

voidvv 
CopyTovv 
(vv 
(vv 
DateTimevv  
,vv  !
TValuevv" (
)vv( )
[vv) *
]vv* +
arrayvv, 1
,vv1 2
intvv3 6

arrayIndexvv7 A
)vvA B
=>ww 

timelineww 
.ww 
CopyToww 
(ww 
arrayww  
,ww  !

arrayIndexww" ,
)ww, -
;ww- .
void}} 
ICollection}}	 
<}} 
(}} 
DateTime}} 
Time}} #
,}}# $
TValue}}% +
Value}}, 1
)}}1 2
>}}2 3
.}}3 4
Add}}4 7
(}}7 8
(}}8 9
DateTime}}9 A
Time}}B F
,}}F G
TValue}}H N
Value}}O T
)}}T U
item}}V Z
)}}Z [
=>~~ 

Add~~ 
(~~ 
item~~ 
.~~ 
Time~~ 
,~~ 
item~~ 
.~~ 
Value~~ $
)~~$ %
;~~% &
bool
ÖÖ 
ICollection
ÖÖ	 
<
ÖÖ 
(
ÖÖ 
DateTime
ÖÖ 
Time
ÖÖ #
,
ÖÖ# $
TValue
ÖÖ% +
Value
ÖÖ, 1
)
ÖÖ1 2
>
ÖÖ2 3
.
ÖÖ3 4
Contains
ÖÖ4 <
(
ÖÖ< =
(
ÖÖ= >
DateTime
ÖÖ> F
Time
ÖÖG K
,
ÖÖK L
TValue
ÖÖM S
Value
ÖÖT Y
)
ÖÖY Z
item
ÖÖ[ _
)
ÖÖ_ `
=>
ÜÜ 

Contains
ÜÜ 
(
ÜÜ 
item
ÜÜ 
.
ÜÜ 
Time
ÜÜ 
,
ÜÜ 
item
ÜÜ #
.
ÜÜ# $
Value
ÜÜ$ )
)
ÜÜ) *
;
ÜÜ* +
bool
çç 
ICollection
çç	 
<
çç 
(
çç 
DateTime
çç 
Time
çç #
,
çç# $
TValue
çç% +
Value
çç, 1
)
çç1 2
>
çç2 3
.
çç3 4
Remove
çç4 :
(
çç: ;
(
çç; <
DateTime
çç< D
Time
ççE I
,
ççI J
TValue
ççK Q
Value
ççR W
)
ççW X
item
ççY ]
)
çç] ^
=>
éé 

Remove
éé 
(
éé 
item
éé 
.
éé 
Time
éé 
,
éé 
item
éé !
.
éé! "
Value
éé" '
)
éé' (
;
éé( )
IEnumerator
ëë 
IEnumerable
ëë 
.
ëë 
GetEnumerator
ëë )
(
ëë) *
)
ëë* +
=>
íí 

timeline
íí 
.
íí 
GetEnumerator
íí !
(
íí! "
)
íí" #
;
íí# $
IEnumerator
ïï 
<
ïï 
(
ïï 
DateTime
ïï 
Time
ïï 
,
ïï 
TValue
ïï  &
Value
ïï' ,
)
ïï, -
>
ïï- .
IEnumerable
ïï/ :
<
ïï: ;
(
ïï; <
DateTime
ïï< D
Time
ïïE I
,
ïïI J
TValue
ïïK Q
Value
ïïR W
)
ïïW X
>
ïïX Y
.
ïïY Z
GetEnumerator
ïïZ g
(
ïïg h
)
ïïh i
=>
ññ 

timeline
ññ 
.
ññ 
GetEnumerator
ññ !
(
ññ! "
)
ññ" #
;
ññ# $
public
ôô 

bool
ôô 
Equals
ôô 
(
ôô 
Timeline
ôô 
<
ôô  
TValue
ôô  &
>
ôô& '
?
ôô' (
other
ôô) .
)
ôô. /
=>
öö 

other
öö 
is
öö 
not
öö 
null
öö 
&&
öö 
this
öö  $
==
öö% '
other
öö( -
;
öö- .
public
¢¢ 

static
¢¢ 
bool
¢¢ 
operator
¢¢ 
==
¢¢  "
(
¢¢" #
Timeline
¢¢# +
<
¢¢+ ,
TValue
¢¢, 2
>
¢¢2 3
left
¢¢4 8
,
¢¢8 9
Timeline
¢¢: B
<
¢¢B C
TValue
¢¢C I
>
¢¢I J
right
¢¢K P
)
¢¢P Q
{
££ 
var
§§ 
	leftArray
§§ 
=
§§ 
left
§§ 
.
§§ 
ToArray
§§ $
(
§§$ %
)
§§% &
;
§§& '
var
•• 

rightArray
•• 
=
•• 
right
•• 
.
•• 
ToArray
•• &
(
••& '
)
••' (
;
••( )
if
ßß 

(
ßß 
left
ßß 
.
ßß 
Count
ßß 
!=
ßß 

rightArray
ßß $
.
ßß$ %
Length
ßß% +
)
ßß+ ,
{
®® 	
return
©© 
false
©© 
;
©© 
}
™™ 	
for
¨¨ 
(
¨¨ 
var
¨¨ 
i
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨ 
i
¨¨ 
<
¨¨ 
	leftArray
¨¨ %
.
¨¨% &
Length
¨¨& ,
;
¨¨, -
i
¨¨. /
++
¨¨/ 1
)
¨¨1 2
{
≠≠ 	
if
ÆÆ 
(
ÆÆ 
	leftArray
ÆÆ 
[
ÆÆ 
i
ÆÆ 
]
ÆÆ 
.
ÆÆ 
Time
ÆÆ !
!=
ÆÆ" $

rightArray
ÆÆ% /
[
ÆÆ/ 0
i
ÆÆ0 1
]
ÆÆ1 2
.
ÆÆ2 3
Time
ÆÆ3 7
&&
ØØ 
!
ØØ 
	leftArray
ØØ 
[
ØØ 
i
ØØ 
]
ØØ  
.
ØØ  !
Value
ØØ! &
!
ØØ& '
.
ØØ' (
Equals
ØØ( .
(
ØØ. /

rightArray
ØØ/ 9
[
ØØ9 :
i
ØØ: ;
]
ØØ; <
.
ØØ< =
Value
ØØ= B
)
ØØB C
)
ØØC D
{
∞∞ 
return
±± 
false
±± 
;
±± 
}
≤≤ 
}
≥≥ 	
return
µµ 
true
µµ 
;
µµ 
}
∂∂ 
public
ææ 

static
ææ 
bool
ææ 
operator
ææ 
!=
ææ  "
(
ææ" #
Timeline
ææ# +
<
ææ+ ,
TValue
ææ, 2
>
ææ2 3
left
ææ4 8
,
ææ8 9
Timeline
ææ: B
<
ææB C
TValue
ææC I
>
ææI J
right
ææK P
)
ææP Q
=>
øø 

!
øø 
(
øø 
left
øø 
==
øø 
right
øø 
)
øø 
;
øø 
public
ƒƒ 

DateTime
ƒƒ 
[
ƒƒ 
]
ƒƒ 
GetAllTimes
ƒƒ !
(
ƒƒ! "
)
ƒƒ" #
=>
≈≈ 

timeline
≈≈ 
.
≈≈ 
Select
≈≈ 
(
≈≈ 
t
≈≈ 
=>
≈≈ 
t
≈≈  !
.
≈≈! "
Time
≈≈" &
)
≈≈& '
.
∆∆ 
Distinct
∆∆ 
(
∆∆ 
)
∆∆ 
.
«« 
ToArray
«« 
(
«« 
)
«« 
;
«« 
public
ÃÃ 

DateTime
ÃÃ 
[
ÃÃ 
]
ÃÃ 
GetTimesByValue
ÃÃ %
(
ÃÃ% &
TValue
ÃÃ& ,
value
ÃÃ- 2
)
ÃÃ2 3
=>
ÕÕ 

timeline
ÕÕ 
.
ÕÕ 
Where
ÕÕ 
(
ÕÕ 
pair
ÕÕ 
=>
ÕÕ !
pair
ÕÕ" &
.
ÕÕ& '
Value
ÕÕ' ,
!
ÕÕ, -
.
ÕÕ- .
Equals
ÕÕ. 4
(
ÕÕ4 5
value
ÕÕ5 :
)
ÕÕ: ;
)
ÕÕ; <
.
ŒŒ 
Select
ŒŒ 
(
ŒŒ 
pair
ŒŒ 
=>
ŒŒ 
pair
ŒŒ  
.
ŒŒ  !
Time
ŒŒ! %
)
ŒŒ% &
.
œœ 
ToArray
œœ 
(
œœ 
)
œœ 
;
œœ 
public
‘‘ 

DateTime
‘‘ 
[
‘‘ 
]
‘‘ 
GetTimesBefore
‘‘ $
(
‘‘$ %
DateTime
‘‘% -
time
‘‘. 2
)
‘‘2 3
=>
’’ 

GetAllTimes
’’ 
(
’’ 
)
’’ 
.
÷÷ 
Where
÷÷ 
(
÷÷ 
t
÷÷ 
=>
÷÷ 
t
÷÷ 
<
÷÷ 
time
÷÷  
)
÷÷  !
.
◊◊ 
OrderBy
◊◊ 
(
◊◊ 
t
◊◊ 
=>
◊◊ 
t
◊◊ 
)
◊◊ 
.
ÿÿ 
ToArray
ÿÿ 
(
ÿÿ 
)
ÿÿ 
;
ÿÿ 
public
›› 

DateTime
›› 
[
›› 
]
›› 
GetTimesAfter
›› #
(
››# $
DateTime
››$ ,
time
››- 1
)
››1 2
=>
ﬁﬁ 

GetAllTimes
ﬁﬁ 
(
ﬁﬁ 
)
ﬁﬁ 
.
ﬂﬂ 
Where
ﬂﬂ 
(
ﬂﬂ 
t
ﬂﬂ 
=>
ﬂﬂ 
t
ﬂﬂ 
>
ﬂﬂ 
time
ﬂﬂ  
)
ﬂﬂ  !
.
‡‡ 
OrderBy
‡‡ 
(
‡‡ 
t
‡‡ 
=>
‡‡ 
t
‡‡ 
)
‡‡ 
.
·· 
ToArray
·· 
(
·· 
)
·· 
;
·· 
public
ÊÊ 

TValue
ÊÊ 
[
ÊÊ 
]
ÊÊ 
GetAllValues
ÊÊ  
(
ÊÊ  !
)
ÊÊ! "
=>
ÁÁ 

timeline
ÁÁ 
.
ÁÁ 
Select
ÁÁ 
(
ÁÁ 
pair
ÁÁ 
=>
ÁÁ  "
pair
ÁÁ# '
.
ÁÁ' (
Value
ÁÁ( -
)
ÁÁ- .
.
ËË 
ToArray
ËË 
(
ËË 
)
ËË 
;
ËË 
public
ÌÌ 

TValue
ÌÌ 
[
ÌÌ 
]
ÌÌ 
GetValuesByTime
ÌÌ #
(
ÌÌ# $
DateTime
ÌÌ$ ,
time
ÌÌ- 1
)
ÌÌ1 2
=>
ÓÓ 

timeline
ÓÓ 
.
ÓÓ 
Where
ÓÓ 
(
ÓÓ 
pair
ÓÓ 
=>
ÓÓ !
pair
ÓÓ" &
.
ÓÓ& '
Time
ÓÓ' +
==
ÓÓ, .
time
ÓÓ/ 3
)
ÓÓ3 4
.
ÔÔ 
Select
ÔÔ 
(
ÔÔ 
pair
ÔÔ 
=>
ÔÔ 
pair
ÔÔ  
.
ÔÔ  !
Value
ÔÔ! &
)
ÔÔ& '
.
 
ToArray
 
(
 
)
 
;
 
public
ıı 

Timeline
ıı 
<
ıı 
TValue
ıı 
>
ıı 
GetValuesBefore
ıı +
(
ıı+ ,
DateTime
ıı, 4
time
ıı5 9
)
ıı9 :
=>
ˆˆ 

new
ˆˆ 
(
ˆˆ 
this
ˆˆ 
.
ˆˆ 
Where
ˆˆ 
(
ˆˆ 
pair
ˆˆ 
=>
ˆˆ !
pair
ˆˆ" &
.
ˆˆ& '
Time
ˆˆ' +
<
ˆˆ, -
time
ˆˆ. 2
)
ˆˆ2 3
.
ˆˆ3 4
ToArray
ˆˆ4 ;
(
ˆˆ; <
)
ˆˆ< =
)
ˆˆ= >
;
ˆˆ> ?
public
˚˚ 

Timeline
˚˚ 
<
˚˚ 
TValue
˚˚ 
>
˚˚ 
GetValuesAfter
˚˚ *
(
˚˚* +
DateTime
˚˚+ 3
time
˚˚4 8
)
˚˚8 9
=>
¸¸ 

new
¸¸ 
(
¸¸ 
this
¸¸ 
.
¸¸ 
Where
¸¸ 
(
¸¸ 
pair
¸¸ 
=>
¸¸ !
pair
¸¸" &
.
¸¸& '
Time
¸¸' +
>
¸¸, -
time
¸¸. 2
)
¸¸2 3
.
¸¸3 4
ToArray
¸¸4 ;
(
¸¸; <
)
¸¸< =
)
¸¸= >
;
¸¸> ?
public
ÉÉ 

Timeline
ÉÉ 
<
ÉÉ 
TValue
ÉÉ 
>
ÉÉ $
GetValuesByMillisecond
ÉÉ 2
(
ÉÉ2 3
int
ÉÉ3 6
millisecond
ÉÉ7 B
)
ÉÉB C
=>
ÑÑ 

new
ÑÑ 
(
ÑÑ 
timeline
ÑÑ 
.
ÑÑ 
Where
ÑÑ 
(
ÑÑ 
pair
ÑÑ "
=>
ÑÑ# %
pair
ÑÑ& *
.
ÑÑ* +
Time
ÑÑ+ /
.
ÑÑ/ 0
Millisecond
ÑÑ0 ;
==
ÑÑ< >
millisecond
ÑÑ? J
)
ÑÑJ K
.
ÑÑK L
ToArray
ÑÑL S
(
ÑÑS T
)
ÑÑT U
)
ÑÑU V
;
ÑÑV W
public
ãã 

Timeline
ãã 
<
ãã 
TValue
ãã 
>
ãã 
GetValuesBySecond
ãã -
(
ãã- .
int
ãã. 1
second
ãã2 8
)
ãã8 9
=>
åå 

new
åå 
(
åå 
timeline
åå 
.
åå 
Where
åå 
(
åå 
pair
åå "
=>
åå# %
pair
åå& *
.
åå* +
Time
åå+ /
.
åå/ 0
Second
åå0 6
==
åå7 9
second
åå: @
)
åå@ A
.
ååA B
ToArray
ååB I
(
ååI J
)
ååJ K
)
ååK L
;
ååL M
public
ìì 

Timeline
ìì 
<
ìì 
TValue
ìì 
>
ìì 
GetValuesByMinute
ìì -
(
ìì- .
int
ìì. 1
minute
ìì2 8
)
ìì8 9
=>
îî 

new
îî 
(
îî 
timeline
îî 
.
îî 
Where
îî 
(
îî 
pair
îî "
=>
îî# %
pair
îî& *
.
îî* +
Time
îî+ /
.
îî/ 0
Minute
îî0 6
==
îî7 9
minute
îî: @
)
îî@ A
.
îîA B
ToArray
îîB I
(
îîI J
)
îîJ K
)
îîK L
;
îîL M
public
õõ 

Timeline
õõ 
<
õõ 
TValue
õõ 
>
õõ 
GetValuesByHour
õõ +
(
õõ+ ,
int
õõ, /
hour
õõ0 4
)
õõ4 5
=>
úú 

new
úú 
(
úú 
timeline
úú 
.
úú 
Where
úú 
(
úú 
pair
úú "
=>
úú# %
pair
úú& *
.
úú* +
Time
úú+ /
.
úú/ 0
Hour
úú0 4
==
úú5 7
hour
úú8 <
)
úú< =
.
úú= >
ToArray
úú> E
(
úúE F
)
úúF G
)
úúG H
;
úúH I
public
££ 

Timeline
££ 
<
££ 
TValue
££ 
>
££ 
GetValuesByDay
££ *
(
££* +
int
££+ .
day
££/ 2
)
££2 3
=>
§§ 

new
§§ 
(
§§ 
timeline
§§ 
.
§§ 
Where
§§ 
(
§§ 
pair
§§ "
=>
§§# %
pair
§§& *
.
§§* +
Time
§§+ /
.
§§/ 0
Day
§§0 3
==
§§4 6
day
§§7 :
)
§§: ;
.
§§; <
ToArray
§§< C
(
§§C D
)
§§D E
)
§§E F
;
§§F G
public
´´ 

Timeline
´´ 
<
´´ 
TValue
´´ 
>
´´ "
GetValuesByTimeOfDay
´´ 0
(
´´0 1
TimeSpan
´´1 9
	timeOfDay
´´: C
)
´´C D
=>
¨¨ 

new
¨¨ 
(
¨¨ 
timeline
¨¨ 
.
¨¨ 
Where
¨¨ 
(
¨¨ 
pair
¨¨ "
=>
¨¨# %
pair
¨¨& *
.
¨¨* +
Time
¨¨+ /
.
¨¨/ 0
	TimeOfDay
¨¨0 9
==
¨¨: <
	timeOfDay
¨¨= F
)
¨¨F G
.
¨¨G H
ToArray
¨¨H O
(
¨¨O P
)
¨¨P Q
)
¨¨Q R
;
¨¨R S
public
≥≥ 

Timeline
≥≥ 
<
≥≥ 
TValue
≥≥ 
>
≥≥ "
GetValuesByDayOfWeek
≥≥ 0
(
≥≥0 1
	DayOfWeek
≥≥1 :
	dayOfWeek
≥≥; D
)
≥≥D E
=>
¥¥ 

new
¥¥ 
(
¥¥ 
timeline
¥¥ 
.
¥¥ 
Where
¥¥ 
(
¥¥ 
pair
¥¥ "
=>
¥¥# %
pair
¥¥& *
.
¥¥* +
Time
¥¥+ /
.
¥¥/ 0
	DayOfWeek
¥¥0 9
==
¥¥: <
	dayOfWeek
¥¥= F
)
¥¥F G
.
¥¥G H
ToArray
¥¥H O
(
¥¥O P
)
¥¥P Q
)
¥¥Q R
;
¥¥R S
public
ªª 

Timeline
ªª 
<
ªª 
TValue
ªª 
>
ªª "
GetValuesByDayOfYear
ªª 0
(
ªª0 1
int
ªª1 4
	dayOfYear
ªª5 >
)
ªª> ?
=>
ºº 

new
ºº 
(
ºº 
timeline
ºº 
.
ºº 
Where
ºº 
(
ºº 
pair
ºº "
=>
ºº# %
pair
ºº& *
.
ºº* +
Time
ºº+ /
.
ºº/ 0
	DayOfYear
ºº0 9
==
ºº: <
	dayOfYear
ºº= F
)
ººF G
.
ººG H
ToArray
ººH O
(
ººO P
)
ººP Q
)
ººQ R
;
ººR S
public
√√ 

Timeline
√√ 
<
√√ 
TValue
√√ 
>
√√ 
GetValuesByMonth
√√ ,
(
√√, -
int
√√- 0
month
√√1 6
)
√√6 7
=>
ƒƒ 

new
ƒƒ 
(
ƒƒ 
timeline
ƒƒ 
.
ƒƒ 
Where
ƒƒ 
(
ƒƒ 
pair
ƒƒ "
=>
ƒƒ# %
pair
ƒƒ& *
.
ƒƒ* +
Time
ƒƒ+ /
.
ƒƒ/ 0
Month
ƒƒ0 5
==
ƒƒ6 8
month
ƒƒ9 >
)
ƒƒ> ?
.
ƒƒ? @
ToArray
ƒƒ@ G
(
ƒƒG H
)
ƒƒH I
)
ƒƒI J
;
ƒƒJ K
public
ÀÀ 

Timeline
ÀÀ 
<
ÀÀ 
TValue
ÀÀ 
>
ÀÀ 
GetValuesByYear
ÀÀ +
(
ÀÀ+ ,
int
ÀÀ, /
year
ÀÀ0 4
)
ÀÀ4 5
=>
ÃÃ 

new
ÃÃ 
(
ÃÃ 
timeline
ÃÃ 
.
ÃÃ 
Where
ÃÃ 
(
ÃÃ 
pair
ÃÃ "
=>
ÃÃ# %
pair
ÃÃ& *
.
ÃÃ* +
Time
ÃÃ+ /
.
ÃÃ/ 0
Year
ÃÃ0 4
==
ÃÃ5 7
year
ÃÃ8 <
)
ÃÃ< =
.
ÃÃ= >
ToArray
ÃÃ> E
(
ÃÃE F
)
ÃÃF G
)
ÃÃG H
;
ÃÃH I
public
”” 

void
”” 
Add
”” 
(
”” 
DateTime
”” 
time
”” !
,
””! "
TValue
””# )
value
””* /
)
””/ 0
{
‘‘ 
timeline
’’ 
.
’’ 
Add
’’ 
(
’’ 
(
’’ 
time
’’ 
,
’’ 
value
’’ !
)
’’! "
)
’’" #
;
’’# $
}
÷÷ 
public
€€ 

void
€€ 
Add
€€ 
(
€€ 
params
€€ 
(
€€ 
DateTime
€€ $
,
€€$ %
TValue
€€& ,
)
€€, -
[
€€- .
]
€€. /
timeline
€€0 8
)
€€8 9
{
‹‹ 
this
›› 
.
›› 
timeline
›› 
.
›› 
AddRange
›› 
(
›› 
timeline
›› '
)
››' (
;
››( )
}
ﬁﬁ 
public
„„ 

void
„„ 
Add
„„ 
(
„„ 
Timeline
„„ 
<
„„ 
TValue
„„ #
>
„„# $
timeline
„„% -
)
„„- .
=>
‰‰ 

Add
‰‰ 
(
‰‰ 
timeline
‰‰ 
.
‰‰ 
ToArray
‰‰ 
(
‰‰  
)
‰‰  !
)
‰‰! "
;
‰‰" #
public
ÈÈ 

void
ÈÈ 
AddNow
ÈÈ 
(
ÈÈ 
params
ÈÈ 
TValue
ÈÈ $
[
ÈÈ$ %
]
ÈÈ% &
value
ÈÈ' ,
)
ÈÈ, -
{
ÍÍ 
var
ÎÎ 
now
ÎÎ 
=
ÎÎ 
DateTime
ÎÎ 
.
ÎÎ 
Now
ÎÎ 
;
ÎÎ 
foreach
ÏÏ 
(
ÏÏ 
var
ÏÏ 
v
ÏÏ 
in
ÏÏ 
value
ÏÏ 
)
ÏÏ  
{
ÌÌ 	
Add
ÓÓ 
(
ÓÓ 
now
ÓÓ 
,
ÓÓ 
v
ÓÓ 
)
ÓÓ 
;
ÓÓ 
}
ÔÔ 	
}
 
public
¯¯ 

bool
¯¯ 
Contains
¯¯ 
(
¯¯ 
DateTime
¯¯ !
time
¯¯" &
,
¯¯& '
TValue
¯¯( .
value
¯¯/ 4
)
¯¯4 5
=>
˘˘ 

timeline
˘˘ 
.
˘˘ 
Contains
˘˘ 
(
˘˘ 
(
˘˘ 
time
˘˘ "
,
˘˘" #
value
˘˘$ )
)
˘˘) *
)
˘˘* +
;
˘˘+ ,
public
ÄÄ 

bool
ÄÄ 
Contains
ÄÄ 
(
ÄÄ 
params
ÄÄ 
(
ÄÄ  !
DateTime
ÄÄ! )
,
ÄÄ) *
TValue
ÄÄ+ 1
)
ÄÄ1 2
[
ÄÄ2 3
]
ÄÄ3 4
timeline
ÄÄ5 =
)
ÄÄ= >
=>
ÅÅ 

timeline
ÅÅ 
.
ÅÅ 
Any
ÅÅ 
(
ÅÅ 
@event
ÅÅ 
=>
ÅÅ !
Contains
ÅÅ" *
(
ÅÅ* +
@event
ÅÅ+ 1
.
ÅÅ1 2
Item1
ÅÅ2 7
,
ÅÅ7 8
@event
ÅÅ9 ?
.
ÅÅ? @
Item2
ÅÅ@ E
)
ÅÅE F
)
ÅÅF G
;
ÅÅG H
public
àà 

bool
àà 
Contains
àà 
(
àà 
Timeline
àà !
<
àà! "
TValue
àà" (
>
àà( )
timeline
àà* 2
)
àà2 3
=>
ââ 

Contains
ââ 
(
ââ 
timeline
ââ 
.
ââ 
ToArray
ââ $
(
ââ$ %
)
ââ% &
)
ââ& '
;
ââ' (
public
êê 

bool
êê 
ContainsTime
êê 
(
êê 
params
êê #
DateTime
êê$ ,
[
êê, -
]
êê- .
times
êê/ 4
)
êê4 5
{
ëë 
var
íí 
storedTimes
íí 
=
íí 
GetAllTimes
íí %
(
íí% &
)
íí& '
;
íí' (
return
ìì 
times
ìì 
.
ìì 
Any
ìì 
(
ìì 
value
ìì 
=>
ìì !
storedTimes
ìì" -
.
ìì- .
Contains
ìì. 6
(
ìì6 7
value
ìì7 <
)
ìì< =
)
ìì= >
;
ìì> ?
}
îî 
public
õõ 

bool
õõ 
ContainsValue
õõ 
(
õõ 
params
õõ $
TValue
õõ% +
[
õõ+ ,
]
õõ, -
values
õõ. 4
)
õõ4 5
{
úú 
var
ùù 
storedValues
ùù 
=
ùù 
GetAllValues
ùù '
(
ùù' (
)
ùù( )
;
ùù) *
return
ûû 
values
ûû 
.
ûû 
Any
ûû 
(
ûû 
value
ûû 
=>
ûû  "
storedValues
ûû# /
.
ûû/ 0
Contains
ûû0 8
(
ûû8 9
value
ûû9 >
)
ûû> ?
)
ûû? @
;
ûû@ A
}
üü 
public
ßß 

bool
ßß 
Remove
ßß 
(
ßß 
DateTime
ßß 
time
ßß  $
,
ßß$ %
TValue
ßß& ,
value
ßß- 2
)
ßß2 3
=>
®® 

timeline
®® 
.
®® 
Remove
®® 
(
®® 
(
®® 
time
®®  
,
®®  !
value
®®" '
)
®®' (
)
®®( )
;
®®) *
public
ØØ 

bool
ØØ 
Remove
ØØ 
(
ØØ 
params
ØØ 
(
ØØ 
DateTime
ØØ '
,
ØØ' (
TValue
ØØ) /
)
ØØ/ 0
[
ØØ0 1
]
ØØ1 2
timeline
ØØ3 ;
)
ØØ; <
{
∞∞ 
var
±± 
result
±± 
=
±± 
false
±± 
;
±± 
foreach
≤≤ 
(
≤≤ 
var
≤≤ 
(
≤≤ 
time
≤≤ 
,
≤≤ 
value
≤≤ !
)
≤≤! "
in
≤≤# %
timeline
≤≤& .
)
≤≤. /
{
≥≥ 	
result
¥¥ 
|=
¥¥ 
this
¥¥ 
.
¥¥ 
timeline
¥¥ #
.
¥¥# $
Remove
¥¥$ *
(
¥¥* +
(
¥¥+ ,
time
¥¥, 0
,
¥¥0 1
value
¥¥2 7
)
¥¥7 8
)
¥¥8 9
;
¥¥9 :
}
µµ 	
return
∑∑ 
result
∑∑ 
;
∑∑ 
}
∏∏ 
public
øø 

bool
øø 
Remove
øø 
(
øø 
Timeline
øø 
<
øø  
TValue
øø  &
>
øø& '
timeline
øø( 0
)
øø0 1
=>
¿¿ 

Remove
¿¿ 
(
¿¿ 
timeline
¿¿ 
.
¿¿ 
ToArray
¿¿ "
(
¿¿" #
)
¿¿# $
)
¿¿$ %
;
¿¿% &
public
∆∆ 

bool
∆∆ 
RemoveTimes
∆∆ 
(
∆∆ 
params
∆∆ "
DateTime
∆∆# +
[
∆∆+ ,
]
∆∆, -
times
∆∆. 3
)
∆∆3 4
{
«« 
var
»» *
isTimeContainedInTheTimeline
»» (
=
»») *
times
»»+ 0
.
»»0 1
Any
»»1 4
(
»»4 5
time
»»5 9
=>
»»: <
GetAllTimes
»»= H
(
»»H I
)
»»I J
.
»»J K
Contains
»»K S
(
»»S T
time
»»T X
)
»»X Y
)
»»Y Z
;
»»Z [
if
   

(
   
!
   *
isTimeContainedInTheTimeline
   )
)
  ) *
{
ÀÀ 	
return
ÃÃ 
false
ÃÃ 
;
ÃÃ 
}
ÕÕ 	
var
œœ 
eventsToRemove
œœ 
=
œœ 
times
œœ "
.
œœ" #

SelectMany
œœ# -
(
œœ- .
time
œœ. 2
=>
œœ3 5
timeline
–– 
.
–– 
Where
–– 
(
–– 
@event
–– !
=>
––" $
@event
––% +
.
––+ ,
Time
––, 0
==
––1 3
time
––4 8
)
––8 9
)
––9 :
.
—— 
ToList
—— 
(
—— 
)
—— 
;
—— 
foreach
”” 
(
”” 
var
”” 
@event
”” 
in
”” 
eventsToRemove
”” -
)
””- .
{
‘‘ 	
timeline
’’ 
.
’’ 
Remove
’’ 
(
’’ 
@event
’’ "
)
’’" #
;
’’# $
}
÷÷ 	
return
ÿÿ 
true
ÿÿ 
;
ÿÿ 
}
ŸŸ 
public
ﬂﬂ 

bool
ﬂﬂ 
RemoveValues
ﬂﬂ 
(
ﬂﬂ 
params
ﬂﬂ #
TValue
ﬂﬂ$ *
[
ﬂﬂ* +
]
ﬂﬂ+ ,
values
ﬂﬂ- 3
)
ﬂﬂ3 4
{
‡‡ 
var
·· +
isValueContainedInTheTimeline
·· )
=
··* +
values
··, 2
.
··2 3
Any
··3 6
(
··6 7
v
··7 8
=>
··9 ;
GetAllValues
··< H
(
··H I
)
··I J
.
··J K
Contains
··K S
(
··S T
v
··T U
)
··U V
)
··V W
;
··W X
if
„„ 

(
„„ 
!
„„ +
isValueContainedInTheTimeline
„„ *
)
„„* +
{
‰‰ 	
return
ÂÂ 
false
ÂÂ 
;
ÂÂ 
}
ÊÊ 	
var
ËË 
eventsToRemove
ËË 
=
ËË 
values
ËË #
.
ËË# $

SelectMany
ËË$ .
(
ËË. /
value
ËË/ 4
=>
ËË5 7
timeline
ÈÈ 
.
ÈÈ 
Where
ÈÈ 
(
ÈÈ 
@event
ÈÈ !
=>
ÈÈ" $
EqualityComparer
ÈÈ% 5
<
ÈÈ5 6
TValue
ÈÈ6 <
>
ÈÈ< =
.
ÈÈ= >
Default
ÈÈ> E
.
ÈÈE F
Equals
ÈÈF L
(
ÈÈL M
@event
ÈÈM S
.
ÈÈS T
Value
ÈÈT Y
,
ÈÈY Z
value
ÈÈ[ `
)
ÈÈ` a
)
ÈÈa b
)
ÈÈb c
.
ÍÍ 
ToList
ÍÍ 
(
ÍÍ 
)
ÍÍ 
;
ÍÍ 
foreach
ÏÏ 
(
ÏÏ 
var
ÏÏ 
@event
ÏÏ 
in
ÏÏ 
eventsToRemove
ÏÏ -
)
ÏÏ- .
{
ÌÌ 	
timeline
ÓÓ 
.
ÓÓ 
Remove
ÓÓ 
(
ÓÓ 
@event
ÓÓ "
)
ÓÓ" #
;
ÓÓ# $
}
ÔÔ 	
return
ÒÒ 
true
ÒÒ 
;
ÒÒ 
}
ÚÚ 
public
˙˙ 

(
˙˙ 
DateTime
˙˙ 
Time
˙˙ 
,
˙˙ 
TValue
˙˙ !
Value
˙˙" '
)
˙˙' (
[
˙˙( )
]
˙˙) *
ToArray
˙˙+ 2
(
˙˙2 3
)
˙˙3 4
=>
˚˚ 

timeline
˚˚ 
.
˚˚ 
ToArray
˚˚ 
(
˚˚ 
)
˚˚ 
;
˚˚ 
public
ÉÉ 

IList
ÉÉ 
<
ÉÉ 
(
ÉÉ 
DateTime
ÉÉ 
Time
ÉÉ 
,
ÉÉ  
TValue
ÉÉ! '
Value
ÉÉ( -
)
ÉÉ- .
>
ÉÉ. /
ToList
ÉÉ0 6
(
ÉÉ6 7
)
ÉÉ7 8
=>
ÑÑ 

timeline
ÑÑ 
;
ÑÑ 
public
åå 

IDictionary
åå 
<
åå 
DateTime
åå 
,
åå  
TValue
åå! '
>
åå' (
ToDictionary
åå) 5
(
åå5 6
)
åå6 7
=>
çç 

timeline
çç 
.
çç 
ToDictionary
çç  
(
çç  !
@event
çç! '
=>
çç( *
@event
çç+ 1
.
çç1 2
Time
çç2 6
,
çç6 7
@event
çç8 >
=>
çç? A
@event
ççB H
.
ççH I
Value
ççI N
)
ççN O
;
ççO P
public
êê 

override
êê 
bool
êê 
Equals
êê 
(
êê  
object
êê  &
?
êê& '
obj
êê( +
)
êê+ ,
=>
ëë 

obj
ëë 
is
ëë 
Timeline
ëë 
<
ëë 
TValue
ëë !
>
ëë! "
otherTimeline
ëë# 0
&&
íí 
this
íí 
==
íí 
otherTimeline
íí #
;
íí# $
public
ïï 

override
ïï 
int
ïï 
GetHashCode
ïï #
(
ïï# $
)
ïï$ %
=>
ññ 

timeline
ññ 
.
ññ 
GetHashCode
ññ 
(
ññ  
)
ññ  !
;
ññ! "
}óó ≈Ø
pC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\ScapegoatTree\ScapegoatTree.cs
	namespace 	
DataStructures
 
. 
ScapegoatTree &
;& '
public 
class 
ScapegoatTree 
< 
TKey 
>  
where! &
TKey' +
:, -
IComparable. 9
{ 
public 

double 
Alpha 
{ 
get 
; 
private &
set' *
;* +
}, -
public 

Node 
< 
TKey 
> 
? 
Root 
{ 
get !
;! "
private# *
set+ .
;. /
}0 1
public 

int 
Size 
{ 
get 
; 
private "
set# &
;& '
}( )
public 

int 
MaxSize 
{ 
get 
; 
private %
set& )
;) *
}+ ,
public$$ 

event$$ 
EventHandler$$ 
?$$ 
TreeIsUnbalanced$$ /
;$$/ 0
public&& 

ScapegoatTree&& 
(&& 
)&& 
:'' 	
this''
 
('' 
alpha'' 
:'' 
$num'' 
,'' 
size'' 
:''  
$num''! "
)''" #
{(( 
})) 
public++ 

ScapegoatTree++ 
(++ 
double++ 
alpha++  %
)++% &
:,, 	
this,,
 
(,, 
alpha,, 
,,, 
size,, 
:,, 
$num,, 
),, 
{-- 
}.. 
public00 

ScapegoatTree00 
(00 
Node00 
<00 
TKey00 "
>00" #
node00$ (
,00( )
double00* 0
alpha001 6
)006 7
:11 	
this11
 
(11 
alpha11 
,11 
size11 
:11 
node11  
.11  !
GetSize11! (
(11( )
)11) *
)11* +
{22 
Root33 
=33 
node33 
;33 
}44 
public66 

ScapegoatTree66 
(66 
TKey66 
key66 !
,66! "
double66# )
alpha66* /
=660 1
$num662 5
)665 6
:77 	
this77
 
(77 
alpha77 
,77 
size77 
:77 
$num77 
)77 
{88 
Root99 
=99 
new99 
Node99 
<99 
TKey99 
>99 
(99 
key99 !
)99! "
;99" #
}:: 
private<< 
ScapegoatTree<< 
(<< 
double<<  
alpha<<! &
,<<& '
int<<( +
size<<, 0
)<<0 1
{== 

CheckAlpha>> 
(>> 
alpha>> 
)>> 
;>> 
Alpha@@ 
=@@ 
alpha@@ 
;@@ 
SizeBB 
=BB 
sizeBB 
;BB 
MaxSizeCC 
=CC 
sizeCC 
;CC 
}DD 
publicJJ 

boolJJ !
IsAlphaWeightBalancedJJ %
(JJ% &
)JJ& '
{KK 
returnLL 
RootLL 
?LL 
.LL !
IsAlphaWeightBalancedLL *
(LL* +
AlphaLL+ 0
)LL0 1
??LL2 4
trueLL5 9
;LL9 :
}MM 
publicTT 

boolTT 
ContainsTT 
(TT 
TKeyTT 
keyTT !
)TT! "
{UU 
returnVV 
SearchVV 
(VV 
keyVV 
)VV 
!=VV 
nullVV "
;VV" #
}WW 
public^^ 

Node^^ 
<^^ 
TKey^^ 
>^^ 
?^^ 
Search^^ 
(^^ 
TKey^^ "
key^^# &
)^^& '
{__ 
if`` 

(`` 
Root`` 
==`` 
null`` 
)`` 
{aa 	
returnbb 
nullbb 
;bb 
}cc 	
varee 
currentee 
=ee 
Rootee 
;ee 
whilegg 
(gg 
truegg 
)gg 
{hh 	
varii 
resultii 
=ii 
currentii  
.ii  !
Keyii! $
.ii$ %
	CompareToii% .
(ii. /
keyii/ 2
)ii2 3
;ii3 4
switchkk 
(kk 
resultkk 
)kk 
{ll 
casemm 
$nummm 
:mm 
returnnn 
currentnn "
;nn" #
caseoo 
>oo 
$numoo 
whenoo 
currentoo %
.oo% &
Leftoo& *
!=oo+ -
nulloo. 2
:oo2 3
currentpp 
=pp 
currentpp %
.pp% &
Leftpp& *
;pp* +
breakqq 
;qq 
caserr 
<rr 
$numrr 
whenrr 
currentrr %
.rr% &
Rightrr& +
!=rr, .
nullrr/ 3
:rr3 4
currentss 
=ss 
currentss %
.ss% &
Rightss& +
;ss+ ,
breaktt 
;tt 
defaultuu 
:uu 
returnvv 
nullvv 
;vv  
}ww 
}xx 	
}yy 
public
ÄÄ 

bool
ÄÄ 
Insert
ÄÄ 
(
ÄÄ 
TKey
ÄÄ 
key
ÄÄ 
)
ÄÄ  
{
ÅÅ 
var
ÇÇ 
node
ÇÇ 
=
ÇÇ 
new
ÇÇ 
Node
ÇÇ 
<
ÇÇ 
TKey
ÇÇ  
>
ÇÇ  !
(
ÇÇ! "
key
ÇÇ" %
)
ÇÇ% &
;
ÇÇ& '
if
ÑÑ 

(
ÑÑ 
Root
ÑÑ 
==
ÑÑ 
null
ÑÑ 
)
ÑÑ 
{
ÖÖ 	
Root
ÜÜ 
=
ÜÜ 
node
ÜÜ 
;
ÜÜ 
UpdateSizes
àà 
(
àà 
)
àà 
;
àà 
return
ää 
true
ää 
;
ää 
}
ãã 	
var
çç 
path
çç 
=
çç 
new
çç 
Stack
çç 
<
çç 
Node
çç !
<
çç! "
TKey
çç" &
>
çç& '
>
çç' (
(
çç( )
)
çç) *
;
çç* +
var
èè 
current
èè 
=
èè 
Root
èè 
;
èè 
var
ëë 
found
ëë 
=
ëë 
false
ëë 
;
ëë 
while
ìì 
(
ìì 
!
ìì 
found
ìì 
)
ìì 
{
îî 	
path
ïï 
.
ïï 
Push
ïï 
(
ïï 
current
ïï 
)
ïï 
;
ïï 
var
óó 
result
óó 
=
óó 
current
óó  
.
óó  !
Key
óó! $
.
óó$ %
	CompareTo
óó% .
(
óó. /
node
óó/ 3
.
óó3 4
Key
óó4 7
)
óó7 8
;
óó8 9
switch
ôô 
(
ôô 
result
ôô 
)
ôô 
{
öö 
case
õõ 
<
õõ 
$num
õõ 
when
õõ 
current
õõ %
.
õõ% &
Right
õõ& +
!=
õõ, .
null
õõ/ 3
:
õõ3 4
current
úú 
=
úú 
current
úú %
.
úú% &
Right
úú& +
;
úú+ ,
continue
ùù 
;
ùù 
case
ûû 
<
ûû 
$num
ûû 
:
ûû 
current
üü 
.
üü 
Right
üü !
=
üü" #
node
üü$ (
;
üü( )
found
†† 
=
†† 
true
††  
;
††  !
break
°° 
;
°° 
case
¢¢ 
>
¢¢ 
$num
¢¢ 
when
¢¢ 
current
¢¢ %
.
¢¢% &
Left
¢¢& *
!=
¢¢+ -
null
¢¢. 2
:
¢¢2 3
current
££ 
=
££ 
current
££ %
.
££% &
Left
££& *
;
££* +
continue
§§ 
;
§§ 
case
•• 
>
•• 
$num
•• 
:
•• 
current
¶¶ 
.
¶¶ 
Left
¶¶  
=
¶¶! "
node
¶¶# '
;
¶¶' (
found
ßß 
=
ßß 
true
ßß  
;
ßß  !
break
®® 
;
®® 
default
©© 
:
©© 
return
™™ 
false
™™  
;
™™  !
}
´´ 
}
¨¨ 	
UpdateSizes
ÆÆ 
(
ÆÆ 
)
ÆÆ 
;
ÆÆ 
if
∞∞ 

(
∞∞ 
path
∞∞ 
.
∞∞ 
Count
∞∞ 
>
∞∞ 
Root
∞∞ 
.
∞∞ 
GetAlphaHeight
∞∞ ,
(
∞∞, -
Alpha
∞∞- 2
)
∞∞2 3
)
∞∞3 4
{
±± 	
TreeIsUnbalanced
≤≤ 
?
≤≤ 
.
≤≤ 
Invoke
≤≤ $
(
≤≤$ %
this
≤≤% )
,
≤≤) *
	EventArgs
≤≤+ 4
.
≤≤4 5
Empty
≤≤5 :
)
≤≤: ;
;
≤≤; <
BalanceFromPath
¥¥ 
(
¥¥ 
path
¥¥  
)
¥¥  !
;
¥¥! "
MaxSize
∂∂ 
=
∂∂ 
Math
∂∂ 
.
∂∂ 
Max
∂∂ 
(
∂∂ 
MaxSize
∂∂ &
,
∂∂& '
Size
∂∂( ,
)
∂∂, -
;
∂∂- .
}
∑∑ 	
return
ππ 
true
ππ 
;
ππ 
}
∫∫ 
public
¡¡ 

bool
¡¡ 
Delete
¡¡ 
(
¡¡ 
TKey
¡¡ 
key
¡¡ 
)
¡¡  
{
¬¬ 
if
√√ 

(
√√ 
Root
√√ 
==
√√ 
null
√√ 
)
√√ 
{
ƒƒ 	
return
≈≈ 
false
≈≈ 
;
≈≈ 
}
∆∆ 	
if
»» 

(
»» 
Remove
»» 
(
»» 
Root
»» 
,
»» 
Root
»» 
,
»» 
key
»» "
)
»»" #
)
»»# $
{
…… 	
Size
   
--
   
;
   
if
ÃÃ 
(
ÃÃ 
Root
ÃÃ 
!=
ÃÃ 
null
ÃÃ 
&&
ÃÃ 
Size
ÃÃ  $
<
ÃÃ% &
Alpha
ÃÃ' ,
*
ÃÃ- .
MaxSize
ÃÃ/ 6
)
ÃÃ6 7
{
ÕÕ 
TreeIsUnbalanced
ŒŒ  
?
ŒŒ  !
.
ŒŒ! "
Invoke
ŒŒ" (
(
ŒŒ( )
this
ŒŒ) -
,
ŒŒ- .
	EventArgs
ŒŒ/ 8
.
ŒŒ8 9
Empty
ŒŒ9 >
)
ŒŒ> ?
;
ŒŒ? @
var
–– 
list
–– 
=
–– 
new
–– 
List
–– #
<
––# $
Node
––$ (
<
––( )
TKey
––) -
>
––- .
>
––. /
(
––/ 0
)
––0 1
;
––1 2

Extensions
““ 
.
““ 
FlattenTree
““ &
(
““& '
Root
““' +
,
““+ ,
list
““- 1
)
““1 2
;
““2 3
Root
‘‘ 
=
‘‘ 

Extensions
‘‘ !
.
‘‘! "
RebuildFromList
‘‘" 1
(
‘‘1 2
list
‘‘2 6
,
‘‘6 7
$num
‘‘8 9
,
‘‘9 :
list
‘‘; ?
.
‘‘? @
Count
‘‘@ E
-
‘‘F G
$num
‘‘H I
)
‘‘I J
;
‘‘J K
MaxSize
÷÷ 
=
÷÷ 
Size
÷÷ 
;
÷÷ 
}
◊◊ 
return
ŸŸ 
true
ŸŸ 
;
ŸŸ 
}
⁄⁄ 	
return
‹‹ 
false
‹‹ 
;
‹‹ 
}
›› 
public
‚‚ 

void
‚‚ 
Clear
‚‚ 
(
‚‚ 
)
‚‚ 
{
„„ 
Size
‰‰ 
=
‰‰ 
$num
‰‰ 
;
‰‰ 
MaxSize
ÂÂ 
=
ÂÂ 
$num
ÂÂ 
;
ÂÂ 
Root
ÊÊ 
=
ÊÊ 
null
ÊÊ 
;
ÊÊ 
}
ÁÁ 
public
ÌÌ 

void
ÌÌ 
Tune
ÌÌ 
(
ÌÌ 
double
ÌÌ 
value
ÌÌ !
)
ÌÌ! "
{
ÓÓ 

CheckAlpha
ÔÔ 
(
ÔÔ 
value
ÔÔ 
)
ÔÔ 
;
ÔÔ 
Alpha
 
=
 
value
 
;
 
}
ÒÒ 
public
˙˙ 

(
˙˙ 
Node
˙˙ 
<
˙˙ 
TKey
˙˙ 
>
˙˙ 
?
˙˙ 
Parent
˙˙ 
,
˙˙ 
Node
˙˙  $
<
˙˙$ %
TKey
˙˙% )
>
˙˙) *
	Scapegoat
˙˙+ 4
)
˙˙4 5!
FindScapegoatInPath
˙˙6 I
(
˙˙I J
Stack
˙˙J O
<
˙˙O P
Node
˙˙P T
<
˙˙T U
TKey
˙˙U Y
>
˙˙Y Z
>
˙˙Z [
path
˙˙\ `
)
˙˙` a
{
˚˚ 
if
¸¸ 

(
¸¸ 
path
¸¸ 
.
¸¸ 
Count
¸¸ 
==
¸¸ 
$num
¸¸ 
)
¸¸ 
{
˝˝ 	
throw
˛˛ 
new
˛˛ 
ArgumentException
˛˛ '
(
˛˛' (
$str
˛˛( R
,
˛˛R S
nameof
˛˛T Z
(
˛˛Z [
path
˛˛[ _
)
˛˛_ `
)
˛˛` a
;
˛˛a b
}
ˇˇ 	
var
ÅÅ 
depth
ÅÅ 
=
ÅÅ 
$num
ÅÅ 
;
ÅÅ 
while
ÉÉ 
(
ÉÉ 
path
ÉÉ 
.
ÉÉ 
TryPop
ÉÉ 
(
ÉÉ 
out
ÉÉ 
var
ÉÉ "
next
ÉÉ# '
)
ÉÉ' (
)
ÉÉ( )
{
ÑÑ 	
if
ÖÖ 
(
ÖÖ 
depth
ÖÖ 
>
ÖÖ 
next
ÖÖ 
.
ÖÖ 
GetAlphaHeight
ÖÖ +
(
ÖÖ+ ,
Alpha
ÖÖ, 1
)
ÖÖ1 2
)
ÖÖ2 3
{
ÜÜ 
return
áá 
path
áá 
.
áá 
TryPop
áá "
(
áá" #
out
áá# &
var
áá' *
parent
áá+ 1
)
áá1 2
?
áá3 4
(
áá5 6
parent
áá6 <
,
áá< =
next
áá> B
)
ááB C
:
ááD E
(
ááF G
null
ááG K
,
ááK L
next
ááM Q
)
ááQ R
;
ááR S
}
àà 
depth
ää 
++
ää 
;
ää 
}
ãã 	
throw
çç 
new
çç '
InvalidOperationException
çç +
(
çç+ ,
$str
çç, i
)
ççi j
;
ççj k
}
éé 
private
êê 
static
êê 
void
êê 

CheckAlpha
êê "
(
êê" #
double
êê# )
alpha
êê* /
)
êê/ 0
{
ëë 
if
íí 

(
íí 
alpha
íí 
is
íí 
<
íí 
$num
íí 
or
íí 
>
íí 
$num
íí  #
)
íí# $
{
ìì 	
throw
îî 
new
îî 
ArgumentException
îî '
(
îî' (
$str
îî( b
,
îîb c
nameof
îîd j
(
îîj k
alpha
îîk p
)
îîp q
)
îîq r
;
îîr s
}
ïï 	
}
ññ 
private
òò 
bool
òò 
Remove
òò 
(
òò 
Node
òò 
<
òò 
TKey
òò !
>
òò! "
?
òò" #
parent
òò$ *
,
òò* +
Node
òò, 0
<
òò0 1
TKey
òò1 5
>
òò5 6
?
òò6 7
node
òò8 <
,
òò< =
TKey
òò> B
key
òòC F
)
òòF G
{
ôô 
if
öö 

(
öö 
node
öö 
is
öö 
null
öö 
||
öö 
parent
öö "
is
öö# %
null
öö& *
)
öö* +
{
õõ 	
return
úú 
false
úú 
;
úú 
}
ùù 	
var
üü 
compareResult
üü 
=
üü 
node
üü  
.
üü  !
Key
üü! $
.
üü$ %
	CompareTo
üü% .
(
üü. /
key
üü/ 2
)
üü2 3
;
üü3 4
if
°° 

(
°° 
compareResult
°° 
>
°° 
$num
°° 
)
°° 
{
¢¢ 	
return
££ 
Remove
££ 
(
££ 
node
££ 
,
££ 
node
££  $
.
££$ %
Left
££% )
,
££) *
key
££+ .
)
££. /
;
££/ 0
}
§§ 	
if
¶¶ 

(
¶¶ 
compareResult
¶¶ 
<
¶¶ 
$num
¶¶ 
)
¶¶ 
{
ßß 	
return
®® 
Remove
®® 
(
®® 
node
®® 
,
®® 
node
®®  $
.
®®$ %
Right
®®% *
,
®®* +
key
®®, /
)
®®/ 0
;
®®0 1
}
©© 	
Node
´´ 
<
´´ 
TKey
´´ 
>
´´ 
?
´´ 
replacementNode
´´ #
;
´´# $
if
ØØ 

(
ØØ 
node
ØØ 
.
ØØ 
Left
ØØ 
is
ØØ 
null
ØØ 
||
ØØ  
node
ØØ! %
.
ØØ% &
Right
ØØ& +
is
ØØ, .
null
ØØ/ 3
)
ØØ3 4
{
∞∞ 	
replacementNode
±± 
=
±± 
node
±± "
.
±±" #
Left
±±# '
??
±±( *
node
±±+ /
.
±±/ 0
Right
±±0 5
;
±±5 6
}
≤≤ 	
else
µµ 
{
∂∂ 	
var
∑∑ 
predecessorNode
∑∑ 
=
∑∑  !
node
∑∑" &
.
∑∑& '
Left
∑∑' +
.
∑∑+ ,
GetLargestKeyNode
∑∑, =
(
∑∑= >
)
∑∑> ?
;
∑∑? @
Remove
∏∏ 
(
∏∏ 
Root
∏∏ 
,
∏∏ 
Root
∏∏ 
,
∏∏ 
predecessorNode
∏∏ .
.
∏∏. /
Key
∏∏/ 2
)
∏∏2 3
;
∏∏3 4
replacementNode
ππ 
=
ππ 
new
ππ !
Node
ππ" &
<
ππ& '
TKey
ππ' +
>
ππ+ ,
(
ππ, -
predecessorNode
ππ- <
.
ππ< =
Key
ππ= @
)
ππ@ A
{
∫∫ 
Left
ªª 
=
ªª 
node
ªª 
.
ªª 
Left
ªª  
,
ªª  !
Right
ºº 
=
ºº 
node
ºº 
.
ºº 
Right
ºº "
,
ºº" #
}
ΩΩ 
;
ΩΩ 
}
ææ 	
if
¬¬ 

(
¬¬ 
node
¬¬ 
==
¬¬ 
Root
¬¬ 
)
¬¬ 
{
√√ 	
Root
ƒƒ 
=
ƒƒ 
replacementNode
ƒƒ "
;
ƒƒ" #
}
≈≈ 	
else
∆∆ 
if
∆∆ 
(
∆∆ 
parent
∆∆ 
.
∆∆ 
Left
∆∆ 
==
∆∆ 
node
∆∆  $
)
∆∆$ %
{
«« 	
parent
»» 
.
»» 
Left
»» 
=
»» 
replacementNode
»» )
;
»») *
}
…… 	
else
   
{
ÀÀ 	
parent
ÃÃ 
.
ÃÃ 
Right
ÃÃ 
=
ÃÃ 
replacementNode
ÃÃ *
;
ÃÃ* +
}
ÕÕ 	
return
œœ 
true
œœ 
;
œœ 
}
–– 
private
““ 
void
““ 
BalanceFromPath
““  
(
““  !
Stack
““! &
<
““& '
Node
““' +
<
““+ ,
TKey
““, 0
>
““0 1
>
““1 2
path
““3 7
)
““7 8
{
”” 
var
‘‘ 
(
‘‘ 
parent
‘‘ 
,
‘‘ 
	scapegoat
‘‘ 
)
‘‘ 
=
‘‘  !!
FindScapegoatInPath
‘‘" 5
(
‘‘5 6
path
‘‘6 :
)
‘‘: ;
;
‘‘; <
var
÷÷ 
list
÷÷ 
=
÷÷ 
new
÷÷ 
List
÷÷ 
<
÷÷ 
Node
÷÷  
<
÷÷  !
TKey
÷÷! %
>
÷÷% &
>
÷÷& '
(
÷÷' (
)
÷÷( )
;
÷÷) *

Extensions
ÿÿ 
.
ÿÿ 
FlattenTree
ÿÿ 
(
ÿÿ 
	scapegoat
ÿÿ (
,
ÿÿ( )
list
ÿÿ* .
)
ÿÿ. /
;
ÿÿ/ 0
var
⁄⁄ 
tree
⁄⁄ 
=
⁄⁄ 

Extensions
⁄⁄ 
.
⁄⁄ 
RebuildFromList
⁄⁄ -
(
⁄⁄- .
list
⁄⁄. 2
,
⁄⁄2 3
$num
⁄⁄4 5
,
⁄⁄5 6
list
⁄⁄7 ;
.
⁄⁄; <
Count
⁄⁄< A
-
⁄⁄B C
$num
⁄⁄D E
)
⁄⁄E F
;
⁄⁄F G
if
‹‹ 

(
‹‹ 
parent
‹‹ 
==
‹‹ 
null
‹‹ 
)
‹‹ 
{
›› 	
Root
ﬁﬁ 
=
ﬁﬁ 
tree
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 	
else
‡‡ 
{
·· 	
var
‚‚ 
result
‚‚ 
=
‚‚ 
parent
‚‚ 
.
‚‚  
Key
‚‚  #
.
‚‚# $
	CompareTo
‚‚$ -
(
‚‚- .
tree
‚‚. 2
.
‚‚2 3
Key
‚‚3 6
)
‚‚6 7
;
‚‚7 8
if
‰‰ 
(
‰‰ 
result
‰‰ 
<
‰‰ 
$num
‰‰ 
)
‰‰ 
{
ÂÂ 
parent
ÊÊ 
.
ÊÊ 
Right
ÊÊ 
=
ÊÊ 
tree
ÊÊ #
;
ÊÊ# $
}
ÁÁ 
else
ËË 
{
ÈÈ 
parent
ÍÍ 
.
ÍÍ 
Left
ÍÍ 
=
ÍÍ 
tree
ÍÍ "
;
ÍÍ" #
}
ÎÎ 
}
ÏÏ 	
}
ÌÌ 
private
ÔÔ 
void
ÔÔ 
UpdateSizes
ÔÔ 
(
ÔÔ 
)
ÔÔ 
{
 
Size
ÒÒ 
+=
ÒÒ 
$num
ÒÒ 
;
ÒÒ 
MaxSize
ÚÚ 
=
ÚÚ 
Math
ÚÚ 
.
ÚÚ 
Max
ÚÚ 
(
ÚÚ 
Size
ÚÚ 
,
ÚÚ  
MaxSize
ÚÚ! (
)
ÚÚ( )
;
ÚÚ) *
}
ÛÛ 
}ÙÙ ø/
gC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\ScapegoatTree\Node.cs
	namespace 	
DataStructures
 
. 
ScapegoatTree &
;& '
public		 
class		 
Node		 
<		 
TKey		 
>		 
where		 
TKey		 "
:		# $
IComparable		% 0
{

 
private 
Node 
< 
TKey 
> 
? 
right 
; 
private 
Node 
< 
TKey 
> 
? 
left 
; 
public 

TKey 
Key 
{ 
get 
; 
} 
public 

Node 
< 
TKey 
> 
? 
Right 
{ 
get 
=> 
right 
; 
set 
{ 	
if 
( 
value 
!= 
null 
&&  
!! "
value" '
.' (!
IsGreaterThanOrSameAs( =
(= >
Key> A
)A B
)B C
{ 
throw 
new 
ArgumentException +
(+ ,
$str, s
,s t
nameofu {
({ |
value	| Å
)
Å Ç
)
Ç É
;
É Ñ
} 
right 
= 
value 
; 
} 	
} 
public 

Node 
< 
TKey 
> 
? 
Left 
{ 
get   
=>   
left   
;   
set!! 
{"" 	
if## 
(## 
value## 
!=## 
null## 
&&##  
value##! &
.##& '!
IsGreaterThanOrSameAs##' <
(##< =
Key##= @
)##@ A
)##A B
{$$ 
throw%% 
new%% 
ArgumentException%% +
(%%+ ,
$str%%, r
,%%r s
nameof%%t z
(%%z {
value	%%{ Ä
)
%%Ä Å
)
%%Å Ç
;
%%Ç É
}&& 
left(( 
=(( 
value(( 
;(( 
})) 	
}** 
public,, 

Node,, 
(,, 
TKey,, 
key,, 
),, 
=>,, 
Key,,  
=,,! "
key,,# &
;,,& '
public.. 

Node.. 
(.. 
TKey.. 
key.. 
,.. 
Node.. 
<.. 
TKey.. #
>..# $
?..$ %
right..& +
,..+ ,
Node..- 1
<..1 2
TKey..2 6
>..6 7
?..7 8
left..9 =
)..= >
:// 	
this//
 
(// 
key// 
)// 
{00 
Right11 
=11 
right11 
;11 
Left22 
=22 
left22 
;22 
}33 
public99 

int99 
GetSize99 
(99 
)99 
=>99 
(99 
Left99 !
?99! "
.99" #
GetSize99# *
(99* +
)99+ ,
??99- /
$num990 1
)991 2
+993 4
$num995 6
+997 8
(999 :
Right99: ?
?99? @
.99@ A
GetSize99A H
(99H I
)99I J
??99K M
$num99N O
)99O P
;99P Q
public@@ 

double@@ 
GetAlphaHeight@@  
(@@  !
double@@! '
alpha@@( -
)@@- .
=>@@/ 1
Math@@2 6
.@@6 7
Floor@@7 <
(@@< =
Math@@= A
.@@A B
Log@@B E
(@@E F
GetSize@@F M
(@@M N
)@@N O
,@@O P
$num@@Q T
/@@U V
alpha@@W \
)@@\ ]
)@@] ^
;@@^ _
publicBB 

NodeBB 
<BB 
TKeyBB 
>BB 
GetSmallestKeyNodeBB (
(BB( )
)BB) *
=>BB+ -
LeftBB. 2
?BB2 3
.BB3 4
GetSmallestKeyNodeBB4 F
(BBF G
)BBG H
??BBI K
thisBBL P
;BBP Q
publicDD 

NodeDD 
<DD 
TKeyDD 
>DD 
GetLargestKeyNodeDD '
(DD' (
)DD( )
=>DD* ,
RightDD- 2
?DD2 3
.DD3 4
GetLargestKeyNodeDD4 E
(DDE F
)DDF G
??DDH J
thisDDK O
;DDO P
publicKK 

boolKK !
IsAlphaWeightBalancedKK %
(KK% &
doubleKK& ,
aKK- .
)KK. /
{LL 
varMM 
isLeftBalancedMM 
=MM 
(MM 
LeftMM "
?MM" #
.MM# $
GetSizeMM$ +
(MM+ ,
)MM, -
??MM. 0
$numMM1 2
)MM2 3
<=MM4 6
aMM7 8
*MM9 :
GetSizeMM; B
(MMB C
)MMC D
;MMD E
varNN 
isRightBalancedNN 
=NN 
(NN 
RightNN $
?NN$ %
.NN% &
GetSizeNN& -
(NN- .
)NN. /
??NN0 2
$numNN3 4
)NN4 5
<=NN6 8
aNN9 :
*NN; <
GetSizeNN= D
(NND E
)NNE F
;NNF G
returnPP 
isLeftBalancedPP 
&&PP  
isRightBalancedPP! 0
;PP0 1
}QQ 
privateSS 
boolSS !
IsGreaterThanOrSameAsSS &
(SS& '
TKeySS' +
keySS, /
)SS/ 0
{TT 
returnUU 
KeyUU 
.UU 
	CompareToUU 
(UU 
keyUU  
)UU  !
>=UU" $
$numUU% &
;UU& '
}VV 
}WW Ω
mC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\ScapegoatTree\Extensions.cs
	namespace 	
DataStructures
 
. 
ScapegoatTree &
;& '
public 
static 
class 

Extensions 
{ 
public 

static 
void 
FlattenTree "
<" #
TKey# '
>' (
(( )
Node) -
<- .
TKey. 2
>2 3
root4 8
,8 9
List: >
<> ?
Node? C
<C D
TKeyD H
>H I
>I J
listK O
)O P
whereQ V
TKeyW [
:\ ]
IComparable^ i
{ 
if 

( 
root 
. 
Left 
!= 
null 
) 
{ 	
FlattenTree 
( 
root 
. 
Left !
,! "
list# '
)' (
;( )
} 	
list 
. 
Add 
( 
root 
) 
; 
if 

( 
root 
. 
Right 
!= 
null 
) 
{ 	
FlattenTree 
( 
root 
. 
Right "
," #
list$ (
)( )
;) *
} 	
} 
public'' 

static'' 
Node'' 
<'' 
TKey'' 
>'' 
RebuildFromList'' ,
<'', -
TKey''- 1
>''1 2
(''2 3
IList''3 8
<''8 9
Node''9 =
<''= >
TKey''> B
>''B C
>''C D
list''E I
,''I J
int''K N
start''O T
,''T U
int''V Y
end''Z ]
)''] ^
where(( 
TKey(( 
:(( 
IComparable((  
{)) 
if** 

(** 
start** 
>** 
end** 
)** 
{++ 	
throw,, 
new,, 
ArgumentException,, '
(,,' (
$str,,( K
,,,K L
nameof,,M S
(,,S T
start,,T Y
),,Y Z
),,Z [
;,,[ \
}-- 	
var// 
pivot// 
=// 
Convert// 
.// 
ToInt32// #
(//# $
Math//$ (
.//( )
Ceiling//) 0
(//0 1
start//1 6
+//7 8
(//9 :
end//: =
-//> ?
start//@ E
)//E F
///G H
$num//I L
)//L M
)//M N
;//N O
return11 
new11 
Node11 
<11 
TKey11 
>11 
(11 
list11 "
[11" #
pivot11# (
]11( )
.11) *
Key11* -
)11- .
{22 	
Left33 
=33 
start33 
>33 
(33 
pivot33 !
-33" #
$num33$ %
)33% &
?33' (
null33) -
:33. /
RebuildFromList330 ?
(33? @
list33@ D
,33D E
start33F K
,33K L
pivot33M R
-33S T
$num33U V
)33V W
,33W X
Right44 
=44 
(44 
pivot44 
+44 
$num44 
)44 
>44  !
end44" %
?44& '
null44( ,
:44- .
RebuildFromList44/ >
(44> ?
list44? C
,44C D
pivot44E J
+44K L
$num44M N
,44N O
end44P S
)44S T
,44T U
}55 	
;55	 

}66 
}77 ê
rC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\RedBlackTree\RedBlackTreeNode.cs
	namespace 	
DataStructures
 
. 
RedBlackTree %
;% &
public 
enum 
	NodeColor 
: 
byte 
{ 
Red 
, 
Black 	
,	 

} 
public 
class 
RedBlackTreeNode 
< 
TKey "
>" #
{ 
public 

TKey 
Key 
{ 
get 
; 
set 
; 
}  !
public!! 

	NodeColor!! 
Color!! 
{!! 
get!!  
;!!  !
set!!" %
;!!% &
}!!' (
public&& 

RedBlackTreeNode&& 
<&& 
TKey&&  
>&&  !
?&&! "
Parent&&# )
{&&* +
get&&, /
;&&/ 0
set&&1 4
;&&4 5
}&&6 7
public++ 

RedBlackTreeNode++ 
<++ 
TKey++  
>++  !
?++! "
Left++# '
{++( )
get++* -
;++- .
set++/ 2
;++2 3
}++4 5
public00 

RedBlackTreeNode00 
<00 
TKey00  
>00  !
?00! "
Right00# (
{00) *
get00+ .
;00. /
set000 3
;003 4
}005 6
public77 

RedBlackTreeNode77 
(77 
TKey77  
key77! $
,77$ %
RedBlackTreeNode77& 6
<776 7
TKey777 ;
>77; <
?77< =
parent77> D
)77D E
{88 
Key99 
=99 
key99 
;99 
Parent:: 
=:: 
parent:: 
;:: 
};; 
}<< ≈•
nC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\RedBlackTree\RedBlackTree.cs
	namespace 	
DataStructures
 
. 
RedBlackTree %
;% &
public$$ 
class$$ 
RedBlackTree$$ 
<$$ 
TKey$$ 
>$$ 
{%% 
public)) 

int)) 
Count)) 
{)) 
get)) 
;)) 
private)) #
set))$ '
;))' (
}))) *
private.. 
readonly.. 
Comparer.. 
<.. 
TKey.. "
>.." #
comparer..$ ,
;.., -
private33 
RedBlackTreeNode33 
<33 
TKey33 !
>33! "
?33" #
root33$ (
;33( )
public88 

RedBlackTree88 
(88 
)88 
{99 
comparer:: 
=:: 
Comparer:: 
<:: 
TKey::  
>::  !
.::! "
Default::" )
;::) *
};; 
publicBB 

RedBlackTreeBB 
(BB 
ComparerBB  
<BB  !
TKeyBB! %
>BB% &
customComparerBB' 5
)BB5 6
{CC 
comparerDD 
=DD 
customComparerDD !
;DD! "
}EE 
publicKK 

voidKK 
AddKK 
(KK 
TKeyKK 
keyKK 
)KK 
{LL 
ifMM 

(MM 
rootMM 
isMM 
nullMM 
)MM 
{NN 	
rootQQ 
=QQ 
newQQ 
RedBlackTreeNodeQQ '
<QQ' (
TKeyQQ( ,
>QQ, -
(QQ- .
keyQQ. 1
,QQ1 2
nullQQ3 7
)QQ7 8
{RR 
ColorSS 
=SS 
	NodeColorSS !
.SS! "
BlackSS" '
,SS' (
}TT 
;TT 
CountUU 
++UU 
;UU 
returnVV 
;VV 
}WW 	
varZZ 
nodeZZ 
=ZZ 
AddZZ 
(ZZ 
rootZZ 
,ZZ 
keyZZ  
)ZZ  !
;ZZ! "
var]] 
childDir]] 
=]] 
comparer]] 
.]]  
Compare]]  '
(]]' (
node]]( ,
.]], -
Key]]- 0
,]]0 1
node]]2 6
.]]6 7
Parent]]7 =
!]]= >
.]]> ?
Key]]? B
)]]B C
;]]C D
node`` 
=`` 
node`` 
.`` 
Parent`` 
;`` 
intcc 
addCasecc 
;cc 
dodd 

{ee 	
addCaseff 
=ff 

GetAddCaseff  
(ff  !
nodeff! %
)ff% &
;ff& '
switchhh 
(hh 
addCasehh 
)hh 
{ii 
casejj 
$numjj 
:jj 
breakkk 
;kk 
casell 
$numll 
:ll 
varmm 
	oldParentmm !
=mm" #
nodemm$ (
.mm( )
Parentmm) /
;mm/ 0
nodenn 
=nn 
AddCase2nn #
(nn# $
nodenn$ (
)nn( )
;nn) *
ifpp 
(pp 
nodepp 
ispp 
notpp  #
nullpp$ (
)pp( )
{qq 
childDirrr  
=rr! "
comparerrr# +
.rr+ ,
Comparerr, 3
(rr3 4
	oldParentrr4 =
!rr= >
.rr> ?
Keyrr? B
,rrB C
	oldParentrrD M
.rrM N
ParentrrN T
!rrT U
.rrU V
KeyrrV Y
)rrY Z
;rrZ [
}ss 
breakuu 
;uu 
casevv 
$numvv 
:vv 
nodeww 
.ww 
Colorww 
=ww  
	NodeColorww! *
.ww* +
Blackww+ 0
;ww0 1
breakxx 
;xx 
caseyy 
$numyy 
:yy 
	AddCase56zz 
(zz 
nodezz "
,zz" #
comparerzz$ ,
.zz, -
Comparezz- 4
(zz4 5
nodezz5 9
.zz9 :
Keyzz: =
,zz= >
nodezz? C
.zzC D
ParentzzD J
!zzJ K
.zzK L
KeyzzL O
)zzO P
,zzP Q
childDirzzR Z
)zzZ [
;zz[ \
break{{ 
;{{ 
default|| 
:|| 
throw}} 
new}} %
InvalidOperationException}} 7
(}}7 8
$str}}8 `
)}}` a
;}}a b
}~~ 
} 	
while
ÄÄ 
(
ÄÄ 
addCase
ÄÄ 
==
ÄÄ 
$num
ÄÄ 
&&
ÄÄ 
node
ÄÄ #
is
ÄÄ$ &
not
ÄÄ' *
null
ÄÄ+ /
)
ÄÄ/ 0
;
ÄÄ0 1
Count
ÇÇ 
++
ÇÇ 
;
ÇÇ 
}
ÉÉ 
public
ââ 

void
ââ 
AddRange
ââ 
(
ââ 
IEnumerable
ââ $
<
ââ$ %
TKey
ââ% )
>
ââ) *
keys
ââ+ /
)
ââ/ 0
{
ää 
foreach
ãã 
(
ãã 
var
ãã 
key
ãã 
in
ãã 
keys
ãã  
)
ãã  !
{
åå 	
Add
çç 
(
çç 
key
çç 
)
çç 
;
çç 
}
éé 	
}
èè 
public
ïï 

void
ïï 
Remove
ïï 
(
ïï 
TKey
ïï 
key
ïï 
)
ïï  
{
ññ 
var
òò 
node
òò 
=
òò 
Remove
òò 
(
òò 
root
òò 
,
òò 
key
òò  #
)
òò# $
;
òò$ %
node
õõ 
=
õõ 
RemoveSimpleCases
õõ  
(
õõ  !
node
õõ! %
)
õõ% &
;
õõ& '
if
ûû 

(
ûû 
node
ûû 
is
ûû 
null
ûû 
)
ûû 
{
üü 	
return
†† 
;
†† 
}
°° 	

DeleteLeaf
§§ 
(
§§ 
node
§§ 
.
§§ 
Parent
§§ 
!
§§ 
,
§§  
comparer
§§! )
.
§§) *
Compare
§§* 1
(
§§1 2
node
§§2 6
.
§§6 7
Key
§§7 :
,
§§: ;
node
§§< @
.
§§@ A
Parent
§§A G
!
§§G H
.
§§H I
Key
§§I L
)
§§L M
)
§§M N
;
§§N O
do
ßß 

{
®® 	
node
©© 
=
©© 
RemoveRecolor
©©  
(
©©  !
node
©©! %
)
©©% &
;
©©& '
}
™™ 	
while
´´ 
(
´´ 
node
´´ 
is
´´ 
not
´´ 
null
´´ 
&&
´´  "
node
´´# '
.
´´' (
Parent
´´( .
is
´´/ 1
not
´´2 5
null
´´6 :
)
´´: ;
;
´´; <
Count
≠≠ 
--
≠≠ 
;
≠≠ 
}
ÆÆ 
public
µµ 

bool
µµ 
Contains
µµ 
(
µµ 
TKey
µµ 
key
µµ !
)
µµ! "
{
∂∂ 
var
∑∑ 
node
∑∑ 
=
∑∑ 
root
∑∑ 
;
∑∑ 
while
∏∏ 
(
∏∏ 
node
∏∏ 
is
∏∏ 
not
∏∏ 
null
∏∏ 
)
∏∏  
{
ππ 	
var
∫∫ 
compareResult
∫∫ 
=
∫∫ 
comparer
∫∫  (
.
∫∫( )
Compare
∫∫) 0
(
∫∫0 1
key
∫∫1 4
,
∫∫4 5
node
∫∫6 :
.
∫∫: ;
Key
∫∫; >
)
∫∫> ?
;
∫∫? @
if
ªª 
(
ªª 
compareResult
ªª 
<
ªª 
$num
ªª  !
)
ªª! "
{
ºº 
node
ΩΩ 
=
ΩΩ 
node
ΩΩ 
.
ΩΩ 
Left
ΩΩ  
;
ΩΩ  !
}
ææ 
else
øø 
if
øø 
(
øø 
compareResult
øø "
>
øø# $
$num
øø% &
)
øø& '
{
¿¿ 
node
¡¡ 
=
¡¡ 
node
¡¡ 
.
¡¡ 
Right
¡¡ !
;
¡¡! "
}
¬¬ 
else
√√ 
{
ƒƒ 
return
≈≈ 
true
≈≈ 
;
≈≈ 
}
∆∆ 
}
«« 	
return
…… 
false
…… 
;
…… 
}
   
public
–– 

TKey
–– 
GetMin
–– 
(
–– 
)
–– 
{
—— 
if
““ 

(
““ 
root
““ 
is
““ 
null
““ 
)
““ 
{
”” 	
throw
‘‘ 
new
‘‘ '
InvalidOperationException
‘‘ /
(
‘‘/ 0
$str
‘‘0 @
)
‘‘@ A
;
‘‘A B
}
’’ 	
return
◊◊ 
GetMin
◊◊ 
(
◊◊ 
root
◊◊ 
)
◊◊ 
.
◊◊ 
Key
◊◊ 
;
◊◊  
}
ÿÿ 
public
ﬁﬁ 

TKey
ﬁﬁ 
GetMax
ﬁﬁ 
(
ﬁﬁ 
)
ﬁﬁ 
{
ﬂﬂ 
if
‡‡ 

(
‡‡ 
root
‡‡ 
is
‡‡ 
null
‡‡ 
)
‡‡ 
{
·· 	
throw
‚‚ 
new
‚‚ '
InvalidOperationException
‚‚ /
(
‚‚/ 0
$str
‚‚0 @
)
‚‚@ A
;
‚‚A B
}
„„ 	
return
ÂÂ 
GetMax
ÂÂ 
(
ÂÂ 
root
ÂÂ 
)
ÂÂ 
.
ÂÂ 
Key
ÂÂ 
;
ÂÂ  
}
ÊÊ 
public
ÏÏ 

IEnumerable
ÏÏ 
<
ÏÏ 
TKey
ÏÏ 
>
ÏÏ 
GetKeysInOrder
ÏÏ +
(
ÏÏ+ ,
)
ÏÏ, -
{
ÌÌ 
var
ÓÓ 
result
ÓÓ 
=
ÓÓ 
new
ÓÓ 
List
ÓÓ 
<
ÓÓ 
TKey
ÓÓ "
>
ÓÓ" #
(
ÓÓ# $
)
ÓÓ$ %
;
ÓÓ% &
InOrderWalk
ÔÔ 
(
ÔÔ 
root
ÔÔ 
)
ÔÔ 
;
ÔÔ 
return
 
result
 
;
 
void
ÚÚ 
InOrderWalk
ÚÚ 
(
ÚÚ 
RedBlackTreeNode
ÚÚ )
<
ÚÚ) *
TKey
ÚÚ* .
>
ÚÚ. /
?
ÚÚ/ 0
node
ÚÚ1 5
)
ÚÚ5 6
{
ÛÛ 	
if
ÙÙ 
(
ÙÙ 
node
ÙÙ 
is
ÙÙ 
null
ÙÙ 
)
ÙÙ 
{
ıı 
return
ˆˆ 
;
ˆˆ 
}
˜˜ 
InOrderWalk
˘˘ 
(
˘˘ 
node
˘˘ 
.
˘˘ 
Left
˘˘ !
)
˘˘! "
;
˘˘" #
result
˙˙ 
.
˙˙ 
Add
˙˙ 
(
˙˙ 
node
˙˙ 
.
˙˙ 
Key
˙˙ 
)
˙˙  
;
˙˙  !
InOrderWalk
˚˚ 
(
˚˚ 
node
˚˚ 
.
˚˚ 
Right
˚˚ "
)
˚˚" #
;
˚˚# $
}
¸¸ 	
}
˝˝ 
public
ÉÉ 

IEnumerable
ÉÉ 
<
ÉÉ 
TKey
ÉÉ 
>
ÉÉ 
GetKeysPreOrder
ÉÉ ,
(
ÉÉ, -
)
ÉÉ- .
{
ÑÑ 
var
ÖÖ 
result
ÖÖ 
=
ÖÖ 
new
ÖÖ 
List
ÖÖ 
<
ÖÖ 
TKey
ÖÖ "
>
ÖÖ" #
(
ÖÖ# $
)
ÖÖ$ %
;
ÖÖ% &
PreOrderWalk
ÜÜ 
(
ÜÜ 
root
ÜÜ 
)
ÜÜ 
;
ÜÜ 
return
áá 
result
áá 
;
áá 
void
ââ 
PreOrderWalk
ââ 
(
ââ 
RedBlackTreeNode
ââ *
<
ââ* +
TKey
ââ+ /
>
ââ/ 0
?
ââ0 1
node
ââ2 6
)
ââ6 7
{
ää 	
if
ãã 
(
ãã 
node
ãã 
is
ãã 
null
ãã 
)
ãã 
{
åå 
return
çç 
;
çç 
}
éé 
result
êê 
.
êê 
Add
êê 
(
êê 
node
êê 
.
êê 
Key
êê 
)
êê  
;
êê  !
PreOrderWalk
ëë 
(
ëë 
node
ëë 
.
ëë 
Left
ëë "
)
ëë" #
;
ëë# $
PreOrderWalk
íí 
(
íí 
node
íí 
.
íí 
Right
íí #
)
íí# $
;
íí$ %
}
ìì 	
}
îî 
public
öö 

IEnumerable
öö 
<
öö 
TKey
öö 
>
öö 
GetKeysPostOrder
öö -
(
öö- .
)
öö. /
{
õõ 
var
úú 
result
úú 
=
úú 
new
úú 
List
úú 
<
úú 
TKey
úú "
>
úú" #
(
úú# $
)
úú$ %
;
úú% &
PostOrderWalk
ùù 
(
ùù 
root
ùù 
)
ùù 
;
ùù 
return
ûû 
result
ûû 
;
ûû 
void
†† 
PostOrderWalk
†† 
(
†† 
RedBlackTreeNode
†† +
<
††+ ,
TKey
††, 0
>
††0 1
?
††1 2
node
††3 7
)
††7 8
{
°° 	
if
¢¢ 
(
¢¢ 
node
¢¢ 
is
¢¢ 
null
¢¢ 
)
¢¢ 
{
££ 
return
§§ 
;
§§ 
}
•• 
PostOrderWalk
ßß 
(
ßß 
node
ßß 
.
ßß 
Left
ßß #
)
ßß# $
;
ßß$ %
PostOrderWalk
®® 
(
®® 
node
®® 
.
®® 
Right
®® $
)
®®$ %
;
®®% &
result
©© 
.
©© 
Add
©© 
(
©© 
node
©© 
.
©© 
Key
©© 
)
©©  
;
©©  !
}
™™ 	
}
´´ 
private
≥≥ 
RedBlackTreeNode
≥≥ 
<
≥≥ 
TKey
≥≥ !
>
≥≥! "
Add
≥≥# &
(
≥≥& '
RedBlackTreeNode
≥≥' 7
<
≥≥7 8
TKey
≥≥8 <
>
≥≥< =
node
≥≥> B
,
≥≥B C
TKey
≥≥D H
key
≥≥I L
)
≥≥L M
{
¥¥ 
int
µµ 
compareResult
µµ 
;
µµ 
RedBlackTreeNode
∂∂ 
<
∂∂ 
TKey
∂∂ 
>
∂∂ 
newNode
∂∂ &
;
∂∂& '
while
∑∑ 
(
∑∑ 
true
∑∑ 
)
∑∑ 
{
∏∏ 	
compareResult
ππ 
=
ππ 
comparer
ππ $
.
ππ$ %
Compare
ππ% ,
(
ππ, -
key
ππ- 0
,
ππ0 1
node
ππ2 6
!
ππ6 7
.
ππ7 8
Key
ππ8 ;
)
ππ; <
;
ππ< =
if
∫∫ 
(
∫∫ 
compareResult
∫∫ 
<
∫∫ 
$num
∫∫  !
)
∫∫! "
{
ªª 
if
ºº 
(
ºº 
node
ºº 
.
ºº 
Left
ºº 
is
ºº  
null
ºº! %
)
ºº% &
{
ΩΩ 
newNode
ææ 
=
ææ 
new
ææ !
RedBlackTreeNode
ææ" 2
<
ææ2 3
TKey
ææ3 7
>
ææ7 8
(
ææ8 9
key
ææ9 <
,
ææ< =
node
ææ> B
)
ææB C
;
ææC D
node
øø 
.
øø 
Left
øø 
=
øø 
newNode
øø  '
;
øø' (
break
¿¿ 
;
¿¿ 
}
¡¡ 
else
¬¬ 
{
√√ 
node
ƒƒ 
=
ƒƒ 
node
ƒƒ 
.
ƒƒ  
Left
ƒƒ  $
;
ƒƒ$ %
}
≈≈ 
}
∆∆ 
else
«« 
if
«« 
(
«« 
compareResult
«« "
>
««# $
$num
««% &
)
««& '
{
»» 
if
…… 
(
…… 
node
…… 
.
…… 
Right
…… 
is
…… !
null
……" &
)
……& '
{
   
newNode
ÀÀ 
=
ÀÀ 
new
ÀÀ !
RedBlackTreeNode
ÀÀ" 2
<
ÀÀ2 3
TKey
ÀÀ3 7
>
ÀÀ7 8
(
ÀÀ8 9
key
ÀÀ9 <
,
ÀÀ< =
node
ÀÀ> B
)
ÀÀB C
;
ÀÀC D
node
ÃÃ 
.
ÃÃ 
Right
ÃÃ 
=
ÃÃ  
newNode
ÃÃ! (
;
ÃÃ( )
break
ÕÕ 
;
ÕÕ 
}
ŒŒ 
else
œœ 
{
–– 
node
—— 
=
—— 
node
—— 
.
——  
Right
——  %
;
——% &
}
““ 
}
”” 
else
‘‘ 
{
’’ 
throw
÷÷ 
new
÷÷ 
ArgumentException
÷÷ +
(
÷÷+ ,
$"
÷÷, .
$str
÷÷. 4
{
÷÷4 5
key
÷÷5 8
}
÷÷8 9
$str
÷÷9 S
"
÷÷S T
)
÷÷T U
;
÷÷U V
}
◊◊ 
}
ÿÿ 	
return
⁄⁄ 
newNode
⁄⁄ 
;
⁄⁄ 
}
€€ 
private
‚‚ 
RedBlackTreeNode
‚‚ 
<
‚‚ 
TKey
‚‚ !
>
‚‚! "
?
‚‚" #
AddCase2
‚‚$ ,
(
‚‚, -
RedBlackTreeNode
‚‚- =
<
‚‚= >
TKey
‚‚> B
>
‚‚B C
node
‚‚D H
)
‚‚H I
{
„„ 
var
‰‰ 
grandparent
‰‰ 
=
‰‰ 
node
‰‰ 
.
‰‰ 
Parent
‰‰ %
;
‰‰% &
var
ÂÂ 
	parentDir
ÂÂ 
=
ÂÂ 
comparer
ÂÂ  
.
ÂÂ  !
Compare
ÂÂ! (
(
ÂÂ( )
node
ÂÂ) -
.
ÂÂ- .
Key
ÂÂ. 1
,
ÂÂ1 2
node
ÂÂ3 7
.
ÂÂ7 8
Parent
ÂÂ8 >
!
ÂÂ> ?
.
ÂÂ? @
Key
ÂÂ@ C
)
ÂÂC D
;
ÂÂD E
var
ÊÊ 
uncle
ÊÊ 
=
ÊÊ 
	parentDir
ÊÊ 
<
ÊÊ 
$num
ÊÊ  !
?
ÊÊ" #
grandparent
ÊÊ$ /
!
ÊÊ/ 0
.
ÊÊ0 1
Right
ÊÊ1 6
:
ÊÊ7 8
grandparent
ÊÊ9 D
!
ÊÊD E
.
ÊÊE F
Left
ÊÊF J
;
ÊÊJ K
node
ËË 
.
ËË 
Color
ËË 
=
ËË 
	NodeColor
ËË 
.
ËË 
Black
ËË $
;
ËË$ %
uncle
ÈÈ 
!
ÈÈ 
.
ÈÈ 
Color
ÈÈ 
=
ÈÈ 
	NodeColor
ÈÈ  
.
ÈÈ  !
Black
ÈÈ! &
;
ÈÈ& '
grandparent
ÍÍ 
.
ÍÍ 
Color
ÍÍ 
=
ÍÍ 
	NodeColor
ÍÍ %
.
ÍÍ% &
Red
ÍÍ& )
;
ÍÍ) *
if
ÌÌ 

(
ÌÌ 
node
ÌÌ 
.
ÌÌ 
Parent
ÌÌ 
.
ÌÌ 
Parent
ÌÌ 
is
ÌÌ !
null
ÌÌ" &
)
ÌÌ& '
{
ÓÓ 	
node
ÔÔ 
.
ÔÔ 
Parent
ÔÔ 
.
ÔÔ 
Color
ÔÔ 
=
ÔÔ 
	NodeColor
ÔÔ  )
.
ÔÔ) *
Black
ÔÔ* /
;
ÔÔ/ 0
}
 	
return
ÛÛ 
node
ÛÛ 
.
ÛÛ 
Parent
ÛÛ 
.
ÛÛ 
Parent
ÛÛ !
;
ÛÛ! "
}
ÙÙ 
private
¸¸ 
void
¸¸ 
	AddCase56
¸¸ 
(
¸¸ 
RedBlackTreeNode
¸¸ +
<
¸¸+ ,
TKey
¸¸, 0
>
¸¸0 1
node
¸¸2 6
,
¸¸6 7
int
¸¸8 ;
	parentDir
¸¸< E
,
¸¸E F
int
¸¸G J
childDir
¸¸K S
)
¸¸S T
{
˝˝ 
if
˛˛ 

(
˛˛ 
	parentDir
˛˛ 
<
˛˛ 
$num
˛˛ 
)
˛˛ 
{
ˇˇ 	
if
ÅÅ 
(
ÅÅ 
childDir
ÅÅ 
>
ÅÅ 
$num
ÅÅ 
)
ÅÅ 
{
ÇÇ 
node
ÉÉ 
=
ÉÉ 

RotateLeft
ÉÉ !
(
ÉÉ! "
node
ÉÉ" &
)
ÉÉ& '
;
ÉÉ' (
}
ÑÑ 
node
áá 
=
áá 
RotateRight
áá 
(
áá 
node
áá #
.
áá# $
Parent
áá$ *
!
áá* +
)
áá+ ,
;
áá, -
node
àà 
.
àà 
Color
àà 
=
àà 
	NodeColor
àà "
.
àà" #
Black
àà# (
;
àà( )
node
ââ 
.
ââ 
Right
ââ 
!
ââ 
.
ââ 
Color
ââ 
=
ââ 
	NodeColor
ââ  )
.
ââ) *
Red
ââ* -
;
ââ- .
}
ää 	
else
ãã 
{
åå 	
if
éé 
(
éé 
childDir
éé 
<
éé 
$num
éé 
)
éé 
{
èè 
node
êê 
=
êê 
RotateRight
êê "
(
êê" #
node
êê# '
)
êê' (
;
êê( )
}
ëë 
node
îî 
=
îî 

RotateLeft
îî 
(
îî 
node
îî "
.
îî" #
Parent
îî# )
!
îî) *
)
îî* +
;
îî+ ,
node
ïï 
.
ïï 
Color
ïï 
=
ïï 
	NodeColor
ïï "
.
ïï" #
Black
ïï# (
;
ïï( )
node
ññ 
.
ññ 
Left
ññ 
!
ññ 
.
ññ 
Color
ññ 
=
ññ 
	NodeColor
ññ (
.
ññ( )
Red
ññ) ,
;
ññ, -
}
óó 	
}
òò 
private
üü 
int
üü 

GetAddCase
üü 
(
üü 
RedBlackTreeNode
üü +
<
üü+ ,
TKey
üü, 0
>
üü0 1
node
üü2 6
)
üü6 7
{
†† 
if
°° 

(
°° 
node
°° 
.
°° 
Color
°° 
==
°° 
	NodeColor
°° #
.
°°# $
Black
°°$ )
)
°°) *
{
¢¢ 	
return
££ 
$num
££ 
;
££ 
}
§§ 	
else
•• 
if
•• 
(
•• 
node
•• 
.
•• 
Parent
•• 
is
•• 
null
••  $
)
••$ %
{
¶¶ 	
return
ßß 
$num
ßß 
;
ßß 
}
®® 	
else
©© 
{
™™ 	
var
¨¨ 
grandparent
¨¨ 
=
¨¨ 
node
¨¨ "
.
¨¨" #
Parent
¨¨# )
;
¨¨) *
var
≠≠ 
	parentDir
≠≠ 
=
≠≠ 
comparer
≠≠ $
.
≠≠$ %
Compare
≠≠% ,
(
≠≠, -
node
≠≠- 1
.
≠≠1 2
Key
≠≠2 5
,
≠≠5 6
node
≠≠7 ;
.
≠≠; <
Parent
≠≠< B
.
≠≠B C
Key
≠≠C F
)
≠≠F G
;
≠≠G H
var
ÆÆ 
uncle
ÆÆ 
=
ÆÆ 
	parentDir
ÆÆ !
<
ÆÆ" #
$num
ÆÆ$ %
?
ÆÆ& '
grandparent
ÆÆ( 3
.
ÆÆ3 4
Right
ÆÆ4 9
:
ÆÆ: ;
grandparent
ÆÆ< G
.
ÆÆG H
Left
ÆÆH L
;
ÆÆL M
if
±± 
(
±± 
uncle
±± 
is
±± 
null
±± 
||
±±  
uncle
±±! &
.
±±& '
Color
±±' ,
==
±±- /
	NodeColor
±±0 9
.
±±9 :
Black
±±: ?
)
±±? @
{
≤≤ 
return
≥≥ 
$num
≥≥ 
;
≥≥ 
}
¥¥ 
return
∂∂ 
$num
∂∂ 
;
∂∂ 
}
∑∑ 	
}
∏∏ 
private
¿¿ 
RedBlackTreeNode
¿¿ 
<
¿¿ 
TKey
¿¿ !
>
¿¿! "
Remove
¿¿# )
(
¿¿) *
RedBlackTreeNode
¿¿* :
<
¿¿: ;
TKey
¿¿; ?
>
¿¿? @
?
¿¿@ A
node
¿¿B F
,
¿¿F G
TKey
¿¿H L
key
¿¿M P
)
¿¿P Q
{
¡¡ 
if
¬¬ 

(
¬¬ 
node
¬¬ 
is
¬¬ 
null
¬¬ 
)
¬¬ 
{
√√ 	
throw
ƒƒ 
new
ƒƒ '
InvalidOperationException
ƒƒ /
(
ƒƒ/ 0
$str
ƒƒ0 @
)
ƒƒ@ A
;
ƒƒA B
}
≈≈ 	
else
∆∆ 
if
∆∆ 
(
∆∆ 
!
∆∆ 
Contains
∆∆ 
(
∆∆ 
key
∆∆ 
)
∆∆ 
)
∆∆  
{
«« 	
throw
»» 
new
»» "
KeyNotFoundException
»» *
(
»»* +
$"
»»+ -
$str
»»- 1
{
»»1 2
key
»»2 5
}
»»5 6
$str
»»6 J
"
»»J K
)
»»K L
;
»»L M
}
…… 	
else
   
{
ÀÀ 	
int
ÕÕ 
dir
ÕÕ 
;
ÕÕ 
while
ŒŒ 
(
ŒŒ 
true
ŒŒ 
)
ŒŒ 
{
œœ 
dir
–– 
=
–– 
comparer
–– 
.
–– 
Compare
–– &
(
––& '
key
––' *
,
––* +
node
––, 0
!
––0 1
.
––1 2
Key
––2 5
)
––5 6
;
––6 7
if
—— 
(
—— 
dir
—— 
<
—— 
$num
—— 
)
—— 
{
““ 
node
”” 
=
”” 
node
”” 
.
””  
Left
””  $
;
””$ %
}
‘‘ 
else
’’ 
if
’’ 
(
’’ 
dir
’’ 
>
’’ 
$num
’’  
)
’’  !
{
÷÷ 
node
◊◊ 
=
◊◊ 
node
◊◊ 
.
◊◊  
Right
◊◊  %
;
◊◊% &
}
ÿÿ 
else
ŸŸ 
{
⁄⁄ 
break
€€ 
;
€€ 
}
‹‹ 
}
›› 
return
ﬂﬂ 
node
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 	
}
·· 
private
ÁÁ 
RedBlackTreeNode
ÁÁ 
<
ÁÁ 
TKey
ÁÁ !
>
ÁÁ! "
?
ÁÁ" #
RemoveRecolor
ÁÁ$ 1
(
ÁÁ1 2
RedBlackTreeNode
ÁÁ2 B
<
ÁÁB C
TKey
ÁÁC G
>
ÁÁG H
node
ÁÁI M
)
ÁÁM N
{
ËË 
var
ÈÈ 

removeCase
ÈÈ 
=
ÈÈ 
GetRemoveCase
ÈÈ &
(
ÈÈ& '
node
ÈÈ' +
)
ÈÈ+ ,
;
ÈÈ, -
var
ÎÎ 
dir
ÎÎ 
=
ÎÎ 
comparer
ÎÎ 
.
ÎÎ 
Compare
ÎÎ "
(
ÎÎ" #
node
ÎÎ# '
.
ÎÎ' (
Key
ÎÎ( +
,
ÎÎ+ ,
node
ÎÎ- 1
.
ÎÎ1 2
Parent
ÎÎ2 8
!
ÎÎ8 9
.
ÎÎ9 :
Key
ÎÎ: =
)
ÎÎ= >
;
ÎÎ> ?
var
ÓÓ 
sibling
ÓÓ 
=
ÓÓ 
dir
ÓÓ 
<
ÓÓ 
$num
ÓÓ 
?
ÓÓ 
node
ÓÓ  $
.
ÓÓ$ %
Parent
ÓÓ% +
.
ÓÓ+ ,
Right
ÓÓ, 1
:
ÓÓ2 3
node
ÓÓ4 8
.
ÓÓ8 9
Parent
ÓÓ9 ?
.
ÓÓ? @
Left
ÓÓ@ D
;
ÓÓD E
var
ÔÔ 
closeNewphew
ÔÔ 
=
ÔÔ 
dir
ÔÔ 
<
ÔÔ  
$num
ÔÔ! "
?
ÔÔ# $
sibling
ÔÔ% ,
!
ÔÔ, -
.
ÔÔ- .
Left
ÔÔ. 2
:
ÔÔ3 4
sibling
ÔÔ5 <
!
ÔÔ< =
.
ÔÔ= >
Right
ÔÔ> C
;
ÔÔC D
var
 
distantNephew
 
=
 
dir
 
<
  !
$num
" #
?
$ %
sibling
& -
!
- .
.
. /
Right
/ 4
:
5 6
sibling
7 >
!
> ?
.
? @
Left
@ D
;
D E
switch
ÚÚ 
(
ÚÚ 

removeCase
ÚÚ 
)
ÚÚ 
{
ÛÛ 	
case
ÙÙ 
$num
ÙÙ 
:
ÙÙ 
sibling
ıı 
.
ıı 
Color
ıı 
=
ıı 
	NodeColor
ıı  )
.
ıı) *
Red
ıı* -
;
ıı- .
return
ˆˆ 
node
ˆˆ 
.
ˆˆ 
Parent
ˆˆ "
;
ˆˆ" #
case
˜˜ 
$num
˜˜ 
:
˜˜ 
RemoveCase3
¯¯ 
(
¯¯ 
node
¯¯  
,
¯¯  !
closeNewphew
¯¯" .
,
¯¯. /
dir
¯¯0 3
)
¯¯3 4
;
¯¯4 5
break
˘˘ 
;
˘˘ 
case
˙˙ 
$num
˙˙ 
:
˙˙ 
RemoveCase4
˚˚ 
(
˚˚ 
sibling
˚˚ #
)
˚˚# $
;
˚˚$ %
break
¸¸ 
;
¸¸ 
case
˝˝ 
$num
˝˝ 
:
˝˝ 
RemoveCase5
˛˛ 
(
˛˛ 
node
˛˛  
,
˛˛  !
sibling
˛˛" )
,
˛˛) *
dir
˛˛+ .
)
˛˛. /
;
˛˛/ 0
break
ˇˇ 
;
ˇˇ 
case
ÄÄ 
$num
ÄÄ 
:
ÄÄ 
RemoveCase6
ÅÅ 
(
ÅÅ 
node
ÅÅ  
,
ÅÅ  !
distantNephew
ÅÅ" /
!
ÅÅ/ 0
,
ÅÅ0 1
dir
ÅÅ2 5
)
ÅÅ5 6
;
ÅÅ6 7
break
ÇÇ 
;
ÇÇ 
default
ÉÉ 
:
ÉÉ 
throw
ÑÑ 
new
ÑÑ '
InvalidOperationException
ÑÑ 3
(
ÑÑ3 4
$str
ÑÑ4 \
)
ÑÑ\ ]
;
ÑÑ] ^
}
ÖÖ 	
return
áá 
null
áá 
;
áá 
}
àà 
private
èè 
RedBlackTreeNode
èè 
<
èè 
TKey
èè !
>
èè! "
?
èè" #
RemoveSimpleCases
èè$ 5
(
èè5 6
RedBlackTreeNode
èè6 F
<
èèF G
TKey
èèG K
>
èèK L
node
èèM Q
)
èèQ R
{
êê 
if
íí 

(
íí 
node
íí 
.
íí 
Parent
íí 
is
íí 
null
íí 
&&
íí  "
node
íí# '
.
íí' (
Left
íí( ,
is
íí- /
null
íí0 4
&&
íí5 7
node
íí8 <
.
íí< =
Right
íí= B
is
ííC E
null
ííF J
)
ííJ K
{
ìì 	
root
îî 
=
îî 
null
îî 
;
îî 
Count
ïï 
--
ïï 
;
ïï 
return
ññ 
null
ññ 
;
ññ 
}
óó 	
if
öö 

(
öö 
node
öö 
.
öö 
Left
öö 
is
öö 
not
öö 
null
öö !
&&
öö" $
node
öö% )
.
öö) *
Right
öö* /
is
öö0 2
not
öö3 6
null
öö7 ;
)
öö; <
{
õõ 	
var
úú 
	successor
úú 
=
úú 
GetMin
úú "
(
úú" #
node
úú# '
.
úú' (
Right
úú( -
)
úú- .
;
úú. /
node
ùù 
.
ùù 
Key
ùù 
=
ùù 
	successor
ùù  
.
ùù  !
Key
ùù! $
;
ùù$ %
node
ûû 
=
ûû 
	successor
ûû 
;
ûû 
}
üü 	
if
¢¢ 

(
¢¢ 
node
¢¢ 
.
¢¢ 
Color
¢¢ 
==
¢¢ 
	NodeColor
¢¢ #
.
¢¢# $
Red
¢¢$ '
)
¢¢' (
{
££ 	

DeleteLeaf
•• 
(
•• 
node
•• 
.
•• 
Parent
•• "
!
••" #
,
••# $
comparer
••% -
.
••- .
Compare
••. 5
(
••5 6
node
••6 :
.
••: ;
Key
••; >
,
••> ?
node
••@ D
.
••D E
Parent
••E K
!
••K L
.
••L M
Key
••M P
)
••P Q
)
••Q R
;
••R S
Count
ßß 
--
ßß 
;
ßß 
return
®® 
null
®® 
;
®® 
}
©© 	
else
™™ 
{
´´ 	
return
≠≠ 
RemoveBlackNode
≠≠ "
(
≠≠" #
node
≠≠# '
)
≠≠' (
;
≠≠( )
}
ÆÆ 	
}
ØØ 
private
∂∂ 
RedBlackTreeNode
∂∂ 
<
∂∂ 
TKey
∂∂ !
>
∂∂! "
?
∂∂" #
RemoveBlackNode
∂∂$ 3
(
∂∂3 4
RedBlackTreeNode
∂∂4 D
<
∂∂D E
TKey
∂∂E I
>
∂∂I J
node
∂∂K O
)
∂∂O P
{
∑∑ 
var
ππ 
child
ππ 
=
ππ 
node
ππ 
.
ππ 
Left
ππ 
??
ππ  
node
ππ! %
.
ππ% &
Right
ππ& +
;
ππ+ ,
if
ºº 

(
ºº 
child
ºº 
is
ºº 
null
ºº 
)
ºº 
{
ΩΩ 	
return
ææ 
node
ææ 
;
ææ 
}
øø 	
child
¬¬ 
.
¬¬ 
Color
¬¬ 
=
¬¬ 
	NodeColor
¬¬ 
.
¬¬  
Black
¬¬  %
;
¬¬% &
child
√√ 
.
√√ 
Parent
√√ 
=
√√ 
node
√√ 
.
√√ 
Parent
√√ "
;
√√" #
var
≈≈ 
childDir
≈≈ 
=
≈≈ 
node
≈≈ 
.
≈≈ 
Parent
≈≈ "
is
≈≈# %
null
≈≈& *
?
≈≈+ ,
$num
≈≈- .
:
≈≈/ 0
comparer
≈≈1 9
.
≈≈9 :
Compare
≈≈: A
(
≈≈A B
node
≈≈B F
.
≈≈F G
Key
≈≈G J
,
≈≈J K
node
≈≈L P
.
≈≈P Q
Parent
≈≈Q W
.
≈≈W X
Key
≈≈X [
)
≈≈[ \
;
≈≈\ ]

Transplant
»» 
(
»» 
node
»» 
.
»» 
Parent
»» 
,
»» 
child
»»  %
,
»»% &
childDir
»»' /
)
»»/ 0
;
»»0 1
Count
   
--
   
;
   
return
ÀÀ 
null
ÀÀ 
;
ÀÀ 
}
ÃÃ 
private
‘‘ 
void
‘‘ 
RemoveCase3
‘‘ 
(
‘‘ 
RedBlackTreeNode
‘‘ -
<
‘‘- .
TKey
‘‘. 2
>
‘‘2 3
node
‘‘4 8
,
‘‘8 9
RedBlackTreeNode
‘‘: J
<
‘‘J K
TKey
‘‘K O
>
‘‘O P
?
‘‘P Q
closeNephew
‘‘R ]
,
‘‘] ^
int
‘‘_ b
childDir
‘‘c k
)
‘‘k l
{
’’ 
var
◊◊ 
sibling
◊◊ 
=
◊◊ 
childDir
◊◊ 
<
◊◊  
$num
◊◊! "
?
◊◊# $

RotateLeft
◊◊% /
(
◊◊/ 0
node
◊◊0 4
.
◊◊4 5
Parent
◊◊5 ;
!
◊◊; <
)
◊◊< =
:
◊◊> ?
RotateRight
◊◊@ K
(
◊◊K L
node
◊◊L P
.
◊◊P Q
Parent
◊◊Q W
!
◊◊W X
)
◊◊X Y
;
◊◊Y Z
sibling
ÿÿ 
.
ÿÿ 
Color
ÿÿ 
=
ÿÿ 
	NodeColor
ÿÿ !
.
ÿÿ! "
Black
ÿÿ" '
;
ÿÿ' (
if
ŸŸ 

(
ŸŸ 
childDir
ŸŸ 
<
ŸŸ 
$num
ŸŸ 
)
ŸŸ 
{
⁄⁄ 	
sibling
€€ 
.
€€ 
Left
€€ 
!
€€ 
.
€€ 
Color
€€ 
=
€€  !
	NodeColor
€€" +
.
€€+ ,
Red
€€, /
;
€€/ 0
}
‹‹ 	
else
›› 
{
ﬁﬁ 	
sibling
ﬂﬂ 
.
ﬂﬂ 
Right
ﬂﬂ 
!
ﬂﬂ 
.
ﬂﬂ 
Color
ﬂﬂ  
=
ﬂﬂ! "
	NodeColor
ﬂﬂ# ,
.
ﬂﬂ, -
Red
ﬂﬂ- 0
;
ﬂﬂ0 1
}
‡‡ 	
sibling
„„ 
=
„„ 
closeNephew
„„ 
!
„„ 
;
„„ 
var
‰‰ 
distantNephew
‰‰ 
=
‰‰ 
childDir
‰‰ $
<
‰‰% &
$num
‰‰' (
?
‰‰) *
sibling
‰‰+ 2
.
‰‰2 3
Right
‰‰3 8
:
‰‰9 :
sibling
‰‰; B
.
‰‰B C
Left
‰‰C G
;
‰‰G H
if
ÁÁ 

(
ÁÁ 
distantNephew
ÁÁ 
is
ÁÁ 
not
ÁÁ  
null
ÁÁ! %
&&
ÁÁ& (
distantNephew
ÁÁ) 6
.
ÁÁ6 7
Color
ÁÁ7 <
==
ÁÁ= ?
	NodeColor
ÁÁ@ I
.
ÁÁI J
Red
ÁÁJ M
)
ÁÁM N
{
ËË 	
RemoveCase6
ÈÈ 
(
ÈÈ 
node
ÈÈ 
,
ÈÈ 
distantNephew
ÈÈ +
,
ÈÈ+ ,
childDir
ÈÈ- 5
)
ÈÈ5 6
;
ÈÈ6 7
return
ÍÍ 
;
ÍÍ 
}
ÎÎ 	
closeNephew
ÓÓ 
=
ÓÓ 
childDir
ÓÓ 
<
ÓÓ  
$num
ÓÓ! "
?
ÓÓ# $
sibling
ÓÓ% ,
!
ÓÓ, -
.
ÓÓ- .
Left
ÓÓ. 2
:
ÓÓ3 4
sibling
ÓÓ5 <
!
ÓÓ< =
.
ÓÓ= >
Right
ÓÓ> C
;
ÓÓC D
if
ÒÒ 

(
ÒÒ 
closeNephew
ÒÒ 
is
ÒÒ 
not
ÒÒ 
null
ÒÒ #
&&
ÒÒ$ &
closeNephew
ÒÒ' 2
.
ÒÒ2 3
Color
ÒÒ3 8
==
ÒÒ9 ;
	NodeColor
ÒÒ< E
.
ÒÒE F
Red
ÒÒF I
)
ÒÒI J
{
ÚÚ 	
RemoveCase5
ÛÛ 
(
ÛÛ 
node
ÛÛ 
,
ÛÛ 
sibling
ÛÛ %
!
ÛÛ% &
,
ÛÛ& '
childDir
ÛÛ( 0
)
ÛÛ0 1
;
ÛÛ1 2
return
ÙÙ 
;
ÙÙ 
}
ıı 	
RemoveCase4
¯¯ 
(
¯¯ 
sibling
¯¯ 
!
¯¯ 
)
¯¯ 
;
¯¯ 
}
˘˘ 
private
ˇˇ 
void
ˇˇ 
RemoveCase4
ˇˇ 
(
ˇˇ 
RedBlackTreeNode
ˇˇ -
<
ˇˇ- .
TKey
ˇˇ. 2
>
ˇˇ2 3
sibling
ˇˇ4 ;
)
ˇˇ; <
{
ÄÄ 
sibling
ÅÅ 
.
ÅÅ 
Color
ÅÅ 
=
ÅÅ 
	NodeColor
ÅÅ !
.
ÅÅ! "
Red
ÅÅ" %
;
ÅÅ% &
sibling
ÇÇ 
.
ÇÇ 
Parent
ÇÇ 
!
ÇÇ 
.
ÇÇ 
Color
ÇÇ 
=
ÇÇ 
	NodeColor
ÇÇ  )
.
ÇÇ) *
Black
ÇÇ* /
;
ÇÇ/ 0
}
ÉÉ 
private
ãã 
void
ãã 
RemoveCase5
ãã 
(
ãã 
RedBlackTreeNode
ãã -
<
ãã- .
TKey
ãã. 2
>
ãã2 3
node
ãã4 8
,
ãã8 9
RedBlackTreeNode
ãã: J
<
ããJ K
TKey
ããK O
>
ããO P
sibling
ããQ X
,
ããX Y
int
ããZ ]
childDir
ãã^ f
)
ããf g
{
åå 
sibling
çç 
=
çç 
childDir
çç 
<
çç 
$num
çç 
?
çç  
RotateRight
çç! ,
(
çç, -
sibling
çç- 4
)
çç4 5
:
çç6 7

RotateLeft
çç8 B
(
ççB C
sibling
ççC J
)
ççJ K
;
ççK L
var
éé 
distantNephew
éé 
=
éé 
childDir
éé $
<
éé% &
$num
éé' (
?
éé) *
sibling
éé+ 2
.
éé2 3
Right
éé3 8
!
éé8 9
:
éé: ;
sibling
éé< C
.
ééC D
Left
ééD H
!
ééH I
;
ééI J
sibling
êê 
.
êê 
Color
êê 
=
êê 
	NodeColor
êê !
.
êê! "
Black
êê" '
;
êê' (
distantNephew
ëë 
.
ëë 
Color
ëë 
=
ëë 
	NodeColor
ëë '
.
ëë' (
Red
ëë( +
;
ëë+ ,
RemoveCase6
ìì 
(
ìì 
node
ìì 
,
ìì 
distantNephew
ìì '
,
ìì' (
childDir
ìì) 1
)
ìì1 2
;
ìì2 3
}
îî 
private
úú 
void
úú 
RemoveCase6
úú 
(
úú 
RedBlackTreeNode
úú -
<
úú- .
TKey
úú. 2
>
úú2 3
node
úú4 8
,
úú8 9
RedBlackTreeNode
úú: J
<
úúJ K
TKey
úúK O
>
úúO P
distantNephew
úúQ ^
,
úú^ _
int
úú` c
childDir
úúd l
)
úúl m
{
ùù 
var
ûû 
	oldParent
ûû 
=
ûû 
node
ûû 
.
ûû 
Parent
ûû #
!
ûû# $
;
ûû$ %
node
üü 
=
üü 
childDir
üü 
<
üü 
$num
üü 
?
üü 

RotateLeft
üü (
(
üü( )
	oldParent
üü) 2
)
üü2 3
:
üü4 5
RotateRight
üü6 A
(
üüA B
	oldParent
üüB K
)
üüK L
;
üüL M
node
†† 
.
†† 
Color
†† 
=
†† 
	oldParent
†† 
.
†† 
Color
†† $
;
††$ %
	oldParent
°° 
.
°° 
Color
°° 
=
°° 
	NodeColor
°° #
.
°°# $
Black
°°$ )
;
°°) *
distantNephew
¢¢ 
.
¢¢ 
Color
¢¢ 
=
¢¢ 
	NodeColor
¢¢ '
.
¢¢' (
Black
¢¢( -
;
¢¢- .
}
££ 
private
™™ 
int
™™ 
GetRemoveCase
™™ 
(
™™ 
RedBlackTreeNode
™™ .
<
™™. /
TKey
™™/ 3
>
™™3 4
node
™™5 9
)
™™9 :
{
´´ 
var
¨¨ 
dir
¨¨ 
=
¨¨ 
comparer
¨¨ 
.
¨¨ 
Compare
¨¨ "
(
¨¨" #
node
¨¨# '
.
¨¨' (
Key
¨¨( +
,
¨¨+ ,
node
¨¨- 1
.
¨¨1 2
Parent
¨¨2 8
!
¨¨8 9
.
¨¨9 :
Key
¨¨: =
)
¨¨= >
;
¨¨> ?
var
ØØ 
sibling
ØØ 
=
ØØ 
dir
ØØ 
<
ØØ 
$num
ØØ 
?
ØØ 
node
ØØ  $
.
ØØ$ %
Parent
ØØ% +
.
ØØ+ ,
Right
ØØ, 1
:
ØØ2 3
node
ØØ4 8
.
ØØ8 9
Parent
ØØ9 ?
.
ØØ? @
Left
ØØ@ D
;
ØØD E
var
∞∞ 
closeNewphew
∞∞ 
=
∞∞ 
dir
∞∞ 
<
∞∞  
$num
∞∞! "
?
∞∞# $
sibling
∞∞% ,
!
∞∞, -
.
∞∞- .
Left
∞∞. 2
:
∞∞3 4
sibling
∞∞5 <
!
∞∞< =
.
∞∞= >
Right
∞∞> C
;
∞∞C D
var
±± 
distantNephew
±± 
=
±± 
dir
±± 
<
±±  !
$num
±±" #
?
±±$ %
sibling
±±& -
!
±±- .
.
±±. /
Right
±±/ 4
:
±±5 6
sibling
±±7 >
!
±±> ?
.
±±? @
Left
±±@ D
;
±±D E
if
≥≥ 

(
≥≥ 
sibling
≥≥ 
.
≥≥ 
Color
≥≥ 
==
≥≥ 
	NodeColor
≥≥ &
.
≥≥& '
Red
≥≥' *
)
≥≥* +
{
¥¥ 	
return
µµ 
$num
µµ 
;
µµ 
}
∂∂ 	
else
∑∑ 
if
∑∑ 
(
∑∑ 
distantNephew
∑∑ 
is
∑∑ !
not
∑∑" %
null
∑∑& *
&&
∑∑+ -
distantNephew
∑∑. ;
.
∑∑; <
Color
∑∑< A
==
∑∑B D
	NodeColor
∑∑E N
.
∑∑N O
Red
∑∑O R
)
∑∑R S
{
∏∏ 	
return
ππ 
$num
ππ 
;
ππ 
}
∫∫ 	
else
ªª 
if
ªª 
(
ªª 
closeNewphew
ªª 
is
ªª  
not
ªª! $
null
ªª% )
&&
ªª* ,
closeNewphew
ªª- 9
.
ªª9 :
Color
ªª: ?
==
ªª@ B
	NodeColor
ªªC L
.
ªªL M
Red
ªªM P
)
ªªP Q
{
ºº 	
return
ΩΩ 
$num
ΩΩ 
;
ΩΩ 
}
ææ 	
else
øø 
if
øø 
(
øø 
node
øø 
.
øø 
Parent
øø 
.
øø 
Color
øø "
==
øø# %
	NodeColor
øø& /
.
øø/ 0
Red
øø0 3
)
øø3 4
{
¿¿ 	
return
¡¡ 
$num
¡¡ 
;
¡¡ 
}
¬¬ 	
else
√√ 
{
ƒƒ 	
return
≈≈ 
$num
≈≈ 
;
≈≈ 
}
∆∆ 	
}
«« 
private
œœ 
void
œœ 

Transplant
œœ 
(
œœ 
RedBlackTreeNode
œœ ,
<
œœ, -
TKey
œœ- 1
>
œœ1 2
?
œœ2 3
node
œœ4 8
,
œœ8 9
RedBlackTreeNode
œœ: J
<
œœJ K
TKey
œœK O
>
œœO P
?
œœP Q
child
œœR W
,
œœW X
int
œœY \
dir
œœ] `
)
œœ` a
{
–– 
if
—— 

(
—— 
node
—— 
is
—— 
null
—— 
)
—— 
{
““ 	
root
”” 
=
”” 
child
”” 
;
”” 
}
‘‘ 	
else
’’ 
if
’’ 
(
’’ 
child
’’ 
is
’’ 
null
’’ 
)
’’ 
{
÷÷ 	

DeleteLeaf
◊◊ 
(
◊◊ 
node
◊◊ 
,
◊◊ 
dir
◊◊  
)
◊◊  !
;
◊◊! "
}
ÿÿ 	
else
ŸŸ 
if
ŸŸ 
(
ŸŸ 
dir
ŸŸ 
<
ŸŸ 
$num
ŸŸ 
)
ŸŸ 
{
⁄⁄ 	
node
€€ 
.
€€ 
Left
€€ 
=
€€ 
child
€€ 
;
€€ 
}
‹‹ 	
else
›› 
{
ﬁﬁ 	
node
ﬂﬂ 
.
ﬂﬂ 
Right
ﬂﬂ 
=
ﬂﬂ 
child
ﬂﬂ 
;
ﬂﬂ 
}
‡‡ 	
}
·· 
private
ËË 
void
ËË 

DeleteLeaf
ËË 
(
ËË 
RedBlackTreeNode
ËË ,
<
ËË, -
TKey
ËË- 1
>
ËË1 2
node
ËË3 7
,
ËË7 8
int
ËË9 <
dir
ËË= @
)
ËË@ A
{
ÈÈ 
if
ÍÍ 

(
ÍÍ 
dir
ÍÍ 
<
ÍÍ 
$num
ÍÍ 
)
ÍÍ 
{
ÎÎ 	
node
ÏÏ 
.
ÏÏ 
Left
ÏÏ 
=
ÏÏ 
null
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
else
ÓÓ 
{
ÔÔ 	
node
 
.
 
Right
 
=
 
null
 
;
 
}
ÒÒ 	
}
ÚÚ 
private
˘˘ 
RedBlackTreeNode
˘˘ 
<
˘˘ 
TKey
˘˘ !
>
˘˘! "

RotateLeft
˘˘# -
(
˘˘- .
RedBlackTreeNode
˘˘. >
<
˘˘> ?
TKey
˘˘? C
>
˘˘C D
node
˘˘E I
)
˘˘I J
{
˙˙ 
var
˚˚ 
temp1
˚˚ 
=
˚˚ 
node
˚˚ 
;
˚˚ 
var
¸¸ 
temp2
¸¸ 
=
¸¸ 
node
¸¸ 
!
¸¸ 
.
¸¸ 
Right
¸¸ 
!
¸¸  
.
¸¸  !
Left
¸¸! %
;
¸¸% &
node
˛˛ 
=
˛˛ 
node
˛˛ 
.
˛˛ 
Right
˛˛ 
;
˛˛ 
node
ˇˇ 
.
ˇˇ 
Parent
ˇˇ 
=
ˇˇ 
temp1
ˇˇ 
.
ˇˇ 
Parent
ˇˇ "
;
ˇˇ" #
if
ÄÄ 

(
ÄÄ 
node
ÄÄ 
.
ÄÄ 
Parent
ÄÄ 
is
ÄÄ 
not
ÄÄ 
null
ÄÄ #
)
ÄÄ# $
{
ÅÅ 	
var
ÇÇ 
nodeDir
ÇÇ 
=
ÇÇ 
comparer
ÇÇ "
.
ÇÇ" #
Compare
ÇÇ# *
(
ÇÇ* +
node
ÇÇ+ /
.
ÇÇ/ 0
Key
ÇÇ0 3
,
ÇÇ3 4
node
ÇÇ5 9
.
ÇÇ9 :
Parent
ÇÇ: @
.
ÇÇ@ A
Key
ÇÇA D
)
ÇÇD E
;
ÇÇE F
if
ÉÉ 
(
ÉÉ 
nodeDir
ÉÉ 
<
ÉÉ 
$num
ÉÉ 
)
ÉÉ 
{
ÑÑ 
node
ÖÖ 
.
ÖÖ 
Parent
ÖÖ 
.
ÖÖ 
Left
ÖÖ  
=
ÖÖ! "
node
ÖÖ# '
;
ÖÖ' (
}
ÜÜ 
else
áá 
{
àà 
node
ââ 
.
ââ 
Parent
ââ 
.
ââ 
Right
ââ !
=
ââ" #
node
ââ$ (
;
ââ( )
}
ää 
}
ãã 	
node
çç 
.
çç 
Left
çç 
=
çç 
temp1
çç 
;
çç 
node
éé 
.
éé 
Left
éé 
.
éé 
Parent
éé 
=
éé 
node
éé 
;
éé  
node
êê 
.
êê 
Left
êê 
.
êê 
Right
êê 
=
êê 
temp2
êê 
;
êê  
if
ëë 

(
ëë 
temp2
ëë 
is
ëë 
not
ëë 
null
ëë 
)
ëë 
{
íí 	
node
ìì 
.
ìì 
Left
ìì 
.
ìì 
Right
ìì 
!
ìì 
.
ìì 
Parent
ìì #
=
ìì$ %
temp1
ìì& +
;
ìì+ ,
}
îî 	
if
ññ 

(
ññ 
node
ññ 
.
ññ 
Parent
ññ 
is
ññ 
null
ññ 
)
ññ  
{
óó 	
root
òò 
=
òò 
node
òò 
;
òò 
}
ôô 	
return
õõ 
node
õõ 
;
õõ 
}
úú 
private
££ 
RedBlackTreeNode
££ 
<
££ 
TKey
££ !
>
££! "
RotateRight
££# .
(
££. /
RedBlackTreeNode
££/ ?
<
££? @
TKey
££@ D
>
££D E
node
££F J
)
££J K
{
§§ 
var
•• 
temp1
•• 
=
•• 
node
•• 
;
•• 
var
¶¶ 
temp2
¶¶ 
=
¶¶ 
node
¶¶ 
!
¶¶ 
.
¶¶ 
Left
¶¶ 
!
¶¶ 
.
¶¶  
Right
¶¶  %
;
¶¶% &
node
®® 
=
®® 
node
®® 
.
®® 
Left
®® 
;
®® 
node
©© 
.
©© 
Parent
©© 
=
©© 
temp1
©© 
.
©© 
Parent
©© "
;
©©" #
if
™™ 

(
™™ 
node
™™ 
.
™™ 
Parent
™™ 
is
™™ 
not
™™ 
null
™™ #
)
™™# $
{
´´ 	
var
¨¨ 
nodeDir
¨¨ 
=
¨¨ 
comparer
¨¨ "
.
¨¨" #
Compare
¨¨# *
(
¨¨* +
node
¨¨+ /
.
¨¨/ 0
Key
¨¨0 3
,
¨¨3 4
node
¨¨5 9
.
¨¨9 :
Parent
¨¨: @
.
¨¨@ A
Key
¨¨A D
)
¨¨D E
;
¨¨E F
if
≠≠ 
(
≠≠ 
nodeDir
≠≠ 
<
≠≠ 
$num
≠≠ 
)
≠≠ 
{
ÆÆ 
node
ØØ 
.
ØØ 
Parent
ØØ 
.
ØØ 
Left
ØØ  
=
ØØ! "
node
ØØ# '
;
ØØ' (
}
∞∞ 
else
±± 
{
≤≤ 
node
≥≥ 
.
≥≥ 
Parent
≥≥ 
.
≥≥ 
Right
≥≥ !
=
≥≥" #
node
≥≥$ (
;
≥≥( )
}
¥¥ 
}
µµ 	
node
∑∑ 
.
∑∑ 
Right
∑∑ 
=
∑∑ 
temp1
∑∑ 
;
∑∑ 
node
∏∏ 
.
∏∏ 
Right
∏∏ 
.
∏∏ 
Parent
∏∏ 
=
∏∏ 
node
∏∏  
;
∏∏  !
node
∫∫ 
.
∫∫ 
Right
∫∫ 
.
∫∫ 
Left
∫∫ 
=
∫∫ 
temp2
∫∫ 
;
∫∫  
if
ªª 

(
ªª 
temp2
ªª 
is
ªª 
not
ªª 
null
ªª 
)
ªª 
{
ºº 	
node
ΩΩ 
.
ΩΩ 
Right
ΩΩ 
.
ΩΩ 
Left
ΩΩ 
!
ΩΩ 
.
ΩΩ 
Parent
ΩΩ #
=
ΩΩ$ %
temp1
ΩΩ& +
;
ΩΩ+ ,
}
ææ 	
if
¿¿ 

(
¿¿ 
node
¿¿ 
.
¿¿ 
Parent
¿¿ 
is
¿¿ 
null
¿¿ 
)
¿¿  
{
¡¡ 	
root
¬¬ 
=
¬¬ 
node
¬¬ 
;
¬¬ 
}
√√ 	
return
≈≈ 
node
≈≈ 
;
≈≈ 
}
∆∆ 
private
ŒŒ 
RedBlackTreeNode
ŒŒ 
<
ŒŒ 
TKey
ŒŒ !
>
ŒŒ! "
GetMin
ŒŒ# )
(
ŒŒ) *
RedBlackTreeNode
ŒŒ* :
<
ŒŒ: ;
TKey
ŒŒ; ?
>
ŒŒ? @
node
ŒŒA E
)
ŒŒE F
{
œœ 
while
–– 
(
–– 
node
–– 
.
–– 
Left
–– 
is
–– 
not
–– 
null
––  $
)
––$ %
{
—— 	
node
““ 
=
““ 
node
““ 
.
““ 
Left
““ 
;
““ 
}
”” 	
return
’’ 
node
’’ 
;
’’ 
}
÷÷ 
private
ﬁﬁ 
RedBlackTreeNode
ﬁﬁ 
<
ﬁﬁ 
TKey
ﬁﬁ !
>
ﬁﬁ! "
GetMax
ﬁﬁ# )
(
ﬁﬁ) *
RedBlackTreeNode
ﬁﬁ* :
<
ﬁﬁ: ;
TKey
ﬁﬁ; ?
>
ﬁﬁ? @
node
ﬁﬁA E
)
ﬁﬁE F
{
ﬂﬂ 
while
‡‡ 
(
‡‡ 
node
‡‡ 
.
‡‡ 
Right
‡‡ 
is
‡‡ 
not
‡‡  
null
‡‡! %
)
‡‡% &
{
·· 	
node
‚‚ 
=
‚‚ 
node
‚‚ 
.
‚‚ 
Right
‚‚ 
;
‚‚ 
}
„„ 	
return
ÂÂ 
node
ÂÂ 
;
ÂÂ 
}
ÊÊ 
}ÁÁ úó
uC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\Heap\FibonacciHeap\FibonacciHeap.cs
	namespace 	
DataStructures
 
. 
Heap 
. 
FibonacciHeap +
;+ ,
public 
class 
FibonacciHeap 
< 
T 
> 
where #
T$ %
:& '
IComparable( 3
{   
public$$ 

int$$ 
Count$$ 
{$$ 
get$$ 
;$$ 
set$$ 
;$$  
}$$! "
private++ 
	FHeapNode++ 
<++ 
T++ 
>++ 
?++ 
MinItem++ !
{++" #
get++$ '
;++' (
set++) ,
;++, -
}++. /
public;; 

	FHeapNode;; 
<;; 
T;; 
>;; 
Push;; 
(;; 
T;; 
x;;  
);;  !
{<< 
Count== 
++== 
;== 
var?? 
newItem?? 
=?? 
new?? 
	FHeapNode?? #
<??# $
T??$ %
>??% &
(??& '
x??' (
)??( )
;??) *
ifAA 

(AA 
MinItemAA 
==AA 
nullAA 
)AA 
{BB 	
MinItemCC 
=CC 
newItemCC 
;CC 
}DD 	
elseEE 
{FF 	
MinItemGG 
.GG 
AddRightGG 
(GG 
newItemGG $
)GG$ %
;GG% &
ifII 
(II 
newItemII 
.II 
KeyII 
.II 
	CompareToII %
(II% &
MinItemII& -
.II- .
KeyII. 1
)II1 2
<II3 4
$numII5 6
)II6 7
{JJ 
MinItemKK 
=KK 
newItemKK !
;KK! "
}LL 
}MM 	
returnOO 
newItemOO 
;OO 
}PP 
publiccc 

voidcc 
Unioncc 
(cc 
FibonacciHeapcc #
<cc# $
Tcc$ %
>cc% &
othercc' ,
)cc, -
{dd 
ifff 

(ff 
otherff 
.ff 
MinItemff 
==ff 
nullff !
)ff! "
{gg 	
returnhh 
;hh 
}ii 	
ifll 

(ll 
MinItemll 
==ll 
nullll 
)ll 
{mm 	
MinItemoo 
=oo 
otheroo 
.oo 
MinItemoo #
;oo# $
Countpp 
=pp 
otherpp 
.pp 
Countpp 
;pp  
otherss 
.ss 
MinItemss 
=ss 
nullss  
;ss  !
othertt 
.tt 
Counttt 
=tt 
$numtt 
;tt 
returnvv 
;vv 
}ww 	
Countyy 
+=yy 
otheryy 
.yy 
Countyy 
;yy 
MinItem|| 
.|| 
ConcatenateRight||  
(||  !
other||! &
.||& '
MinItem||' .
)||. /
;||/ 0
if 

( 
other 
. 
MinItem 
. 
Key 
. 
	CompareTo '
(' (
MinItem( /
./ 0
Key0 3
)3 4
<5 6
$num7 8
)8 9
{
ÄÄ 	
MinItem
ÅÅ 
=
ÅÅ 
other
ÅÅ 
.
ÅÅ 
MinItem
ÅÅ #
;
ÅÅ# $
}
ÇÇ 	
other
ÑÑ 
.
ÑÑ 
MinItem
ÑÑ 
=
ÑÑ 
null
ÑÑ 
;
ÑÑ 
other
ÖÖ 
.
ÖÖ 
Count
ÖÖ 
=
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
}
ÜÜ 
public
ûû 

T
ûû 
Pop
ûû 
(
ûû 
)
ûû 
{
üü 
	FHeapNode
†† 
<
†† 
T
†† 
>
†† 
?
†† 
z
†† 
=
†† 
null
†† 
;
†† 
if
°° 

(
°° 
MinItem
°° 
==
°° 
null
°° 
)
°° 
{
¢¢ 	
throw
££ 
new
££ '
InvalidOperationException
££ /
(
££/ 0
$str
££0 @
)
££@ A
;
££A B
}
§§ 	
z
¶¶ 	
=
¶¶
 
MinItem
¶¶ 
;
¶¶ 
if
©© 

(
©© 
z
©© 
.
©© 
Child
©© 
!=
©© 
null
©© 
)
©© 
{
™™ 	
foreach
´´ 
(
´´ 
var
´´ 
x
´´ 
in
´´ 
SiblingIterator
´´ -
(
´´- .
z
´´. /
.
´´/ 0
Child
´´0 5
)
´´5 6
)
´´6 7
{
¨¨ 
x
≠≠ 
.
≠≠ 
Parent
≠≠ 
=
≠≠ 
null
≠≠ 
;
≠≠  
}
ÆÆ 
z
±± 
.
±± 
ConcatenateRight
±± 
(
±± 
z
±±  
.
±±  !
Child
±±! &
)
±±& '
;
±±' (
}
≤≤ 	
if
¥¥ 

(
¥¥ 
Count
¥¥ 
==
¥¥ 
$num
¥¥ 
)
¥¥ 
{
µµ 	
MinItem
∂∂ 
=
∂∂ 
null
∂∂ 
;
∂∂ 
Count
∑∑ 
=
∑∑ 
$num
∑∑ 
;
∑∑ 
return
∏∏ 
z
∏∏ 
.
∏∏ 
Key
∏∏ 
;
∏∏ 
}
ππ 	
MinItem
ΩΩ 
=
ΩΩ 
MinItem
ΩΩ 
.
ΩΩ 
Right
ΩΩ 
;
ΩΩ  
z
¿¿ 	
.
¿¿	 

Remove
¿¿
 
(
¿¿ 
)
¿¿ 
;
¿¿ 
Consolidate
√√ 
(
√√ 
)
√√ 
;
√√ 
Count
≈≈ 
-=
≈≈ 
$num
≈≈ 
;
≈≈ 
return
«« 
z
«« 
.
«« 
Key
«« 
;
«« 
}
»» 
public
—— 

T
—— 
Peek
—— 
(
—— 
)
—— 
{
““ 
if
”” 

(
”” 
MinItem
”” 
==
”” 
null
”” 
)
”” 
{
‘‘ 	
throw
’’ 
new
’’ '
InvalidOperationException
’’ /
(
’’/ 0
$str
’’0 C
)
’’C D
;
’’D E
}
÷÷ 	
return
ÿÿ 
MinItem
ÿÿ 
.
ÿÿ 
Key
ÿÿ 
;
ÿÿ 
}
ŸŸ 
public
„„ 

void
„„ 
DecreaseKey
„„ 
(
„„ 
	FHeapNode
„„ %
<
„„% &
T
„„& '
>
„„' (
x
„„) *
,
„„* +
T
„„, -
k
„„. /
)
„„/ 0
{
‰‰ 
if
ÂÂ 

(
ÂÂ 
MinItem
ÂÂ 
==
ÂÂ 
null
ÂÂ 
)
ÂÂ 
{
ÊÊ 	
throw
ÁÁ 
new
ÁÁ 
ArgumentException
ÁÁ '
(
ÁÁ' (
$"
ÁÁ( *
{
ÁÁ* +
nameof
ÁÁ+ 1
(
ÁÁ1 2
x
ÁÁ2 3
)
ÁÁ3 4
}
ÁÁ4 5
$str
ÁÁ5 J
"
ÁÁJ K
)
ÁÁK L
;
ÁÁL M
}
ËË 	
if
ÍÍ 

(
ÍÍ 
x
ÍÍ 
.
ÍÍ 
Key
ÍÍ 
==
ÍÍ 
null
ÍÍ 
)
ÍÍ 
{
ÎÎ 	
throw
ÏÏ 
new
ÏÏ 
ArgumentException
ÏÏ '
(
ÏÏ' (
$str
ÏÏ( 8
)
ÏÏ8 9
;
ÏÏ9 :
}
ÌÌ 	
if
ÔÔ 

(
ÔÔ 
k
ÔÔ 
.
ÔÔ 
	CompareTo
ÔÔ 
(
ÔÔ 
x
ÔÔ 
.
ÔÔ 
Key
ÔÔ 
)
ÔÔ 
>
ÔÔ  
$num
ÔÔ! "
)
ÔÔ" #
{
 	
throw
ÒÒ 
new
ÒÒ '
InvalidOperationException
ÒÒ /
(
ÒÒ/ 0
$str
ÒÒ0 K
)
ÒÒK L
;
ÒÒL M
}
ÚÚ 	
x
ÙÙ 	
.
ÙÙ	 

Key
ÙÙ
 
=
ÙÙ 
k
ÙÙ 
;
ÙÙ 
var
ıı 
y
ıı 
=
ıı 
x
ıı 
.
ıı 
Parent
ıı 
;
ıı 
if
ˆˆ 

(
ˆˆ 
y
ˆˆ 
!=
ˆˆ 
null
ˆˆ 
&&
ˆˆ 
x
ˆˆ 
.
ˆˆ 
Key
ˆˆ 
.
ˆˆ 
	CompareTo
ˆˆ (
(
ˆˆ( )
y
ˆˆ) *
.
ˆˆ* +
Key
ˆˆ+ .
)
ˆˆ. /
<
ˆˆ0 1
$num
ˆˆ2 3
)
ˆˆ3 4
{
˜˜ 	
Cut
¯¯ 
(
¯¯ 
x
¯¯ 
,
¯¯ 
y
¯¯ 
)
¯¯ 
;
¯¯ 
CascadingCut
˘˘ 
(
˘˘ 
y
˘˘ 
)
˘˘ 
;
˘˘ 
}
˙˙ 	
if
¸¸ 

(
¸¸ 
x
¸¸ 
.
¸¸ 
Key
¸¸ 
.
¸¸ 
	CompareTo
¸¸ 
(
¸¸ 
MinItem
¸¸ #
.
¸¸# $
Key
¸¸$ '
)
¸¸' (
<
¸¸) *
$num
¸¸+ ,
)
¸¸, -
{
˝˝ 	
MinItem
˛˛ 
=
˛˛ 
x
˛˛ 
;
˛˛ 
}
ˇˇ 	
}
ÄÄ 
	protected
áá 
void
áá 
Cut
áá 
(
áá 
	FHeapNode
áá  
<
áá  !
T
áá! "
>
áá" #
x
áá$ %
,
áá% &
	FHeapNode
áá' 0
<
áá0 1
T
áá1 2
>
áá2 3
y
áá4 5
)
áá5 6
{
àà 
if
ââ 

(
ââ 
MinItem
ââ 
==
ââ 
null
ââ 
)
ââ 
{
ää 	
throw
ãã 
new
ãã '
InvalidOperationException
ãã /
(
ãã/ 0
$str
ãã0 @
)
ãã@ A
;
ããA B
}
åå 	
if
éé 

(
éé 
y
éé 
.
éé 
Degree
éé 
==
éé 
$num
éé 
)
éé 
{
èè 	
y
êê 
.
êê 
Child
êê 
=
êê 
null
êê 
;
êê 
MinItem
ëë 
.
ëë 
AddRight
ëë 
(
ëë 
x
ëë 
)
ëë 
;
ëë  
}
íí 	
else
ìì 
if
ìì 
(
ìì 
y
ìì 
.
ìì 
Degree
ìì 
>
ìì 
$num
ìì 
)
ìì 
{
îî 	
x
ïï 
.
ïï 
Remove
ïï 
(
ïï 
)
ïï 
;
ïï 
}
ññ 	
else
óó 
{
òò 	
throw
ôô 
new
ôô '
InvalidOperationException
ôô /
(
ôô/ 0
$str
ôô0 @
)
ôô@ A
;
ôôA B
}
öö 	
y
úú 	
.
úú	 

Degree
úú
 
--
úú 
;
úú 
x
ùù 	
.
ùù	 

Mark
ùù
 
=
ùù 
false
ùù 
;
ùù 
x
ûû 	
.
ûû	 

Parent
ûû
 
=
ûû 
null
ûû 
;
ûû 
}
üü 
	protected
•• 
void
•• 
CascadingCut
•• 
(
••  
	FHeapNode
••  )
<
••) *
T
••* +
>
••+ ,
y
••- .
)
••. /
{
¶¶ 
var
ßß 
z
ßß 
=
ßß 
y
ßß 
.
ßß 
Parent
ßß 
;
ßß 
if
®® 

(
®® 
z
®® 
!=
®® 
null
®® 
)
®® 
{
©© 	
if
™™ 
(
™™ 
!
™™ 
y
™™ 
.
™™ 
Mark
™™ 
)
™™ 
{
´´ 
y
¨¨ 
.
¨¨ 
Mark
¨¨ 
=
¨¨ 
true
¨¨ 
;
¨¨ 
}
≠≠ 
else
ÆÆ 
{
ØØ 
Cut
∞∞ 
(
∞∞ 
y
∞∞ 
,
∞∞ 
z
∞∞ 
)
∞∞ 
;
∞∞ 
CascadingCut
±± 
(
±± 
z
±± 
)
±± 
;
±±  
}
≤≤ 
}
≥≥ 	
}
¥¥ 
	protected
œœ 
void
œœ 
Consolidate
œœ 
(
œœ 
)
œœ  
{
–– 
if
—— 

(
—— 
MinItem
—— 
==
—— 
null
—— 
)
—— 
{
““ 	
return
”” 
;
”” 
}
‘‘ 	
var
‹‹ 
	maxDegree
‹‹ 
=
‹‹ 
$num
‹‹ 
+
‹‹ 
(
‹‹ 
int
‹‹  
)
‹‹  !
Math
‹‹! %
.
‹‹% &
Log
‹‹& )
(
‹‹) *
Count
‹‹* /
,
‹‹/ 0
(
‹‹1 2
$num
‹‹2 3
+
‹‹4 5
Math
‹‹6 :
.
‹‹: ;
Sqrt
‹‹; ?
(
‹‹? @
$num
‹‹@ A
)
‹‹A B
)
‹‹B C
/
‹‹D E
$num
‹‹F G
)
‹‹G H
;
‹‹H I
var
ﬂﬂ 
a
ﬂﬂ 
=
ﬂﬂ 
new
ﬂﬂ 
	FHeapNode
ﬂﬂ 
<
ﬂﬂ 
T
ﬂﬂ 
>
ﬂﬂ  
?
ﬂﬂ  !
[
ﬂﬂ! "
	maxDegree
ﬂﬂ" +
]
ﬂﬂ+ ,
;
ﬂﬂ, -
var
‡‡ 
siblings
‡‡ 
=
‡‡ 
SiblingIterator
‡‡ &
(
‡‡& '
MinItem
‡‡' .
)
‡‡. /
.
‡‡/ 0
ToList
‡‡0 6
(
‡‡6 7
)
‡‡7 8
;
‡‡8 9
foreach
·· 
(
·· 
var
·· 
w
·· 
in
·· 
siblings
·· "
)
··" #
{
‚‚ 	
var
„„ 
x
„„ 
=
„„ 
w
„„ 
;
„„ 
var
‰‰ 
d
‰‰ 
=
‰‰ 
x
‰‰ 
.
‰‰ 
Degree
‰‰ 
;
‰‰ 
var
ÊÊ 
y
ÊÊ 
=
ÊÊ 
a
ÊÊ 
[
ÊÊ 
d
ÊÊ 
]
ÊÊ 
;
ÊÊ 
while
ÈÈ 
(
ÈÈ 
y
ÈÈ 
!=
ÈÈ 
null
ÈÈ 
)
ÈÈ 
{
ÍÍ 
if
ÎÎ 
(
ÎÎ 
x
ÎÎ 
.
ÎÎ 
Key
ÎÎ 
.
ÎÎ 
	CompareTo
ÎÎ #
(
ÎÎ# $
y
ÎÎ$ %
.
ÎÎ% &
Key
ÎÎ& )
)
ÎÎ) *
>
ÎÎ+ ,
$num
ÎÎ- .
)
ÎÎ. /
{
ÏÏ 
var
ÓÓ 
temp
ÓÓ 
=
ÓÓ 
x
ÓÓ  
;
ÓÓ  !
x
ÔÔ 
=
ÔÔ 
y
ÔÔ 
;
ÔÔ 
y
 
=
 
temp
 
;
 
}
ÒÒ 
FibHeapLink
ÙÙ 
(
ÙÙ 
y
ÙÙ 
,
ÙÙ 
x
ÙÙ  
)
ÙÙ  !
;
ÙÙ! "
a
˜˜ 
[
˜˜ 
d
˜˜ 
]
˜˜ 
=
˜˜ 
null
˜˜ 
;
˜˜ 
d
˙˙ 
++
˙˙ 
;
˙˙ 
y
¸¸ 
=
¸¸ 
a
¸¸ 
[
¸¸ 
d
¸¸ 
]
¸¸ 
;
¸¸ 
}
˝˝ 
a
ÄÄ 
[
ÄÄ 
d
ÄÄ 
]
ÄÄ 
=
ÄÄ 
x
ÄÄ 
;
ÄÄ 
}
ÅÅ 	
ReconstructHeap
ÉÉ 
(
ÉÉ 
a
ÉÉ 
)
ÉÉ 
;
ÉÉ 
}
ÑÑ 
private
ää 
void
ää 
ReconstructHeap
ää  
(
ää  !
	FHeapNode
ää! *
<
ää* +
T
ää+ ,
>
ää, -
?
ää- .
[
ää. /
]
ää/ 0
a
ää1 2
)
ää2 3
{
ãã 
MinItem
çç 
=
çç 
null
çç 
;
çç 
for
èè 
(
èè 
var
èè 
i
èè 
=
èè 
$num
èè 
;
èè 
i
èè 
<
èè 
a
èè 
.
èè 
Length
èè $
;
èè$ %
i
èè& '
++
èè' )
)
èè) *
{
êê 	
var
ëë 
r
ëë 
=
ëë 
a
ëë 
[
ëë 
i
ëë 
]
ëë 
;
ëë 
if
íí 
(
íí 
r
íí 
==
íí 
null
íí 
)
íí 
{
ìì 
continue
îî 
;
îî 
}
ïï 
if
óó 
(
óó 
MinItem
óó 
==
óó 
null
óó 
)
óó  
{
òò 
MinItem
õõ 
=
õõ 
r
õõ 
;
õõ 
MinItem
üü 
.
üü 
SetSiblings
üü #
(
üü# $
MinItem
üü$ +
,
üü+ ,
MinItem
üü- 4
)
üü4 5
;
üü5 6
MinItem
†† 
.
†† 
Parent
†† 
=
††  
null
††! %
;
††% &
}
°° 
else
¢¢ 
{
££ 
MinItem
•• 
.
•• 
AddRight
••  
(
••  !
r
••! "
)
••" #
;
••# $
if
®® 
(
®® 
MinItem
®® 
.
®® 
Key
®® 
.
®®  
	CompareTo
®®  )
(
®®) *
r
®®* +
.
®®+ ,
Key
®®, /
)
®®/ 0
>
®®1 2
$num
®®3 4
)
®®4 5
{
©© 
MinItem
™™ 
=
™™ 
a
™™ 
[
™™  
i
™™  !
]
™™! "
;
™™" #
}
´´ 
}
¨¨ 
}
≠≠ 	
}
ÆÆ 
private
µµ 
void
µµ 
FibHeapLink
µµ 
(
µµ 
	FHeapNode
µµ &
<
µµ& '
T
µµ' (
>
µµ( )
y
µµ* +
,
µµ+ ,
	FHeapNode
µµ- 6
<
µµ6 7
T
µµ7 8
>
µµ8 9
x
µµ: ;
)
µµ; <
{
∂∂ 
y
∑∑ 	
.
∑∑	 

Remove
∑∑
 
(
∑∑ 
)
∑∑ 
;
∑∑ 
x
∏∏ 	
.
∏∏	 

AddChild
∏∏
 
(
∏∏ 
y
∏∏ 
)
∏∏ 
;
∏∏ 
y
ππ 	
.
ππ	 

Mark
ππ
 
=
ππ 
false
ππ 
;
ππ 
}
∫∫ 
private
¬¬ 
IEnumerable
¬¬ 
<
¬¬ 
	FHeapNode
¬¬ !
<
¬¬! "
T
¬¬" #
>
¬¬# $
>
¬¬$ %
SiblingIterator
¬¬& 5
(
¬¬5 6
	FHeapNode
¬¬6 ?
<
¬¬? @
T
¬¬@ A
>
¬¬A B
node
¬¬C G
)
¬¬G H
{
√√ 
var
ƒƒ 
currentNode
ƒƒ 
=
ƒƒ 
node
ƒƒ 
;
ƒƒ 
yield
≈≈ 
return
≈≈ 
currentNode
≈≈  
;
≈≈  !
currentNode
«« 
=
«« 
node
«« 
.
«« 
Right
««  
;
««  !
while
»» 
(
»» 
currentNode
»» 
!=
»» 
node
»» "
)
»»" #
{
…… 	
yield
   
return
   
currentNode
   $
;
  $ %
currentNode
ÀÀ 
=
ÀÀ 
currentNode
ÀÀ %
.
ÀÀ% &
Right
ÀÀ& +
;
ÀÀ+ ,
}
ÃÃ 	
}
ÕÕ 
}ŒŒ º'
qC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\Heap\FibonacciHeap\FHeapNode.cs
	namespace 	
DataStructures
 
. 
Heap 
. 
FibonacciHeap +
;+ ,
public 
class 
	FHeapNode 
< 
T 
> 
where 
T  !
:" #
IComparable$ /
{ 
public 

	FHeapNode 
( 
T 
key 
) 
{ 
Key 
= 
key 
; 
Left 
= 
Right 
= 
this 
; 
Parent 
= 
Child 
= 
null 
; 
} 
public 

T 
Key 
{ 
get 
; 
set 
; 
} 
public## 

	FHeapNode## 
<## 
T## 
>## 
?## 
Parent## 
{##  !
get##" %
;##% &
set##' *
;##* +
}##, -
public(( 

	FHeapNode(( 
<(( 
T(( 
>(( 
Left(( 
{(( 
get(( "
;((" #
set(($ '
;((' (
}(() *
public-- 

	FHeapNode-- 
<-- 
T-- 
>-- 
Right-- 
{-- 
get--  #
;--# $
set--% (
;--( )
}--* +
public44 

	FHeapNode44 
<44 
T44 
>44 
?44 
Child44 
{44  
get44! $
;44$ %
set44& )
;44) *
}44+ ,
public:: 

bool:: 
Mark:: 
{:: 
get:: 
;:: 
set:: 
;::  
}::! "
public?? 

int?? 
Degree?? 
{?? 
get?? 
;?? 
set??  
;??  !
}??" #
publicAA 

voidAA 
SetSiblingsAA 
(AA 
	FHeapNodeAA %
<AA% &
TAA& '
>AA' (
leftAA) -
,AA- .
	FHeapNodeAA/ 8
<AA8 9
TAA9 :
>AA: ;
rightAA< A
)AAA B
{BB 
LeftCC 
=CC 
leftCC 
;CC 
RightDD 
=DD 
rightDD 
;DD 
}EE 
publicLL 

voidLL 
AddRightLL 
(LL 
	FHeapNodeLL "
<LL" #
TLL# $
>LL$ %
nodeLL& *
)LL* +
{MM 
RightNN 
.NN 
LeftNN 
=NN 
nodeNN 
;NN 
nodeOO 
.OO 
RightOO 
=OO 
RightOO 
;OO 
nodePP 
.PP 
LeftPP 
=PP 
thisPP 
;PP 
RightQQ 
=QQ 
nodeQQ 
;QQ 
}RR 
publicXX 

voidXX 
AddChildXX 
(XX 
	FHeapNodeXX "
<XX" #
TXX# $
>XX$ %
nodeXX& *
)XX* +
{YY 
DegreeZZ 
++ZZ 
;ZZ 
if\\ 

(\\ 
Child\\ 
==\\ 
null\\ 
)\\ 
{]] 	
Child^^ 
=^^ 
node^^ 
;^^ 
Child__ 
.__ 
Parent__ 
=__ 
this__ 
;__  
Child`` 
.`` 
Left`` 
=`` 
Child`` 
.`` 
Right`` $
=``% &
Child``' ,
;``, -
returnbb 
;bb 
}cc 	
Childee 
.ee 
AddRightee 
(ee 
nodeee 
)ee 
;ee 
}ff 
publickk 

voidkk 
Removekk 
(kk 
)kk 
{ll 
Leftmm 
.mm 
Rightmm 
=mm 
Rightmm 
;mm 
Rightnn 
.nn 
Leftnn 
=nn 
Leftnn 
;nn 
}oo 
public{{ 

void{{ 
ConcatenateRight{{  
({{  !
	FHeapNode{{! *
<{{* +
T{{+ ,
>{{, -
	otherList{{. 7
){{7 8
{|| 
Right}} 
.}} 
Left}} 
=}} 
	otherList}} 
.}} 
Left}} #
;}}# $
	otherList~~ 
.~~ 
Left~~ 
.~~ 
Right~~ 
=~~ 
Right~~ $
;~~$ %
Right
ÄÄ 
=
ÄÄ 
	otherList
ÄÄ 
;
ÄÄ 
	otherList
ÅÅ 
.
ÅÅ 
Left
ÅÅ 
=
ÅÅ 
this
ÅÅ 
;
ÅÅ 
}
ÇÇ 
}ÉÉ Ñ
aC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\Graph\Vertex.cs
	namespace 	
DataStructures
 
. 
Graph 
; 
public 
class 
Vertex 
< 
T 
> 
{ 
public 

T 
Data 
{ 
get 
; 
} 
public 

int 
Index 
{ 
get 
; 
internal $
set% (
;( )
}* +
public 
!
DirectedWeightedGraph  
<  !
T! "
>" #
?# $
Graph% *
{+ ,
get- 0
;0 1
private2 9
set: =
;= >
}? @
public 

Vertex 
( 
T 
data 
, 
int 
index #
,# $!
DirectedWeightedGraph% :
<: ;
T; <
>< =
?= >
graph? D
)D E
{ 
Data   
=   
data   
;   
Index!! 
=!! 
index!! 
;!! 
Graph"" 
="" 
graph"" 
;"" 
}## 
public** 

Vertex** 
(** 
T** 
data** 
,** 
int** 
index** #
)**# $
{++ 
Data,, 
=,, 
data,, 
;,, 
Index-- 
=-- 
index-- 
;-- 
}.. 
public33 

void33 
SetGraphNull33 
(33 
)33 
=>33 !
Graph33" '
=33( )
null33* .
;33. /
public99 

override99 
string99 
ToString99 #
(99# $
)99$ %
=>99& (
$"99) +
$str99+ 8
{998 9
Data999 =
}99= >
$str99> G
{99G H
Index99H M
}99M N
"99N O
;99O P
}:: °
qC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\Graph\IDirectedWeightedGraph.cs
	namespace 	
DataStructures
 
. 
Graph 
; 
public 
	interface "
IDirectedWeightedGraph '
<' (
T( )
>) *
{ 
int 
Count 
{ 
get 
; 
} 
Vertex		 

<		
 
T		 
>		 
?		 
[		 
]		 
Vertices		 
{		 
get		 
;		  
}		! "
void 
AddEdge	 
( 
Vertex 
< 
T 
> 
startVertex &
,& '
Vertex( .
<. /
T/ 0
>0 1
	endVertex2 ;
,; <
double= C
weightD J
)J K
;K L
Vertex 

<
 
T 
> 
	AddVertex 
( 
T 
data 
) 
;  
bool 
AreAdjacent	 
( 
Vertex 
< 
T 
> 
startVertex *
,* +
Vertex, 2
<2 3
T3 4
>4 5
	endVertex6 ?
)? @
;@ A
double 

AdjacentDistance 
( 
Vertex "
<" #
T# $
>$ %
startVertex& 1
,1 2
Vertex3 9
<9 :
T: ;
>; <
	endVertex= F
)F G
;G H
IEnumerable 
< 
Vertex 
< 
T 
> 
? 
> 
GetNeighbors (
(( )
Vertex) /
</ 0
T0 1
>1 2
vertex3 9
)9 :
;: ;
void 

RemoveEdge	 
( 
Vertex 
< 
T 
> 
startVertex )
,) *
Vertex+ 1
<1 2
T2 3
>3 4
	endVertex5 >
)> ?
;? @
void 
RemoveVertex	 
( 
Vertex 
< 
T 
> 
vertex  &
)& '
;' (
} Üy
pC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\Graph\DirectedWeightedGraph.cs
	namespace 	
DataStructures
 
. 
Graph 
; 
public

 
class

 !
DirectedWeightedGraph

 "
<

" #
T

# $
>

$ %
:

& '"
IDirectedWeightedGraph

( >
<

> ?
T

? @
>

@ A
{ 
private 
readonly 
int 
capacity !
;! "
private 
readonly 
double 
[ 
, 
] 
adjacencyMatrix .
;. /
public 
!
DirectedWeightedGraph  
(  !
int! $
capacity% -
)- .
{ #
ThrowIfNegativeCapacity 
(  
capacity  (
)( )
;) *
this 
. 
capacity 
= 
capacity  
;  !
Vertices   
=   
new   
Vertex   
<   
T   
>    
[    !
capacity  ! )
]  ) *
;  * +
adjacencyMatrix!! 
=!! 
new!! 
double!! $
[!!$ %
capacity!!% -
,!!- .
capacity!!/ 7
]!!7 8
;!!8 9
Count"" 
="" 
$num"" 
;"" 
}## 
public(( 

Vertex(( 
<(( 
T(( 
>(( 
?(( 
[(( 
](( 
Vertices((  
{((! "
get((# &
;((& '
private((( /
set((0 3
;((3 4
}((5 6
public-- 

int-- 
Count-- 
{-- 
get-- 
;-- 
private-- #
set--$ '
;--' (
}--) *
public44 

Vertex44 
<44 
T44 
>44 
	AddVertex44 
(44 
T44  
data44! %
)44% &
{55 
ThrowIfOverflow66 
(66 
)66 
;66 
var77 
vertex77 
=77 
new77 
Vertex77 
<77  
T77  !
>77! "
(77" #
data77# '
,77' (
Count77) .
,77. /
this770 4
)774 5
;775 6
Vertices88 
[88 
Count88 
]88 
=88 
vertex88  
;88  !
Count99 
++99 
;99 
return:: 
vertex:: 
;:: 
};; 
publicCC 

voidCC 
AddEdgeCC 
(CC 
VertexCC 
<CC 
TCC  
>CC  !
startVertexCC" -
,CC- .
VertexCC/ 5
<CC5 6
TCC6 7
>CC7 8
	endVertexCC9 B
,CCB C
doubleCCD J
weightCCK Q
)CCQ R
{DD #
ThrowIfVertexNotInGraphEE 
(EE  
startVertexEE  +
)EE+ ,
;EE, -#
ThrowIfVertexNotInGraphFF 
(FF  
	endVertexFF  )
)FF) *
;FF* +
ThrowIfWeightZeroHH 
(HH 
weightHH  
)HH  !
;HH! "
varJJ 
currentEdgeWeightJJ 
=JJ 
adjacencyMatrixJJ  /
[JJ/ 0
startVertexJJ0 ;
.JJ; <
IndexJJ< A
,JJA B
	endVertexJJC L
.JJL M
IndexJJM R
]JJR S
;JJS T
ThrowIfEdgeExistsLL 
(LL 
currentEdgeWeightLL +
)LL+ ,
;LL, -
adjacencyMatrixNN 
[NN 
startVertexNN #
.NN# $
IndexNN$ )
,NN) *
	endVertexNN+ 4
.NN4 5
IndexNN5 :
]NN: ;
=NN< =
weightNN> D
;NND E
}OO 
publicUU 

voidUU 
RemoveVertexUU 
(UU 
VertexUU #
<UU# $
TUU$ %
>UU% &
vertexUU' -
)UU- .
{VV #
ThrowIfVertexNotInGraphWW 
(WW  
vertexWW  &
)WW& '
;WW' (
intYY 
indexToRemoveYY 
=YY 
vertexYY "
.YY" #
IndexYY# (
;YY( )
vertexZZ 
.ZZ 
IndexZZ 
=ZZ 
-ZZ 
$numZZ 
;ZZ 
vertex[[ 
.[[ 
SetGraphNull[[ 
([[ 
)[[ 
;[[ 
for^^ 
(^^ 
int^^ 
i^^ 
=^^ 
indexToRemove^^ "
;^^" #
i^^$ %
<^^& '
Count^^( -
-^^. /
$num^^0 1
;^^1 2
i^^3 4
++^^4 6
)^^6 7
{__ 	
Vertices`` 
[`` 
i`` 
]`` 
=`` 
Vertices`` "
[``" #
i``# $
+``% &
$num``' (
]``( )
;``) *
Verticesaa 
[aa 
iaa 
]aa 
!aa 
.aa 
Indexaa 
=aa  
iaa! "
;aa" #
}bb 	
Verticesdd 
[dd 
Countdd 
-dd 
$numdd 
]dd 
=dd 
nulldd "
;dd" #
forgg 
(gg 
intgg 
igg 
=gg 
$numgg 
;gg 
igg 
<gg 
Countgg !
;gg! "
igg# $
++gg$ &
)gg& '
{hh 	
forii 
(ii 
intii 
jii 
=ii 
$numii 
;ii 
jii 
<ii 
Countii  %
;ii% &
jii' (
++ii( *
)ii* +
{jj 
ifkk 
(kk 
ikk 
<kk 
indexToRemovekk %
&&kk& (
jkk) *
<kk+ ,
indexToRemovekk- :
)kk: ;
{ll 
continuemm 
;mm 
}nn 
elseoo 
ifoo 
(oo 
ioo 
<oo 
indexToRemoveoo *
&&oo+ -
joo. /
>=oo0 2
indexToRemoveoo3 @
&&ooA C
jooD E
<ooF G
CountooH M
-ooN O
$numooP Q
)ooQ R
{pp 
adjacencyMatrixqq #
[qq# $
iqq$ %
,qq% &
jqq' (
]qq( )
=qq* +
adjacencyMatrixqq, ;
[qq; <
iqq< =
,qq= >
jqq? @
+qqA B
$numqqC D
]qqD E
;qqE F
}rr 
elsess 
ifss 
(ss 
iss 
>=ss 
indexToRemovess +
&&ss, .
iss/ 0
<ss1 2
Countss3 8
-ss9 :
$numss; <
&&ss= ?
jss@ A
<ssB C
indexToRemovessD Q
)ssQ R
{tt 
adjacencyMatrixuu #
[uu# $
iuu$ %
,uu% &
juu' (
]uu( )
=uu* +
adjacencyMatrixuu, ;
[uu; <
iuu< =
+uu> ?
$numuu@ A
,uuA B
juuC D
]uuD E
;uuE F
}vv 
elseww 
ifww 
(ww 
iww 
>=ww 
indexToRemoveww +
&&ww, .
iww/ 0
<ww1 2
Countww3 8
-ww9 :
$numww; <
&&ww= ?
jww@ A
>=wwB D
indexToRemovewwE R
&&wwS U
jwwV W
<wwX Y
CountwwZ _
-ww` a
$numwwb c
)wwc d
{xx 
adjacencyMatrixyy #
[yy# $
iyy$ %
,yy% &
jyy' (
]yy( )
=yy* +
adjacencyMatrixyy, ;
[yy; <
iyy< =
+yy> ?
$numyy@ A
,yyA B
jyyC D
+yyE F
$numyyG H
]yyH I
;yyI J
}zz 
else{{ 
if{{ 
({{ 
i{{ 
=={{ 
Count{{ #
-{{$ %
$num{{& '
||{{( *
j{{+ ,
=={{- /
Count{{0 5
-{{6 7
$num{{8 9
){{9 :
{|| 
adjacencyMatrix}} #
[}}# $
i}}$ %
,}}% &
j}}' (
]}}( )
=}}* +
$num}}, -
;}}- .
}~~ 
else 
{
ÄÄ 
throw
ÅÅ 
new
ÅÅ '
InvalidOperationException
ÅÅ 7
(
ÅÅ7 8
)
ÅÅ8 9
;
ÅÅ9 :
}
ÇÇ 
}
ÉÉ 
}
ÑÑ 	
Count
ÜÜ 
--
ÜÜ 
;
ÜÜ 
}
áá 
public
éé 

void
éé 

RemoveEdge
éé 
(
éé 
Vertex
éé !
<
éé! "
T
éé" #
>
éé# $
startVertex
éé% 0
,
éé0 1
Vertex
éé2 8
<
éé8 9
T
éé9 :
>
éé: ;
	endVertex
éé< E
)
ééE F
{
èè %
ThrowIfVertexNotInGraph
êê 
(
êê  
startVertex
êê  +
)
êê+ ,
;
êê, -%
ThrowIfVertexNotInGraph
ëë 
(
ëë  
	endVertex
ëë  )
)
ëë) *
;
ëë* +
adjacencyMatrix
íí 
[
íí 
startVertex
íí #
.
íí# $
Index
íí$ )
,
íí) *
	endVertex
íí+ 4
.
íí4 5
Index
íí5 :
]
íí: ;
=
íí< =
$num
íí> ?
;
íí? @
}
ìì 
public
öö 

IEnumerable
öö 
<
öö 
Vertex
öö 
<
öö 
T
öö 
>
öö  
?
öö  !
>
öö! "
GetNeighbors
öö# /
(
öö/ 0
Vertex
öö0 6
<
öö6 7
T
öö7 8
>
öö8 9
vertex
öö: @
)
öö@ A
{
õõ %
ThrowIfVertexNotInGraph
úú 
(
úú  
vertex
úú  &
)
úú& '
;
úú' (
for
ûû 
(
ûû 
var
ûû 
i
ûû 
=
ûû 
$num
ûû 
;
ûû 
i
ûû 
<
ûû 
Count
ûû !
;
ûû! "
i
ûû# $
++
ûû$ &
)
ûû& '
{
üü 	
if
†† 
(
†† 
adjacencyMatrix
†† 
[
††  
vertex
††  &
.
††& '
Index
††' ,
,
††, -
i
††. /
]
††/ 0
!=
††1 3
$num
††4 5
)
††5 6
{
°° 
yield
¢¢ 
return
¢¢ 
Vertices
¢¢ %
[
¢¢% &
i
¢¢& '
]
¢¢' (
;
¢¢( )
}
££ 
}
§§ 	
}
•• 
public
≠≠ 

bool
≠≠ 
AreAdjacent
≠≠ 
(
≠≠ 
Vertex
≠≠ "
<
≠≠" #
T
≠≠# $
>
≠≠$ %
startVertex
≠≠& 1
,
≠≠1 2
Vertex
≠≠3 9
<
≠≠9 :
T
≠≠: ;
>
≠≠; <
	endVertex
≠≠= F
)
≠≠F G
{
ÆÆ %
ThrowIfVertexNotInGraph
ØØ 
(
ØØ  
startVertex
ØØ  +
)
ØØ+ ,
;
ØØ, -%
ThrowIfVertexNotInGraph
∞∞ 
(
∞∞  
	endVertex
∞∞  )
)
∞∞) *
;
∞∞* +
return
≤≤ 
adjacencyMatrix
≤≤ 
[
≤≤ 
startVertex
≤≤ *
.
≤≤* +
Index
≤≤+ 0
,
≤≤0 1
	endVertex
≤≤2 ;
.
≤≤; <
Index
≤≤< A
]
≤≤A B
!=
≤≤C E
$num
≤≤F G
;
≤≤G H
}
≥≥ 
public
ªª 

double
ªª 
AdjacentDistance
ªª "
(
ªª" #
Vertex
ªª# )
<
ªª) *
T
ªª* +
>
ªª+ ,
startVertex
ªª- 8
,
ªª8 9
Vertex
ªª: @
<
ªª@ A
T
ªªA B
>
ªªB C
	endVertex
ªªD M
)
ªªM N
{
ºº 
if
ΩΩ 

(
ΩΩ 
AreAdjacent
ΩΩ 
(
ΩΩ 
startVertex
ΩΩ #
,
ΩΩ# $
	endVertex
ΩΩ% .
)
ΩΩ. /
)
ΩΩ/ 0
{
ææ 	
return
øø 
adjacencyMatrix
øø "
[
øø" #
startVertex
øø# .
.
øø. /
Index
øø/ 4
,
øø4 5
	endVertex
øø6 ?
.
øø? @
Index
øø@ E
]
øøE F
;
øøF G
}
¿¿ 	
return
¬¬ 
$num
¬¬ 
;
¬¬ 
}
√√ 
private
≈≈ 
static
≈≈ 
void
≈≈ %
ThrowIfNegativeCapacity
≈≈ /
(
≈≈/ 0
int
≈≈0 3
capacity
≈≈4 <
)
≈≈< =
{
∆∆ 
if
«« 

(
«« 
capacity
«« 
<
«« 
$num
«« 
)
«« 
{
»» 	
throw
…… 
new
…… '
InvalidOperationException
…… /
(
……/ 0
$str
……0 i
)
……i j
;
……j k
}
   	
}
ÀÀ 
private
ÕÕ 
static
ÕÕ 
void
ÕÕ 
ThrowIfWeightZero
ÕÕ )
(
ÕÕ) *
double
ÕÕ* 0
weight
ÕÕ1 7
)
ÕÕ7 8
{
ŒŒ 
if
œœ 

(
œœ 
weight
œœ 
.
œœ 
Equals
œœ 
(
œœ 
$num
œœ 
)
œœ 
)
œœ  
{
–– 	
throw
—— 
new
—— '
InvalidOperationException
—— /
(
——/ 0
$str
——0 M
)
——M N
;
——N O
}
““ 	
}
”” 
private
’’ 
static
’’ 
void
’’ 
ThrowIfEdgeExists
’’ )
(
’’) *
double
’’* 0
currentEdgeWeight
’’1 B
)
’’B C
{
÷÷ 
if
◊◊ 

(
◊◊ 
!
◊◊ 
currentEdgeWeight
◊◊ 
.
◊◊ 
Equals
◊◊ %
(
◊◊% &
$num
◊◊& *
)
◊◊* +
)
◊◊+ ,
{
ÿÿ 	
throw
ŸŸ 
new
ŸŸ '
InvalidOperationException
ŸŸ /
(
ŸŸ/ 0
$"
ŸŸ0 2
$str
ŸŸ2 I
{
ŸŸI J
currentEdgeWeight
ŸŸJ [
}
ŸŸ[ \
"
ŸŸ\ ]
)
ŸŸ] ^
;
ŸŸ^ _
}
⁄⁄ 	
}
€€ 
private
›› 
void
›› 
ThrowIfOverflow
››  
(
››  !
)
››! "
{
ﬁﬁ 
if
ﬂﬂ 

(
ﬂﬂ 
Count
ﬂﬂ 
==
ﬂﬂ 
capacity
ﬂﬂ 
)
ﬂﬂ 
{
‡‡ 	
throw
·· 
new
·· '
InvalidOperationException
·· /
(
··/ 0
$str
··0 A
)
··A B
;
··B C
}
‚‚ 	
}
„„ 
private
ÂÂ 
void
ÂÂ %
ThrowIfVertexNotInGraph
ÂÂ (
(
ÂÂ( )
Vertex
ÂÂ) /
<
ÂÂ/ 0
T
ÂÂ0 1
>
ÂÂ1 2
vertex
ÂÂ3 9
)
ÂÂ9 :
{
ÊÊ 
if
ÁÁ 

(
ÁÁ 
vertex
ÁÁ 
.
ÁÁ 
Graph
ÁÁ 
!=
ÁÁ 
this
ÁÁ  
)
ÁÁ  !
{
ËË 	
throw
ÈÈ 
new
ÈÈ '
InvalidOperationException
ÈÈ /
(
ÈÈ/ 0
$"
ÈÈ0 2
$str
ÈÈ2 S
{
ÈÈS T
vertex
ÈÈT Z
}
ÈÈZ [
$str
ÈÈ[ \
"
ÈÈ\ ]
)
ÈÈ] ^
;
ÈÈ^ _
}
ÍÍ 	
}
ÎÎ 
}ÏÏ √
eC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\DisjointSet\Node.cs
	namespace 	
DataStructures
 
. 
DisjointSet $
;$ %
public 
class 
Node 
< 
T 
> 
{ 
public		 

int		 
Rank		 
{		 
get		 
;		 
set		 
;		 
}		  !
public 

Node 
< 
T 
> 
Parent 
{ 
get 
;  
set! $
;$ %
}& '
public 

T 
Data 
{ 
get 
; 
set 
; 
} 
public 

Node 
( 
T 
data 
) 
{ 
Data 
= 
data 
; 
Parent 
= 
this 
; 
} 
} Å	
zC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\BinarySearchTree\BinarySearchTreeNode.cs
	namespace 	
DataStructures
 
. 
BinarySearchTree )
;) *
public 
class  
BinarySearchTreeNode !
<! "
TKey" &
>& '
{		 
public 
 
BinarySearchTreeNode 
(  
TKey  $
key% (
)( )
=>* ,
Key- 0
=1 2
key3 6
;6 7
public 

TKey 
Key 
{ 
get 
; 
} 
public 
 
BinarySearchTreeNode 
<  
TKey  $
>$ %
?% &
Left' +
{, -
get. 1
;1 2
set3 6
;6 7
}8 9
public 
 
BinarySearchTreeNode 
<  
TKey  $
>$ %
?% &
Right' ,
{- .
get/ 2
;2 3
set4 7
;7 8
}9 :
} ⁄√
]C:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\BitArray.cs
	namespace{{ 	
DataStructures{{
 
;{{ 
publicÇÇ 
sealed
ÇÇ 
class
ÇÇ 
BitArray
ÇÇ 
:
ÇÇ 

ICloneable
ÇÇ )
,
ÇÇ) *
IEnumerator
ÇÇ+ 6
<
ÇÇ6 7
bool
ÇÇ7 ;
>
ÇÇ; <
,
ÇÇ< =
IEnumerable
ÇÇ> I
<
ÇÇI J
bool
ÇÇJ N
>
ÇÇN O
{ÉÉ 
private
ÑÑ 
readonly
ÑÑ 
bool
ÑÑ 
[
ÑÑ 
]
ÑÑ 
field
ÑÑ !
;
ÑÑ! "
private
ÖÖ 
int
ÖÖ 
position
ÖÖ 
=
ÖÖ 
-
ÖÖ 
$num
ÖÖ 
;
ÖÖ 
public
åå 

BitArray
åå 
(
åå 
int
åå 
n
åå 
)
åå 
{
çç 
if
éé 

(
éé 
n
éé 
<
éé 
$num
éé 
)
éé 
{
èè 	
field
êê 
=
êê 
new
êê 
bool
êê 
[
êê 
$num
êê 
]
êê 
;
êê  
}
ëë 	
field
ìì 
=
ìì 
new
ìì 
bool
ìì 
[
ìì 
n
ìì 
]
ìì 
;
ìì 
}
îî 
public
ûû 

BitArray
ûû 
(
ûû 
string
ûû 
sequence
ûû #
)
ûû# $
{
üü 
if
°° 

(
°° 
sequence
°° 
.
°° 
Length
°° 
<=
°° 
$num
°°  
)
°°  !
{
¢¢ 	
throw
££ 
new
££ 
ArgumentException
££ '
(
££' (
$str
££( W
)
££W X
;
££X Y
}
§§ 	&
ThrowIfSequenceIsInvalid
ßß  
(
ßß  !
sequence
ßß! )
)
ßß) *
;
ßß* +
field
©© 
=
©© 
new
©© 
bool
©© 
[
©© 
sequence
©© !
.
©©! "
Length
©©" (
]
©©( )
;
©©) *
Compile
™™ 
(
™™ 
sequence
™™ 
)
™™ 
;
™™ 
}
´´ 
public
≤≤ 

BitArray
≤≤ 
(
≤≤ 
bool
≤≤ 
[
≤≤ 
]
≤≤ 
bits
≤≤ 
)
≤≤  
=>
≤≤! #
field
≤≤$ )
=
≤≤* +
bits
≤≤, 0
;
≤≤0 1
private
∑∑ 
int
∑∑ 
Length
∑∑ 
=>
∑∑ 
field
∑∑ 
.
∑∑  
Length
∑∑  &
;
∑∑& '
public
ææ 

bool
ææ 
this
ææ 
[
ææ 
int
ææ 
offset
ææ 
]
ææ  
{
øø 
get
¿¿ 
=>
¿¿ 
field
¿¿ 
[
¿¿ 
offset
¿¿ 
]
¿¿ 
;
¿¿ 
private
¡¡ 
set
¡¡ 
=>
¡¡ 
field
¡¡ 
[
¡¡ 
offset
¡¡ #
]
¡¡# $
=
¡¡% &
value
¡¡' ,
;
¡¡, -
}
¬¬ 
public
»» 

object
»» 
Clone
»» 
(
»» 
)
»» 
{
…… 
var
   
theClone
   
=
   
new
   
BitArray
   #
(
  # $
Length
  $ *
)
  * +
;
  + ,
for
ÃÃ 
(
ÃÃ 
var
ÃÃ 
i
ÃÃ 
=
ÃÃ 
$num
ÃÃ 
;
ÃÃ 
i
ÃÃ 
<
ÃÃ 
Length
ÃÃ "
;
ÃÃ" #
i
ÃÃ$ %
++
ÃÃ% '
)
ÃÃ' (
{
ÕÕ 	
theClone
ŒŒ 
[
ŒŒ 
i
ŒŒ 
]
ŒŒ 
=
ŒŒ 
field
ŒŒ 
[
ŒŒ  
i
ŒŒ  !
]
ŒŒ! "
;
ŒŒ" #
}
œœ 	
return
—— 
theClone
—— 
;
—— 
}
““ 
public
ÿÿ 

IEnumerator
ÿÿ 
<
ÿÿ 
bool
ÿÿ 
>
ÿÿ 
GetEnumerator
ÿÿ *
(
ÿÿ* +
)
ÿÿ+ ,
=>
ÿÿ- /
this
ÿÿ0 4
;
ÿÿ4 5
IEnumerator
ﬁﬁ 
IEnumerable
ﬁﬁ 
.
ﬁﬁ 
GetEnumerator
ﬁﬁ )
(
ﬁﬁ) *
)
ﬁﬁ* +
=>
ﬁﬁ, .
this
ﬁﬁ/ 3
;
ﬁﬁ3 4
public
„„ 

bool
„„ 
Current
„„ 
=>
„„ 
field
„„  
[
„„  !
position
„„! )
]
„„) *
;
„„* +
object
ËË 

IEnumerator
ËË 
.
ËË 
Current
ËË 
=>
ËË !
field
ËË" '
[
ËË' (
position
ËË( 0
]
ËË0 1
;
ËË1 2
public
ÓÓ 

bool
ÓÓ 
MoveNext
ÓÓ 
(
ÓÓ 
)
ÓÓ 
{
ÔÔ 
if
 

(
 
position
 
+
 
$num
 
>=
 
field
 !
.
! "
Length
" (
)
( )
{
ÒÒ 	
return
ÚÚ 
false
ÚÚ 
;
ÚÚ 
}
ÛÛ 	
position
ıı 
++
ıı 
;
ıı 
return
ˆˆ 
true
ˆˆ 
;
ˆˆ 
}
˜˜ 
public
˝˝ 

void
˝˝ 
Reset
˝˝ 
(
˝˝ 
)
˝˝ 
=>
˝˝ 
position
˝˝ #
=
˝˝$ %
-
˝˝& '
$num
˝˝' (
;
˝˝( )
public
ÇÇ 

void
ÇÇ 
Dispose
ÇÇ 
(
ÇÇ 
)
ÇÇ 
{
ÉÉ 
}
ÖÖ 
public
éé 

static
éé 
BitArray
éé 
operator
éé #
&
éé$ %
(
éé% &
BitArray
éé& .
one
éé/ 2
,
éé2 3
BitArray
éé4 <
two
éé= @
)
éé@ A
{
èè 
var
êê 
	sequence1
êê 
=
êê 
one
êê 
.
êê 
ToString
êê $
(
êê$ %
)
êê% &
;
êê& '
var
ëë 
	sequence2
ëë 
=
ëë 
two
ëë 
.
ëë 
ToString
ëë $
(
ëë$ %
)
ëë% &
;
ëë& '
var
íí 
result
íí 
=
íí 
new
íí 
StringBuilder
íí &
(
íí& '
)
íí' (
;
íí( )
var
ìì 
tmp
ìì 
=
ìì 
new
ìì 
StringBuilder
ìì #
(
ìì# $
)
ìì$ %
;
ìì% &
if
ññ 

(
ññ 
one
ññ 
.
ññ 
Length
ññ 
!=
ññ 
two
ññ 
.
ññ 
Length
ññ $
)
ññ$ %
{
óó 	
int
òò 

difference
òò 
;
òò 
if
ôô 
(
ôô 
one
ôô 
.
ôô 
Length
ôô 
>
ôô 
two
ôô  
.
ôô  !
Length
ôô! '
)
ôô' (
{
öö 

difference
úú 
=
úú 
one
úú  
.
úú  !
Length
úú! '
-
úú( )
two
úú* -
.
úú- .
Length
úú. 4
;
úú4 5
for
üü 
(
üü 
var
üü 
i
üü 
=
üü 
$num
üü 
;
üü 
i
üü  !
<
üü" #

difference
üü$ .
;
üü. /
i
üü0 1
++
üü1 3
)
üü3 4
{
†† 
tmp
°° 
.
°° 
Append
°° 
(
°° 
$char
°° "
)
°°" #
;
°°# $
}
¢¢ 
tmp
§§ 
.
§§ 
Append
§§ 
(
§§ 
two
§§ 
)
§§ 
;
§§  
	sequence2
•• 
=
•• 
tmp
•• 
.
••  
ToString
••  (
(
••( )
)
••) *
;
••* +
}
¶¶ 
else
ßß 
{
®® 

difference
™™ 
=
™™ 
two
™™  
.
™™  !
Length
™™! '
-
™™( )
one
™™* -
.
™™- .
Length
™™. 4
;
™™4 5
for
≠≠ 
(
≠≠ 
var
≠≠ 
i
≠≠ 
=
≠≠ 
$num
≠≠ 
;
≠≠ 
i
≠≠  !
<
≠≠" #

difference
≠≠$ .
;
≠≠. /
i
≠≠0 1
++
≠≠1 3
)
≠≠3 4
{
ÆÆ 
tmp
ØØ 
.
ØØ 
Append
ØØ 
(
ØØ 
$char
ØØ "
)
ØØ" #
;
ØØ# $
}
∞∞ 
tmp
≤≤ 
.
≤≤ 
Append
≤≤ 
(
≤≤ 
one
≤≤ 
)
≤≤ 
;
≤≤  
	sequence1
≥≥ 
=
≥≥ 
tmp
≥≥ 
.
≥≥  
ToString
≥≥  (
(
≥≥( )
)
≥≥) *
;
≥≥* +
}
¥¥ 
}
µµ 	
var
∑∑ 
len
∑∑ 
=
∑∑ 
one
∑∑ 
.
∑∑ 
Length
∑∑ 
>
∑∑ 
two
∑∑ "
.
∑∑" #
Length
∑∑# )
?
∑∑* +
one
∑∑, /
.
∑∑/ 0
Length
∑∑0 6
:
∑∑7 8
two
∑∑9 <
.
∑∑< =
Length
∑∑= C
;
∑∑C D
var
∏∏ 
ans
∏∏ 
=
∏∏ 
new
∏∏ 
BitArray
∏∏ 
(
∏∏ 
len
∏∏ "
)
∏∏" #
;
∏∏# $
for
∫∫ 
(
∫∫ 
var
∫∫ 
i
∫∫ 
=
∫∫ 
$num
∫∫ 
;
∫∫ 
i
∫∫ 
<
∫∫ 
one
∫∫ 
.
∫∫  
Length
∫∫  &
;
∫∫& '
i
∫∫( )
++
∫∫) +
)
∫∫+ ,
{
ªª 	
result
ºº 
.
ºº 
Append
ºº 
(
ºº 
	sequence1
ºº #
[
ºº# $
i
ºº$ %
]
ºº% &
.
ºº& '
Equals
ºº' -
(
ºº- .
$char
ºº. 1
)
ºº1 2
&&
ºº3 5
	sequence2
ºº6 ?
[
ºº? @
i
ºº@ A
]
ººA B
.
ººB C
Equals
ººC I
(
ººI J
$char
ººJ M
)
ººM N
?
ººO P
$char
ººQ T
:
ººU V
$char
ººW Z
)
ººZ [
;
ºº[ \
}
ΩΩ 	
ans
øø 
.
øø 
Compile
øø 
(
øø 
result
øø 
.
øø 
ToString
øø #
(
øø# $
)
øø$ %
.
øø% &
Trim
øø& *
(
øø* +
)
øø+ ,
)
øø, -
;
øø- .
return
¡¡ 
ans
¡¡ 
;
¡¡ 
}
¬¬ 
public
ÀÀ 

static
ÀÀ 
BitArray
ÀÀ 
operator
ÀÀ #
|
ÀÀ$ %
(
ÀÀ% &
BitArray
ÀÀ& .
one
ÀÀ/ 2
,
ÀÀ2 3
BitArray
ÀÀ4 <
two
ÀÀ= @
)
ÀÀ@ A
{
ÃÃ 
var
ÕÕ 
	sequence1
ÕÕ 
=
ÕÕ 
one
ÕÕ 
.
ÕÕ 
ToString
ÕÕ $
(
ÕÕ$ %
)
ÕÕ% &
;
ÕÕ& '
var
ŒŒ 
	sequence2
ŒŒ 
=
ŒŒ 
two
ŒŒ 
.
ŒŒ 
ToString
ŒŒ $
(
ŒŒ$ %
)
ŒŒ% &
;
ŒŒ& '
var
œœ 
result
œœ 
=
œœ 
string
œœ 
.
œœ 
Empty
œœ !
;
œœ! "
var
–– 
tmp
–– 
=
–– 
string
–– 
.
–– 
Empty
–– 
;
–– 
if
”” 

(
”” 
one
”” 
.
”” 
Length
”” 
!=
”” 
two
”” 
.
”” 
Length
”” $
)
””$ %
{
‘‘ 	
int
’’ 

difference
’’ 
;
’’ 
if
÷÷ 
(
÷÷ 
one
÷÷ 
.
÷÷ 
Length
÷÷ 
>
÷÷ 
two
÷÷  
.
÷÷  !
Length
÷÷! '
)
÷÷' (
{
◊◊ 

difference
ŸŸ 
=
ŸŸ 
one
ŸŸ  
.
ŸŸ  !
Length
ŸŸ! '
-
ŸŸ( )
two
ŸŸ* -
.
ŸŸ- .
Length
ŸŸ. 4
;
ŸŸ4 5
for
‹‹ 
(
‹‹ 
var
‹‹ 
i
‹‹ 
=
‹‹ 
$num
‹‹ 
;
‹‹ 
i
‹‹  !
<
‹‹" #

difference
‹‹$ .
;
‹‹. /
i
‹‹0 1
++
‹‹1 3
)
‹‹3 4
{
›› 
tmp
ﬁﬁ 
+=
ﬁﬁ 
$char
ﬁﬁ 
;
ﬁﬁ 
}
ﬂﬂ 
tmp
·· 
+=
·· 
two
·· 
.
·· 
ToString
·· #
(
··# $
)
··$ %
;
··% &
	sequence2
‚‚ 
=
‚‚ 
tmp
‚‚ 
;
‚‚  
}
„„ 
else
‰‰ 
{
ÂÂ 

difference
ÁÁ 
=
ÁÁ 
two
ÁÁ  
.
ÁÁ  !
Length
ÁÁ! '
-
ÁÁ( )
one
ÁÁ* -
.
ÁÁ- .
Length
ÁÁ. 4
;
ÁÁ4 5
for
ÍÍ 
(
ÍÍ 
var
ÍÍ 
i
ÍÍ 
=
ÍÍ 
$num
ÍÍ 
;
ÍÍ 
i
ÍÍ  !
<
ÍÍ" #

difference
ÍÍ$ .
;
ÍÍ. /
i
ÍÍ0 1
++
ÍÍ1 3
)
ÍÍ3 4
{
ÎÎ 
tmp
ÏÏ 
+=
ÏÏ 
$char
ÏÏ 
;
ÏÏ 
}
ÌÌ 
tmp
ÔÔ 
+=
ÔÔ 
one
ÔÔ 
.
ÔÔ 
ToString
ÔÔ #
(
ÔÔ# $
)
ÔÔ$ %
;
ÔÔ% &
	sequence1
 
=
 
tmp
 
;
  
}
ÒÒ 
}
ÚÚ 	
var
ÙÙ 
len
ÙÙ 
=
ÙÙ 
one
ÙÙ 
.
ÙÙ 
Length
ÙÙ 
>
ÙÙ 
two
ÙÙ "
.
ÙÙ" #
Length
ÙÙ# )
?
ÙÙ* +
one
ÙÙ, /
.
ÙÙ/ 0
Length
ÙÙ0 6
:
ÙÙ7 8
two
ÙÙ9 <
.
ÙÙ< =
Length
ÙÙ= C
;
ÙÙC D
var
ıı 
ans
ıı 
=
ıı 
new
ıı 
BitArray
ıı 
(
ıı 
len
ıı "
)
ıı" #
;
ıı# $
for
˜˜ 
(
˜˜ 
var
˜˜ 
i
˜˜ 
=
˜˜ 
$num
˜˜ 
;
˜˜ 
i
˜˜ 
<
˜˜ 
len
˜˜ 
;
˜˜  
i
˜˜! "
++
˜˜" $
)
˜˜$ %
{
¯¯ 	
result
˘˘ 
+=
˘˘ 
	sequence1
˘˘ 
[
˘˘  
i
˘˘  !
]
˘˘! "
.
˘˘" #
Equals
˘˘# )
(
˘˘) *
$char
˘˘* -
)
˘˘- .
&&
˘˘/ 1
	sequence2
˘˘2 ;
[
˘˘; <
i
˘˘< =
]
˘˘= >
.
˘˘> ?
Equals
˘˘? E
(
˘˘E F
$char
˘˘F I
)
˘˘I J
?
˘˘K L
$char
˘˘M P
:
˘˘Q R
$char
˘˘S V
;
˘˘V W
}
˙˙ 	
result
¸¸ 
=
¸¸ 
result
¸¸ 
.
¸¸ 
Trim
¸¸ 
(
¸¸ 
)
¸¸ 
;
¸¸ 
ans
˝˝ 
.
˝˝ 
Compile
˝˝ 
(
˝˝ 
result
˝˝ 
)
˝˝ 
;
˝˝ 
return
ˇˇ 
ans
ˇˇ 
;
ˇˇ 
}
ÄÄ 
public
àà 

static
àà 
BitArray
àà 
operator
àà #
~
àà$ %
(
àà% &
BitArray
àà& .
one
àà/ 2
)
àà2 3
{
ââ 
var
ää 
ans
ää 
=
ää 
new
ää 
BitArray
ää 
(
ää 
one
ää "
.
ää" #
Length
ää# )
)
ää) *
;
ää* +
var
ãã 
sequence
ãã 
=
ãã 
one
ãã 
.
ãã 
ToString
ãã #
(
ãã# $
)
ãã$ %
;
ãã% &
var
åå 
result
åå 
=
åå 
string
åå 
.
åå 
Empty
åå !
;
åå! "
foreach
éé 
(
éé 
var
éé 
ch
éé 
in
éé 
sequence
éé #
)
éé# $
{
èè 	
if
êê 
(
êê 
ch
êê 
==
êê 
$char
êê 
)
êê 
{
ëë 
result
íí 
+=
íí 
$char
íí 
;
íí 
}
ìì 
else
îî 
{
ïï 
result
ññ 
+=
ññ 
$char
ññ 
;
ññ 
}
óó 
}
òò 	
result
öö 
=
öö 
result
öö 
.
öö 
Trim
öö 
(
öö 
)
öö 
;
öö 
ans
õõ 
.
õõ 
Compile
õõ 
(
õõ 
result
õõ 
)
õõ 
;
õõ 
return
ùù 
ans
ùù 
;
ùù 
}
ûû 
public
ßß 

static
ßß 
BitArray
ßß 
operator
ßß #
<<
ßß$ &
(
ßß& '
BitArray
ßß' /
other
ßß0 5
,
ßß5 6
int
ßß7 :
n
ßß; <
)
ßß< =
{
®® 
var
©© 
ans
©© 
=
©© 
new
©© 
BitArray
©© 
(
©© 
other
©© $
.
©©$ %
Length
©©% +
+
©©, -
n
©©. /
)
©©/ 0
;
©©0 1
for
¨¨ 
(
¨¨ 
var
¨¨ 
i
¨¨ 
=
¨¨ 
$num
¨¨ 
;
¨¨ 
i
¨¨ 
<
¨¨ 
other
¨¨ !
.
¨¨! "
Length
¨¨" (
;
¨¨( )
i
¨¨* +
++
¨¨+ -
)
¨¨- .
{
≠≠ 	
ans
ÆÆ 
[
ÆÆ 
i
ÆÆ 
]
ÆÆ 
=
ÆÆ 
other
ÆÆ 
[
ÆÆ 
i
ÆÆ 
]
ÆÆ 
;
ÆÆ 
}
ØØ 	
return
±± 
ans
±± 
;
±± 
}
≤≤ 
public
ªª 

static
ªª 
BitArray
ªª 
operator
ªª #
^
ªª$ %
(
ªª% &
BitArray
ªª& .
one
ªª/ 2
,
ªª2 3
BitArray
ªª4 <
two
ªª= @
)
ªª@ A
{
ºº 
var
ΩΩ 
	sequence1
ΩΩ 
=
ΩΩ 
one
ΩΩ 
.
ΩΩ 
ToString
ΩΩ $
(
ΩΩ$ %
)
ΩΩ% &
;
ΩΩ& '
var
ææ 
	sequence2
ææ 
=
ææ 
two
ææ 
.
ææ 
ToString
ææ $
(
ææ$ %
)
ææ% &
;
ææ& '
var
øø 
tmp
øø 
=
øø 
string
øø 
.
øø 
Empty
øø 
;
øø 
if
¬¬ 

(
¬¬ 
one
¬¬ 
.
¬¬ 
Length
¬¬ 
!=
¬¬ 
two
¬¬ 
.
¬¬ 
Length
¬¬ $
)
¬¬$ %
{
√√ 	
int
ƒƒ 

difference
ƒƒ 
;
ƒƒ 
if
≈≈ 
(
≈≈ 
one
≈≈ 
.
≈≈ 
Length
≈≈ 
>
≈≈ 
two
≈≈  
.
≈≈  !
Length
≈≈! '
)
≈≈' (
{
∆∆ 

difference
»» 
=
»» 
one
»»  
.
»»  !
Length
»»! '
-
»»( )
two
»»* -
.
»»- .
Length
»». 4
;
»»4 5
for
ÀÀ 
(
ÀÀ 
var
ÀÀ 
i
ÀÀ 
=
ÀÀ 
$num
ÀÀ 
;
ÀÀ 
i
ÀÀ  !
<
ÀÀ" #

difference
ÀÀ$ .
;
ÀÀ. /
i
ÀÀ0 1
++
ÀÀ1 3
)
ÀÀ3 4
{
ÃÃ 
tmp
ÕÕ 
+=
ÕÕ 
$char
ÕÕ 
;
ÕÕ 
}
ŒŒ 
tmp
–– 
+=
–– 
two
–– 
.
–– 
ToString
–– #
(
––# $
)
––$ %
;
––% &
	sequence2
—— 
=
—— 
tmp
—— 
;
——  
}
““ 
else
”” 
{
‘‘ 

difference
÷÷ 
=
÷÷ 
two
÷÷  
.
÷÷  !
Length
÷÷! '
-
÷÷( )
one
÷÷* -
.
÷÷- .
Length
÷÷. 4
;
÷÷4 5
for
ŸŸ 
(
ŸŸ 
var
ŸŸ 
i
ŸŸ 
=
ŸŸ 
$num
ŸŸ 
;
ŸŸ 
i
ŸŸ  !
<
ŸŸ" #

difference
ŸŸ$ .
;
ŸŸ. /
i
ŸŸ0 1
++
ŸŸ1 3
)
ŸŸ3 4
{
⁄⁄ 
tmp
€€ 
+=
€€ 
$char
€€ 
;
€€ 
}
‹‹ 
tmp
ﬁﬁ 
+=
ﬁﬁ 
one
ﬁﬁ 
.
ﬁﬁ 
ToString
ﬁﬁ #
(
ﬁﬁ# $
)
ﬁﬁ$ %
;
ﬁﬁ% &
	sequence1
ﬂﬂ 
=
ﬂﬂ 
tmp
ﬂﬂ 
;
ﬂﬂ  
}
‡‡ 
}
·· 	
var
„„ 
len
„„ 
=
„„ 
one
„„ 
.
„„ 
Length
„„ 
>
„„ 
two
„„ "
.
„„" #
Length
„„# )
?
„„* +
one
„„, /
.
„„/ 0
Length
„„0 6
:
„„7 8
two
„„9 <
.
„„< =
Length
„„= C
;
„„C D
var
‰‰ 
ans
‰‰ 
=
‰‰ 
new
‰‰ 
BitArray
‰‰ 
(
‰‰ 
len
‰‰ "
)
‰‰" #
;
‰‰# $
var
ÊÊ 
sb
ÊÊ 
=
ÊÊ 
new
ÊÊ 
StringBuilder
ÊÊ "
(
ÊÊ" #
)
ÊÊ# $
;
ÊÊ$ %
for
ËË 
(
ËË 
var
ËË 
i
ËË 
=
ËË 
$num
ËË 
;
ËË 
i
ËË 
<
ËË 
len
ËË 
;
ËË  
i
ËË! "
++
ËË" $
)
ËË$ %
{
ÈÈ 	
_
ÍÍ 
=
ÍÍ 
sb
ÍÍ 
.
ÍÍ 
Append
ÍÍ 
(
ÍÍ 
	sequence1
ÍÍ #
[
ÍÍ# $
i
ÍÍ$ %
]
ÍÍ% &
==
ÍÍ' )
	sequence2
ÍÍ* 3
[
ÍÍ3 4
i
ÍÍ4 5
]
ÍÍ5 6
?
ÍÍ7 8
$char
ÍÍ9 <
:
ÍÍ= >
$char
ÍÍ? B
)
ÍÍB C
;
ÍÍC D
}
ÎÎ 	
var
ÌÌ 
result
ÌÌ 
=
ÌÌ 
sb
ÌÌ 
.
ÌÌ 
ToString
ÌÌ  
(
ÌÌ  !
)
ÌÌ! "
.
ÌÌ" #
Trim
ÌÌ# '
(
ÌÌ' (
)
ÌÌ( )
;
ÌÌ) *
ans
ÓÓ 
.
ÓÓ 
Compile
ÓÓ 
(
ÓÓ 
result
ÓÓ 
)
ÓÓ 
;
ÓÓ 
return
 
ans
 
;
 
}
ÒÒ 
public
˙˙ 

static
˙˙ 
BitArray
˙˙ 
operator
˙˙ #
>>
˙˙$ &
(
˙˙& '
BitArray
˙˙' /
other
˙˙0 5
,
˙˙5 6
int
˙˙7 :
n
˙˙; <
)
˙˙< =
{
˚˚ 
var
¸¸ 
ans
¸¸ 
=
¸¸ 
new
¸¸ 
BitArray
¸¸ 
(
¸¸ 
other
¸¸ $
.
¸¸$ %
Length
¸¸% +
-
¸¸, -
n
¸¸. /
)
¸¸/ 0
;
¸¸0 1
for
ˇˇ 
(
ˇˇ 
var
ˇˇ 
i
ˇˇ 
=
ˇˇ 
$num
ˇˇ 
;
ˇˇ 
i
ˇˇ 
<
ˇˇ 
other
ˇˇ !
.
ˇˇ! "
Length
ˇˇ" (
-
ˇˇ) *
n
ˇˇ+ ,
;
ˇˇ, -
i
ˇˇ. /
++
ˇˇ/ 1
)
ˇˇ1 2
{
ÄÄ 	
ans
ÅÅ 
[
ÅÅ 
i
ÅÅ 
]
ÅÅ 
=
ÅÅ 
other
ÅÅ 
[
ÅÅ 
i
ÅÅ 
]
ÅÅ 
;
ÅÅ 
}
ÇÇ 	
return
ÑÑ 
ans
ÑÑ 
;
ÑÑ 
}
ÖÖ 
public
éé 

static
éé 
bool
éé 
operator
éé 
==
éé  "
(
éé" #
BitArray
éé# +
one
éé, /
,
éé/ 0
BitArray
éé1 9
two
éé: =
)
éé= >
{
èè 
if
êê 

(
êê 
ReferenceEquals
êê 
(
êê 
one
êê 
,
êê  
two
êê! $
)
êê$ %
)
êê% &
{
ëë 	
return
íí 
true
íí 
;
íí 
}
ìì 	
if
ïï 

(
ïï 
one
ïï 
.
ïï 
Length
ïï 
!=
ïï 
two
ïï 
.
ïï 
Length
ïï $
)
ïï$ %
{
ññ 	
return
óó 
false
óó 
;
óó 
}
òò 	
var
öö 
status
öö 
=
öö 
true
öö 
;
öö 
for
õõ 
(
õõ 
var
õõ 
i
õõ 
=
õõ 
$num
õõ 
;
õõ 
i
õõ 
<
õõ 
one
õõ 
.
õõ  
Length
õõ  &
;
õõ& '
i
õõ( )
++
õõ) +
)
õõ+ ,
{
úú 	
if
ùù 
(
ùù 
one
ùù 
[
ùù 
i
ùù 
]
ùù 
!=
ùù 
two
ùù 
[
ùù 
i
ùù 
]
ùù  
)
ùù  !
{
ûû 
status
üü 
=
üü 
false
üü 
;
üü 
break
†† 
;
†† 
}
°° 
}
¢¢ 	
return
§§ 
status
§§ 
;
§§ 
}
•• 
public
ÆÆ 

static
ÆÆ 
bool
ÆÆ 
operator
ÆÆ 
!=
ÆÆ  "
(
ÆÆ" #
BitArray
ÆÆ# +
one
ÆÆ, /
,
ÆÆ/ 0
BitArray
ÆÆ1 9
two
ÆÆ: =
)
ÆÆ= >
=>
ÆÆ? A
!
ÆÆB C
(
ÆÆC D
one
ÆÆD G
==
ÆÆH J
two
ÆÆK N
)
ÆÆN O
;
ÆÆO P
public
∂∂ 

void
∂∂ 
Compile
∂∂ 
(
∂∂ 
string
∂∂ 
sequence
∂∂ '
)
∂∂' (
{
∑∑ 
if
ππ 

(
ππ 
sequence
ππ 
.
ππ 
Length
ππ 
>
ππ 
field
ππ #
.
ππ# $
Length
ππ$ *
)
ππ* +
{
∫∫ 	
throw
ªª 
new
ªª 
ArgumentException
ªª '
(
ªª' (
$"
ªª( *
{
ªª* +
nameof
ªª+ 1
(
ªª1 2
sequence
ªª2 :
)
ªª: ;
}
ªª; <
$str
ªª< i
"
ªªi j
)
ªªj k
;
ªªk l
}
ºº 	&
ThrowIfSequenceIsInvalid
øø  
(
øø  !
sequence
øø! )
)
øø) *
;
øø* +
var
¬¬ 
tmp
¬¬ 
=
¬¬ 
string
¬¬ 
.
¬¬ 
Empty
¬¬ 
;
¬¬ 
if
√√ 

(
√√ 
sequence
√√ 
.
√√ 
Length
√√ 
<
√√ 
field
√√ #
.
√√# $
Length
√√$ *
)
√√* +
{
ƒƒ 	
var
≈≈ 

difference
≈≈ 
=
≈≈ 
field
≈≈ "
.
≈≈" #
Length
≈≈# )
-
≈≈* +
sequence
≈≈, 4
.
≈≈4 5
Length
≈≈5 ;
;
≈≈; <
for
«« 
(
«« 
var
«« 
i
«« 
=
«« 
$num
«« 
;
«« 
i
«« 
<
«« 

difference
««  *
;
««* +
i
««, -
++
««- /
)
««/ 0
{
»» 
tmp
…… 
+=
…… 
$char
…… 
;
…… 
}
   
tmp
ÃÃ 
+=
ÃÃ 
sequence
ÃÃ 
;
ÃÃ 
sequence
ÕÕ 
=
ÕÕ 
tmp
ÕÕ 
;
ÕÕ 
}
ŒŒ 	
for
—— 
(
—— 
var
—— 
i
—— 
=
—— 
$num
—— 
;
—— 
i
—— 
<
—— 
sequence
—— $
.
——$ %
Length
——% +
;
——+ ,
i
——- .
++
——. 0
)
——0 1
{
““ 	
field
”” 
[
”” 
i
”” 
]
”” 
=
”” 
sequence
”” 
[
””  
i
””  !
]
””! "
==
””# %
$char
””& )
;
””) *
}
‘‘ 	
}
’’ 
public
‹‹ 

void
‹‹ 
Compile
‹‹ 
(
‹‹ 
int
‹‹ 
number
‹‹ "
)
‹‹" #
{
›› 
var
ﬁﬁ 
tmp
ﬁﬁ 
=
ﬁﬁ 
string
ﬁﬁ 
.
ﬁﬁ 
Empty
ﬁﬁ 
;
ﬁﬁ 
if
·· 

(
·· 
number
·· 
<=
·· 
$num
·· 
)
·· 
{
‚‚ 	
throw
„„ 
new
„„ 
ArgumentException
„„ '
(
„„' (
$"
„„( *
{
„„* +
nameof
„„+ 1
(
„„1 2
number
„„2 8
)
„„8 9
}
„„9 :
$str
„„: K
"
„„K L
)
„„L M
;
„„M N
}
‰‰ 	
var
ÁÁ 
binaryNumber
ÁÁ 
=
ÁÁ 
Convert
ÁÁ "
.
ÁÁ" #
ToString
ÁÁ# +
(
ÁÁ+ ,
number
ÁÁ, 2
,
ÁÁ2 3
$num
ÁÁ4 5
)
ÁÁ5 6
;
ÁÁ6 7
if
ÍÍ 

(
ÍÍ 
binaryNumber
ÍÍ 
.
ÍÍ 
Length
ÍÍ 
>
ÍÍ  !
field
ÍÍ" '
.
ÍÍ' (
Length
ÍÍ( .
)
ÍÍ. /
{
ÎÎ 	
throw
ÏÏ 
new
ÏÏ 
ArgumentException
ÏÏ '
(
ÏÏ' (
$str
ÏÏ( D
)
ÏÏD E
;
ÏÏE F
}
ÌÌ 	
if
 

(
 
binaryNumber
 
.
 
Length
 
<
  !
field
" '
.
' (
Length
( .
)
. /
{
ÒÒ 	
var
ÚÚ 

difference
ÚÚ 
=
ÚÚ 
field
ÚÚ "
.
ÚÚ" #
Length
ÚÚ# )
-
ÚÚ* +
binaryNumber
ÚÚ, 8
.
ÚÚ8 9
Length
ÚÚ9 ?
;
ÚÚ? @
for
ÙÙ 
(
ÙÙ 
var
ÙÙ 
i
ÙÙ 
=
ÙÙ 
$num
ÙÙ 
;
ÙÙ 
i
ÙÙ 
<
ÙÙ 

difference
ÙÙ  *
;
ÙÙ* +
i
ÙÙ, -
++
ÙÙ- /
)
ÙÙ/ 0
{
ıı 
tmp
ˆˆ 
+=
ˆˆ 
$char
ˆˆ 
;
ˆˆ 
}
˜˜ 
tmp
˘˘ 
+=
˘˘ 
binaryNumber
˘˘ 
;
˘˘  
binaryNumber
˙˙ 
=
˙˙ 
tmp
˙˙ 
;
˙˙ 
}
˚˚ 	
for
˛˛ 
(
˛˛ 
var
˛˛ 
i
˛˛ 
=
˛˛ 
$num
˛˛ 
;
˛˛ 
i
˛˛ 
<
˛˛ 
binaryNumber
˛˛ (
.
˛˛( )
Length
˛˛) /
;
˛˛/ 0
i
˛˛1 2
++
˛˛2 4
)
˛˛4 5
{
ˇˇ 	
field
ÄÄ 
[
ÄÄ 
i
ÄÄ 
]
ÄÄ 
=
ÄÄ 
binaryNumber
ÄÄ #
[
ÄÄ# $
i
ÄÄ$ %
]
ÄÄ% &
==
ÄÄ' )
$char
ÄÄ* -
;
ÄÄ- .
}
ÅÅ 	
}
ÇÇ 
public
ââ 

void
ââ 
Compile
ââ 
(
ââ 
long
ââ 
number
ââ #
)
ââ# $
{
ää 
var
ãã 
tmp
ãã 
=
ãã 
string
ãã 
.
ãã 
Empty
ãã 
;
ãã 
if
éé 

(
éé 
number
éé 
<=
éé 
$num
éé 
)
éé 
{
èè 	
throw
êê 
new
êê 
ArgumentException
êê '
(
êê' (
$"
êê( *
{
êê* +
nameof
êê+ 1
(
êê1 2
number
êê2 8
)
êê8 9
}
êê9 :
$str
êê: K
"
êêK L
)
êêL M
;
êêM N
}
ëë 	
var
îî 
binaryNumber
îî 
=
îî 
Convert
îî "
.
îî" #
ToString
îî# +
(
îî+ ,
number
îî, 2
,
îî2 3
$num
îî4 5
)
îî5 6
;
îî6 7
if
óó 

(
óó 
binaryNumber
óó 
.
óó 
Length
óó 
>
óó  !
field
óó" '
.
óó' (
Length
óó( .
)
óó. /
{
òò 	
throw
ôô 
new
ôô 
ArgumentException
ôô '
(
ôô' (
$str
ôô( D
)
ôôD E
;
ôôE F
}
öö 	
if
ùù 

(
ùù 
binaryNumber
ùù 
.
ùù 
Length
ùù 
<
ùù  !
field
ùù" '
.
ùù' (
Length
ùù( .
)
ùù. /
{
ûû 	
var
üü 

difference
üü 
=
üü 
field
üü "
.
üü" #
Length
üü# )
-
üü* +
binaryNumber
üü, 8
.
üü8 9
Length
üü9 ?
;
üü? @
for
°° 
(
°° 
var
°° 
i
°° 
=
°° 
$num
°° 
;
°° 
i
°° 
<
°° 

difference
°°  *
;
°°* +
i
°°, -
++
°°- /
)
°°/ 0
{
¢¢ 
tmp
££ 
+=
££ 
$char
££ 
;
££ 
}
§§ 
tmp
¶¶ 
+=
¶¶ 
binaryNumber
¶¶ 
;
¶¶  
binaryNumber
ßß 
=
ßß 
tmp
ßß 
;
ßß 
}
®® 	
for
´´ 
(
´´ 
var
´´ 
i
´´ 
=
´´ 
$num
´´ 
;
´´ 
i
´´ 
<
´´ 
binaryNumber
´´ (
.
´´( )
Length
´´) /
;
´´/ 0
i
´´1 2
++
´´2 4
)
´´4 5
{
¨¨ 	
field
≠≠ 
[
≠≠ 
i
≠≠ 
]
≠≠ 
=
≠≠ 
binaryNumber
≠≠ #
[
≠≠# $
i
≠≠$ %
]
≠≠% &
==
≠≠' )
$char
≠≠* -
;
≠≠- .
}
ÆÆ 	
}
ØØ 
public
µµ 

override
µµ 
string
µµ 
ToString
µµ #
(
µµ# $
)
µµ$ %
{
∂∂ 
return
∏∏ 
field
∏∏ 
.
∏∏ 
	Aggregate
∏∏ 
(
∏∏ 
string
∏∏ %
.
∏∏% &
Empty
∏∏& +
,
∏∏+ ,
(
∏∏- .
current
∏∏. 5
,
∏∏5 6
t
∏∏7 8
)
∏∏8 9
=>
∏∏: <
current
∏∏= D
+
∏∏E F
(
∏∏G H
t
∏∏H I
?
∏∏J K
$str
∏∏L O
:
∏∏P Q
$str
∏∏R U
)
∏∏U V
)
∏∏V W
;
∏∏W X
}
ππ 
public
øø 

int
øø 
NumberOfOneBits
øø 
(
øø 
)
øø  
{
¿¿ 
return
¬¬ 
field
¬¬ 
.
¬¬ 
Count
¬¬ 
(
¬¬ 
bit
¬¬ 
=>
¬¬ !
bit
¬¬" %
)
¬¬% &
;
¬¬& '
}
√√ 
public
…… 

int
…… 
NumberOfZeroBits
…… 
(
……  
)
……  !
{
   
return
ÃÃ 
field
ÃÃ 
.
ÃÃ 
Count
ÃÃ 
(
ÃÃ 
bit
ÃÃ 
=>
ÃÃ !
!
ÃÃ" #
bit
ÃÃ# &
)
ÃÃ& '
;
ÃÃ' (
}
ÕÕ 
public
”” 

bool
”” 

EvenParity
”” 
(
”” 
)
”” 
=>
”” 
NumberOfOneBits
””  /
(
””/ 0
)
””0 1
%
””2 3
$num
””4 5
==
””6 8
$num
””9 :
;
””: ;
public
ŸŸ 

bool
ŸŸ 
	OddParity
ŸŸ 
(
ŸŸ 
)
ŸŸ 
=>
ŸŸ 
NumberOfOneBits
ŸŸ .
(
ŸŸ. /
)
ŸŸ/ 0
%
ŸŸ1 2
$num
ŸŸ3 4
!=
ŸŸ5 7
$num
ŸŸ8 9
;
ŸŸ9 :
public
‡‡ 

long
‡‡ 
ToInt64
‡‡ 
(
‡‡ 
)
‡‡ 
{
·· 
if
„„ 

(
„„ 
field
„„ 
.
„„ 
Length
„„ 
>
„„ 
$num
„„ 
)
„„ 
{
‰‰ 	
throw
ÂÂ 
new
ÂÂ '
InvalidOperationException
ÂÂ /
(
ÂÂ/ 0
$str
ÂÂ0 T
)
ÂÂT U
;
ÂÂU V
}
ÊÊ 	
var
ËË 
sequence
ËË 
=
ËË 
ToString
ËË 
(
ËË  
)
ËË  !
;
ËË! "
return
ÈÈ 
Convert
ÈÈ 
.
ÈÈ 
ToInt64
ÈÈ 
(
ÈÈ 
sequence
ÈÈ '
,
ÈÈ' (
$num
ÈÈ) *
)
ÈÈ* +
;
ÈÈ+ ,
}
ÍÍ 
public
ÒÒ 

int
ÒÒ 
ToInt32
ÒÒ 
(
ÒÒ 
)
ÒÒ 
{
ÚÚ 
if
ÙÙ 

(
ÙÙ 
field
ÙÙ 
.
ÙÙ 
Length
ÙÙ 
>
ÙÙ 
$num
ÙÙ 
)
ÙÙ 
{
ıı 	
throw
ˆˆ 
new
ˆˆ '
InvalidOperationException
ˆˆ /
(
ˆˆ/ 0
$str
ˆˆ0 T
)
ˆˆT U
;
ˆˆU V
}
˜˜ 	
var
˘˘ 
sequence
˘˘ 
=
˘˘ 
ToString
˘˘ 
(
˘˘  
)
˘˘  !
;
˘˘! "
return
˙˙ 
Convert
˙˙ 
.
˙˙ 
ToInt32
˙˙ 
(
˙˙ 
sequence
˙˙ '
,
˙˙' (
$num
˙˙) *
)
˙˙* +
;
˙˙+ ,
}
˚˚ 
public
ÄÄ 

void
ÄÄ 

ResetField
ÄÄ 
(
ÄÄ 
)
ÄÄ 
{
ÅÅ 
for
ÇÇ 
(
ÇÇ 
var
ÇÇ 
i
ÇÇ 
=
ÇÇ 
$num
ÇÇ 
;
ÇÇ 
i
ÇÇ 
<
ÇÇ 
field
ÇÇ !
.
ÇÇ! "
Length
ÇÇ" (
;
ÇÇ( )
i
ÇÇ* +
++
ÇÇ+ -
)
ÇÇ- .
{
ÉÉ 	
field
ÑÑ 
[
ÑÑ 
i
ÑÑ 
]
ÑÑ 
=
ÑÑ 
false
ÑÑ 
;
ÑÑ 
}
ÖÖ 	
}
ÜÜ 
public
åå 

void
åå 
SetAll
åå 
(
åå 
bool
åå 
flag
åå  
)
åå  !
{
çç 
for
éé 
(
éé 
var
éé 
i
éé 
=
éé 
$num
éé 
;
éé 
i
éé 
<
éé 
field
éé !
.
éé! "
Length
éé" (
;
éé( )
i
éé* +
++
éé+ -
)
éé- .
{
èè 	
field
êê 
[
êê 
i
êê 
]
êê 
=
êê 
flag
êê 
;
êê 
}
ëë 	
}
íí 
public
öö 

override
öö 
bool
öö 
Equals
öö 
(
öö  
object
öö  &
?
öö& '
obj
öö( +
)
öö+ ,
{
õõ 
if
úú 

(
úú 
obj
úú 
is
úú 
null
úú 
)
úú 
{
ùù 	
return
ûû 
false
ûû 
;
ûû 
}
üü 	
var
°° 
otherBitArray
°° 
=
°° 
(
°° 
BitArray
°° %
)
°°% &
obj
°°& )
;
°°) *
if
££ 

(
££ 
Length
££ 
!=
££ 
otherBitArray
££ #
.
££# $
Length
££$ *
)
££* +
{
§§ 	
return
•• 
false
•• 
;
•• 
}
¶¶ 	
for
®® 
(
®® 
var
®® 
i
®® 
=
®® 
$num
®® 
;
®® 
i
®® 
<
®® 
Length
®® "
;
®®" #
i
®®$ %
++
®®% '
)
®®' (
{
©© 	
if
™™ 
(
™™ 
field
™™ 
[
™™ 
i
™™ 
]
™™ 
!=
™™ 
otherBitArray
™™ )
[
™™) *
i
™™* +
]
™™+ ,
)
™™, -
{
´´ 
return
¨¨ 
false
¨¨ 
;
¨¨ 
}
≠≠ 
}
ÆÆ 	
return
∞∞ 
true
∞∞ 
;
∞∞ 
}
±± 
public
∏∏ 

override
∏∏ 
int
∏∏ 
GetHashCode
∏∏ #
(
∏∏# $
)
∏∏$ %
=>
∏∏& (
ToInt32
∏∏) 0
(
∏∏0 1
)
∏∏1 2
;
∏∏2 3
private
∫∫ 
static
∫∫ 
void
∫∫ &
ThrowIfSequenceIsInvalid
∫∫ 0
(
∫∫0 1
string
∫∫1 7
sequence
∫∫8 @
)
∫∫@ A
{
ªª 
if
ºº 

(
ºº 
!
ºº 
Match
ºº 
(
ºº 
sequence
ºº 
)
ºº 
)
ºº 
{
ΩΩ 	
throw
ææ 
new
ææ 
ArgumentException
ææ '
(
ææ' (
$str
ææ( U
)
ææU V
;
ææV W
}
øø 	
}
¿¿ 
private
»» 
static
»» 
bool
»» 
Match
»» 
(
»» 
string
»» $
sequence
»»% -
)
»»- .
=>
»»/ 1
sequence
»»2 :
.
»»: ;
All
»»; >
(
»»> ?
ch
»»? A
=>
»»B D
ch
»»E G
==
»»H J
$char
»»K N
||
»»O Q
ch
»»R T
==
»»U W
$char
»»X [
)
»»[ \
;
»»\ ]
}…… ÷
lC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\DisjointSet\DisjointSet.cs
	namespace 	
DataStructures
 
. 
DisjointSet $
;$ %
public		 
class		 
DisjointSet		 
<		 
T		 
>		 
{

 
public 

Node 
< 
T 
> 
MakeSet 
( 
T 
x 
) 
=>  "
new# &
(& '
x' (
)( )
;) *
public 

Node 
< 
T 
> 
FindSet 
( 
Node 
<  
T  !
>! "
node# '
)' (
{ 
if 

( 
node 
!= 
node 
. 
Parent 
)  
{ 	
node 
. 
Parent 
= 
FindSet !
(! "
node" &
.& '
Parent' -
)- .
;. /
} 	
return 
node 
. 
Parent 
; 
} 
public&& 

void&& 
UnionSet&& 
(&& 
Node&& 
<&& 
T&& 
>&&  
x&&! "
,&&" #
Node&&$ (
<&&( )
T&&) *
>&&* +
y&&, -
)&&- .
{'' 
Node(( 
<(( 
T(( 
>(( 
nx(( 
=(( 
FindSet(( 
((( 
x(( 
)(( 
;((  
Node)) 
<)) 
T)) 
>)) 
ny)) 
=)) 
FindSet)) 
()) 
y)) 
))) 
;))  
if** 

(** 
nx** 
==** 
ny** 
)** 
{++ 	
return,, 
;,, 
}-- 	
if// 

(// 
nx// 
.// 
Rank// 
>// 
ny// 
.// 
Rank// 
)// 
{00 	
ny11 
.11 
Parent11 
=11 
nx11 
;11 
}22 	
else33 
if33 
(33 
ny33 
.33 
Rank33 
>33 
nx33 
.33 
Rank33 "
)33" #
{44 	
nx55 
.55 
Parent55 
=55 
ny55 
;55 
}66 	
else77 
{88 	
nx99 
.99 
Parent99 
=99 
ny99 
;99 
ny:: 
.:: 
Rank:: 
++:: 
;:: 
};; 	
}<< 
}== í¢
vC:\programmering\mex\DA231X\ZeroShot\C-Sharp-master\C-Sharp-master\DataStructures\BinarySearchTree\BinarySearchTree.cs
	namespace 	
DataStructures
 
. 
BinarySearchTree )
;) *
public 
class 
BinarySearchTree 
< 
TKey "
>" #
{ 
private 
readonly 
Comparer 
< 
TKey "
>" #
comparer$ ,
;, -
public 
 
BinarySearchTreeNode 
<  
TKey  $
>$ %
?% &
Root' +
{, -
get. 1
;1 2
private3 :
set; >
;> ?
}@ A
public 

BinarySearchTree 
( 
) 
{   
Root!! 
=!! 
null!! 
;!! 
Count"" 
="" 
$num"" 
;"" 
comparer## 
=## 
Comparer## 
<## 
TKey##  
>##  !
.##! "
Default##" )
;##) *
}$$ 
public&& 

BinarySearchTree&& 
(&& 
Comparer&& $
<&&$ %
TKey&&% )
>&&) *
customComparer&&+ 9
)&&9 :
{'' 
Root(( 
=(( 
null(( 
;(( 
Count)) 
=)) 
$num)) 
;)) 
comparer** 
=** 
customComparer** !
;**! "
}++ 
public00 

int00 
Count00 
{00 
get00 
;00 
private00 #
set00$ '
;00' (
}00) *
public99 

void99 
Add99 
(99 
TKey99 
key99 
)99 
{:: 
if;; 

(;; 
Root;; 
is;; 
null;; 
);; 
{<< 	
Root== 
=== 
new==  
BinarySearchTreeNode== +
<==+ ,
TKey==, 0
>==0 1
(==1 2
key==2 5
)==5 6
;==6 7
}>> 	
else?? 
{@@ 	
AddAA 
(AA 
RootAA 
,AA 
keyAA 
)AA 
;AA 
}BB 	
CountDD 
++DD 
;DD 
}EE 
publicLL 

voidLL 
AddRangeLL 
(LL 
IEnumerableLL $
<LL$ %
TKeyLL% )
>LL) *
keysLL+ /
)LL/ 0
{MM 
foreachNN 
(NN 
varNN 
keyNN 
inNN 
keysNN  
)NN  !
{OO 	
AddPP 
(PP 
keyPP 
)PP 
;PP 
}QQ 	
}RR 
publicYY 
 
BinarySearchTreeNodeYY 
<YY  
TKeyYY  $
>YY$ %
?YY% &
SearchYY' -
(YY- .
TKeyYY. 2
keyYY3 6
)YY6 7
=>YY8 :
SearchYY; A
(YYA B
RootYYB F
,YYF G
keyYYH K
)YYK L
;YYL M
public`` 

bool`` 
Contains`` 
(`` 
TKey`` 
key`` !
)``! "
=>``# %
Search``& ,
(``, -
Root``- 1
,``1 2
key``3 6
)``6 7
is``8 :
not``; >
null``? C
;``C D
publicgg 

boolgg 
Removegg 
(gg 
TKeygg 
keygg 
)gg  
{hh 
ifii 

(ii 
Rootii 
isii 
nullii 
)ii 
{jj 	
returnkk 
falsekk 
;kk 
}ll 	
varnn 
resultnn 
=nn 
Removenn 
(nn 
Rootnn  
,nn  !
Rootnn" &
,nn& '
keynn( +
)nn+ ,
;nn, -
ifoo 

(oo 
resultoo 
)oo 
{pp 	
Countqq 
--qq 
;qq 
}rr 	
returntt 
resulttt 
;tt 
}uu 
public{{ 
 
BinarySearchTreeNode{{ 
<{{  
TKey{{  $
>{{$ %
?{{% &
GetMin{{' -
({{- .
){{. /
{|| 
if}} 

(}} 
Root}} 
is}} 
null}} 
)}} 
{~~ 	
return 
default 
; 
}
ÄÄ 	
return
ÇÇ 
GetMin
ÇÇ 
(
ÇÇ 
Root
ÇÇ 
)
ÇÇ 
;
ÇÇ 
}
ÉÉ 
public
ââ 
"
BinarySearchTreeNode
ââ 
<
ââ  
TKey
ââ  $
>
ââ$ %
?
ââ% &
GetMax
ââ' -
(
ââ- .
)
ââ. /
{
ää 
if
ãã 

(
ãã 
Root
ãã 
is
ãã 
null
ãã 
)
ãã 
{
åå 	
return
çç 
default
çç 
;
çç 
}
éé 	
return
êê 
GetMax
êê 
(
êê 
Root
êê 
)
êê 
;
êê 
}
ëë 
public
óó 

ICollection
óó 
<
óó 
TKey
óó 
>
óó 
GetKeysInOrder
óó +
(
óó+ ,
)
óó, -
=>
óó. 0
GetKeysInOrder
óó1 ?
(
óó? @
Root
óó@ D
)
óóD E
;
óóE F
public
ùù 

ICollection
ùù 
<
ùù 
TKey
ùù 
>
ùù 
GetKeysPreOrder
ùù ,
(
ùù, -
)
ùù- .
=>
ùù/ 1
GetKeysPreOrder
ùù2 A
(
ùùA B
Root
ùùB F
)
ùùF G
;
ùùG H
public
££ 

ICollection
££ 
<
££ 
TKey
££ 
>
££ 
GetKeysPostOrder
££ -
(
££- .
)
££. /
=>
££0 2
GetKeysPostOrder
££3 C
(
££C D
Root
££D H
)
££H I
;
££I J
private
≠≠ 
void
≠≠ 
Add
≠≠ 
(
≠≠ "
BinarySearchTreeNode
≠≠ )
<
≠≠) *
TKey
≠≠* .
>
≠≠. /
node
≠≠0 4
,
≠≠4 5
TKey
≠≠6 :
key
≠≠; >
)
≠≠> ?
{
ÆÆ 
var
ØØ 
compareResult
ØØ 
=
ØØ 
comparer
ØØ $
.
ØØ$ %
Compare
ØØ% ,
(
ØØ, -
node
ØØ- 1
.
ØØ1 2
Key
ØØ2 5
,
ØØ5 6
key
ØØ7 :
)
ØØ: ;
;
ØØ; <
if
∞∞ 

(
∞∞ 
compareResult
∞∞ 
>
∞∞ 
$num
∞∞ 
)
∞∞ 
{
±± 	
if
≤≤ 
(
≤≤ 
node
≤≤ 
.
≤≤ 
Left
≤≤ 
is
≤≤ 
not
≤≤  
null
≤≤! %
)
≤≤% &
{
≥≥ 
Add
¥¥ 
(
¥¥ 
node
¥¥ 
.
¥¥ 
Left
¥¥ 
,
¥¥ 
key
¥¥ "
)
¥¥" #
;
¥¥# $
}
µµ 
else
∂∂ 
{
∑∑ 
var
∏∏ 
newNode
∏∏ 
=
∏∏ 
new
∏∏ !"
BinarySearchTreeNode
∏∏" 6
<
∏∏6 7
TKey
∏∏7 ;
>
∏∏; <
(
∏∏< =
key
∏∏= @
)
∏∏@ A
;
∏∏A B
node
ππ 
.
ππ 
Left
ππ 
=
ππ 
newNode
ππ #
;
ππ# $
}
∫∫ 
}
ªª 	
else
ºº 
if
ºº 
(
ºº 
compareResult
ºº 
<
ºº  
$num
ºº! "
)
ºº" #
{
ΩΩ 	
if
ææ 
(
ææ 
node
ææ 
.
ææ 
Right
ææ 
is
ææ 
not
ææ !
null
ææ" &
)
ææ& '
{
øø 
Add
¿¿ 
(
¿¿ 
node
¿¿ 
.
¿¿ 
Right
¿¿ 
,
¿¿ 
key
¿¿  #
)
¿¿# $
;
¿¿$ %
}
¡¡ 
else
¬¬ 
{
√√ 
var
ƒƒ 
newNode
ƒƒ 
=
ƒƒ 
new
ƒƒ !"
BinarySearchTreeNode
ƒƒ" 6
<
ƒƒ6 7
TKey
ƒƒ7 ;
>
ƒƒ; <
(
ƒƒ< =
key
ƒƒ= @
)
ƒƒ@ A
;
ƒƒA B
node
≈≈ 
.
≈≈ 
Right
≈≈ 
=
≈≈ 
newNode
≈≈ $
;
≈≈$ %
}
∆∆ 
}
«« 	
else
   
{
ÀÀ 	
throw
ÃÃ 
new
ÃÃ 
ArgumentException
ÃÃ '
(
ÃÃ' (
$"
ÃÃ( *
$str
ÃÃ* 0
{
ÃÃ0 1
key
ÃÃ1 4
}
ÃÃ4 5
$str
ÃÃ5 O
"
ÃÃO P
)
ÃÃP Q
;
ÃÃQ R
}
ÕÕ 	
}
ŒŒ 
private
ËË 
bool
ËË 
Remove
ËË 
(
ËË "
BinarySearchTreeNode
ËË ,
<
ËË, -
TKey
ËË- 1
>
ËË1 2
?
ËË2 3
parent
ËË4 :
,
ËË: ;"
BinarySearchTreeNode
ËË< P
<
ËËP Q
TKey
ËËQ U
>
ËËU V
?
ËËV W
node
ËËX \
,
ËË\ ]
TKey
ËË^ b
key
ËËc f
)
ËËf g
{
ÈÈ 
if
ÍÍ 

(
ÍÍ 
node
ÍÍ 
is
ÍÍ 
null
ÍÍ 
||
ÍÍ 
parent
ÍÍ "
is
ÍÍ# %
null
ÍÍ& *
)
ÍÍ* +
{
ÎÎ 	
return
ÏÏ 
false
ÏÏ 
;
ÏÏ 
}
ÌÌ 	
var
ÔÔ 
compareResult
ÔÔ 
=
ÔÔ 
comparer
ÔÔ $
.
ÔÔ$ %
Compare
ÔÔ% ,
(
ÔÔ, -
node
ÔÔ- 1
.
ÔÔ1 2
Key
ÔÔ2 5
,
ÔÔ5 6
key
ÔÔ7 :
)
ÔÔ: ;
;
ÔÔ; <
if
ÒÒ 

(
ÒÒ 
compareResult
ÒÒ 
>
ÒÒ 
$num
ÒÒ 
)
ÒÒ 
{
ÚÚ 	
return
ÛÛ 
Remove
ÛÛ 
(
ÛÛ 
node
ÛÛ 
,
ÛÛ 
node
ÛÛ  $
.
ÛÛ$ %
Left
ÛÛ% )
,
ÛÛ) *
key
ÛÛ+ .
)
ÛÛ. /
;
ÛÛ/ 0
}
ÙÙ 	
if
ˆˆ 

(
ˆˆ 
compareResult
ˆˆ 
<
ˆˆ 
$num
ˆˆ 
)
ˆˆ 
{
˜˜ 	
return
¯¯ 
Remove
¯¯ 
(
¯¯ 
node
¯¯ 
,
¯¯ 
node
¯¯  $
.
¯¯$ %
Right
¯¯% *
,
¯¯* +
key
¯¯, /
)
¯¯/ 0
;
¯¯0 1
}
˘˘ 	"
BinarySearchTreeNode
˚˚ 
<
˚˚ 
TKey
˚˚ !
>
˚˚! "
?
˚˚" #
replacementNode
˚˚$ 3
;
˚˚3 4
if
ˇˇ 

(
ˇˇ 
node
ˇˇ 
.
ˇˇ 
Left
ˇˇ 
is
ˇˇ 
null
ˇˇ 
||
ˇˇ  
node
ˇˇ! %
.
ˇˇ% &
Right
ˇˇ& +
is
ˇˇ, .
null
ˇˇ/ 3
)
ˇˇ3 4
{
ÄÄ 	
replacementNode
ÅÅ 
=
ÅÅ 
node
ÅÅ "
.
ÅÅ" #
Left
ÅÅ# '
??
ÅÅ( *
node
ÅÅ+ /
.
ÅÅ/ 0
Right
ÅÅ0 5
;
ÅÅ5 6
}
ÇÇ 	
else
ÖÖ 
{
ÜÜ 	
var
áá 
predecessorNode
áá 
=
áá  !
GetMax
áá" (
(
áá( )
node
áá) -
.
áá- .
Left
áá. 2
)
áá2 3
;
áá3 4
Remove
àà 
(
àà 
Root
àà 
,
àà 
Root
àà 
,
àà 
predecessorNode
àà .
.
àà. /
Key
àà/ 2
)
àà2 3
;
àà3 4
replacementNode
ââ 
=
ââ 
new
ââ !"
BinarySearchTreeNode
ââ" 6
<
ââ6 7
TKey
ââ7 ;
>
ââ; <
(
ââ< =
predecessorNode
ââ= L
.
ââL M
Key
ââM P
)
ââP Q
{
ää 
Left
ãã 
=
ãã 
node
ãã 
.
ãã 
Left
ãã  
,
ãã  !
Right
åå 
=
åå 
node
åå 
.
åå 
Right
åå "
,
åå" #
}
çç 
;
çç 
}
éé 	
if
íí 

(
íí 
node
íí 
==
íí 
Root
íí 
)
íí 
{
ìì 	
Root
îî 
=
îî 
replacementNode
îî "
;
îî" #
}
ïï 	
else
ññ 
if
ññ 
(
ññ 
parent
ññ 
.
ññ 
Left
ññ 
==
ññ 
node
ññ  $
)
ññ$ %
{
óó 	
parent
òò 
.
òò 
Left
òò 
=
òò 
replacementNode
òò )
;
òò) *
}
ôô 	
else
öö 
{
õõ 	
parent
úú 
.
úú 
Right
úú 
=
úú 
replacementNode
úú *
;
úú* +
}
ùù 	
return
üü 
true
üü 
;
üü 
}
†† 
private
ßß "
BinarySearchTreeNode
ßß  
<
ßß  !
TKey
ßß! %
>
ßß% &
GetMax
ßß' -
(
ßß- ."
BinarySearchTreeNode
ßß. B
<
ßßB C
TKey
ßßC G
>
ßßG H
node
ßßI M
)
ßßM N
{
®® 
if
©© 

(
©© 
node
©© 
.
©© 
Right
©© 
is
©© 
null
©© 
)
©© 
{
™™ 	
return
´´ 
node
´´ 
;
´´ 
}
¨¨ 	
return
ÆÆ 
GetMax
ÆÆ 
(
ÆÆ 
node
ÆÆ 
.
ÆÆ 
Right
ÆÆ  
)
ÆÆ  !
;
ÆÆ! "
}
ØØ 
private
∂∂ "
BinarySearchTreeNode
∂∂  
<
∂∂  !
TKey
∂∂! %
>
∂∂% &
GetMin
∂∂' -
(
∂∂- ."
BinarySearchTreeNode
∂∂. B
<
∂∂B C
TKey
∂∂C G
>
∂∂G H
node
∂∂I M
)
∂∂M N
{
∑∑ 
if
∏∏ 

(
∏∏ 
node
∏∏ 
.
∏∏ 
Left
∏∏ 
is
∏∏ 
null
∏∏ 
)
∏∏ 
{
ππ 	
return
∫∫ 
node
∫∫ 
;
∫∫ 
}
ªª 	
return
ΩΩ 
GetMin
ΩΩ 
(
ΩΩ 
node
ΩΩ 
.
ΩΩ 
Left
ΩΩ 
)
ΩΩ  
;
ΩΩ  !
}
ææ 
private
≈≈ 
IList
≈≈ 
<
≈≈ 
TKey
≈≈ 
>
≈≈ 
GetKeysInOrder
≈≈ &
(
≈≈& '"
BinarySearchTreeNode
≈≈' ;
<
≈≈; <
TKey
≈≈< @
>
≈≈@ A
?
≈≈A B
node
≈≈C G
)
≈≈G H
{
∆∆ 
if
«« 

(
«« 
node
«« 
is
«« 
null
«« 
)
«« 
{
»» 	
return
…… 
new
…… 
List
…… 
<
…… 
TKey
……  
>
……  !
(
……! "
)
……" #
;
……# $
}
   	
var
ÃÃ 
result
ÃÃ 
=
ÃÃ 
new
ÃÃ 
List
ÃÃ 
<
ÃÃ 
TKey
ÃÃ "
>
ÃÃ" #
(
ÃÃ# $
)
ÃÃ$ %
;
ÃÃ% &
result
ÕÕ 
.
ÕÕ 
AddRange
ÕÕ 
(
ÕÕ 
GetKeysInOrder
ÕÕ &
(
ÕÕ& '
node
ÕÕ' +
.
ÕÕ+ ,
Left
ÕÕ, 0
)
ÕÕ0 1
)
ÕÕ1 2
;
ÕÕ2 3
result
ŒŒ 
.
ŒŒ 
Add
ŒŒ 
(
ŒŒ 
node
ŒŒ 
.
ŒŒ 
Key
ŒŒ 
)
ŒŒ 
;
ŒŒ 
result
œœ 
.
œœ 
AddRange
œœ 
(
œœ 
GetKeysInOrder
œœ &
(
œœ& '
node
œœ' +
.
œœ+ ,
Right
œœ, 1
)
œœ1 2
)
œœ2 3
;
œœ3 4
return
–– 
result
–– 
;
–– 
}
—— 
private
ÿÿ 
IList
ÿÿ 
<
ÿÿ 
TKey
ÿÿ 
>
ÿÿ 
GetKeysPreOrder
ÿÿ '
(
ÿÿ' ("
BinarySearchTreeNode
ÿÿ( <
<
ÿÿ< =
TKey
ÿÿ= A
>
ÿÿA B
?
ÿÿB C
node
ÿÿD H
)
ÿÿH I
{
ŸŸ 
if
⁄⁄ 

(
⁄⁄ 
node
⁄⁄ 
is
⁄⁄ 
null
⁄⁄ 
)
⁄⁄ 
{
€€ 	
return
‹‹ 
new
‹‹ 
List
‹‹ 
<
‹‹ 
TKey
‹‹  
>
‹‹  !
(
‹‹! "
)
‹‹" #
;
‹‹# $
}
›› 	
var
ﬂﬂ 
result
ﬂﬂ 
=
ﬂﬂ 
new
ﬂﬂ 
List
ﬂﬂ 
<
ﬂﬂ 
TKey
ﬂﬂ "
>
ﬂﬂ" #
(
ﬂﬂ# $
)
ﬂﬂ$ %
;
ﬂﬂ% &
result
‡‡ 
.
‡‡ 
Add
‡‡ 
(
‡‡ 
node
‡‡ 
.
‡‡ 
Key
‡‡ 
)
‡‡ 
;
‡‡ 
result
·· 
.
·· 
AddRange
·· 
(
·· 
GetKeysPreOrder
·· '
(
··' (
node
··( ,
.
··, -
Left
··- 1
)
··1 2
)
··2 3
;
··3 4
result
‚‚ 
.
‚‚ 
AddRange
‚‚ 
(
‚‚ 
GetKeysPreOrder
‚‚ '
(
‚‚' (
node
‚‚( ,
.
‚‚, -
Right
‚‚- 2
)
‚‚2 3
)
‚‚3 4
;
‚‚4 5
return
„„ 
result
„„ 
;
„„ 
}
‰‰ 
private
ÎÎ 
IList
ÎÎ 
<
ÎÎ 
TKey
ÎÎ 
>
ÎÎ 
GetKeysPostOrder
ÎÎ (
(
ÎÎ( )"
BinarySearchTreeNode
ÎÎ) =
<
ÎÎ= >
TKey
ÎÎ> B
>
ÎÎB C
?
ÎÎC D
node
ÎÎE I
)
ÎÎI J
{
ÏÏ 
if
ÌÌ 

(
ÌÌ 
node
ÌÌ 
is
ÌÌ 
null
ÌÌ 
)
ÌÌ 
{
ÓÓ 	
return
ÔÔ 
new
ÔÔ 
List
ÔÔ 
<
ÔÔ 
TKey
ÔÔ  
>
ÔÔ  !
(
ÔÔ! "
)
ÔÔ" #
;
ÔÔ# $
}
 	
var
ÚÚ 
result
ÚÚ 
=
ÚÚ 
new
ÚÚ 
List
ÚÚ 
<
ÚÚ 
TKey
ÚÚ "
>
ÚÚ" #
(
ÚÚ# $
)
ÚÚ$ %
;
ÚÚ% &
result
ÛÛ 
.
ÛÛ 
AddRange
ÛÛ 
(
ÛÛ 
GetKeysPostOrder
ÛÛ (
(
ÛÛ( )
node
ÛÛ) -
.
ÛÛ- .
Left
ÛÛ. 2
)
ÛÛ2 3
)
ÛÛ3 4
;
ÛÛ4 5
result
ÙÙ 
.
ÙÙ 
AddRange
ÙÙ 
(
ÙÙ 
GetKeysPostOrder
ÙÙ (
(
ÙÙ( )
node
ÙÙ) -
.
ÙÙ- .
Right
ÙÙ. 3
)
ÙÙ3 4
)
ÙÙ4 5
;
ÙÙ5 6
result
ıı 
.
ıı 
Add
ıı 
(
ıı 
node
ıı 
.
ıı 
Key
ıı 
)
ıı 
;
ıı 
return
ˆˆ 
result
ˆˆ 
;
ˆˆ 
}
˜˜ 
private
ˇˇ "
BinarySearchTreeNode
ˇˇ  
<
ˇˇ  !
TKey
ˇˇ! %
>
ˇˇ% &
?
ˇˇ& '
Search
ˇˇ( .
(
ˇˇ. /"
BinarySearchTreeNode
ˇˇ/ C
<
ˇˇC D
TKey
ˇˇD H
>
ˇˇH I
?
ˇˇI J
node
ˇˇK O
,
ˇˇO P
TKey
ˇˇQ U
key
ˇˇV Y
)
ˇˇY Z
{
ÄÄ 
if
ÅÅ 

(
ÅÅ 
node
ÅÅ 
is
ÅÅ 
null
ÅÅ 
)
ÅÅ 
{
ÇÇ 	
return
ÉÉ 
default
ÉÉ 
;
ÉÉ 
}
ÑÑ 	
var
ÜÜ 
compareResult
ÜÜ 
=
ÜÜ 
comparer
ÜÜ $
.
ÜÜ$ %
Compare
ÜÜ% ,
(
ÜÜ, -
node
ÜÜ- 1
.
ÜÜ1 2
Key
ÜÜ2 5
,
ÜÜ5 6
key
ÜÜ7 :
)
ÜÜ: ;
;
ÜÜ; <
if
áá 

(
áá 
compareResult
áá 
>
áá 
$num
áá 
)
áá 
{
àà 	
return
ââ 
Search
ââ 
(
ââ 
node
ââ 
.
ââ 
Left
ââ #
,
ââ# $
key
ââ% (
)
ââ( )
;
ââ) *
}
ää 	
if
åå 

(
åå 
compareResult
åå 
<
åå 
$num
åå 
)
åå 
{
çç 	
return
éé 
Search
éé 
(
éé 
node
éé 
.
éé 
Right
éé $
,
éé$ %
key
éé& )
)
éé) *
;
éé* +
}
èè 	
return
ëë 
node
ëë 
;
ëë 
}
íí 
}ìì 